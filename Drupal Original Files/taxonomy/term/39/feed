<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xml:base="https://web-engineering.info"  xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel>
 <title>web-engineering.info - Android</title>
 <link>https://web-engineering.info/taxonomy/term/39</link>
 <description></description>
 <language>en</language>
<item>
 <title>Building a WiFi-connected weather station with an Android user interface for less than 30 Euro</title>
 <link>https://web-engineering.info/node/52</link>
 <description>&lt;div class=&quot;field field-name-body field-type-text-with-summary field-label-hidden view-mode-rss&quot;&gt;&lt;div class=&quot;field-items&quot;&gt;&lt;div class=&quot;field-item even&quot; property=&quot;content:encoded&quot;&gt;&lt;article&gt;
&lt;header&gt;
&lt;h1&gt;Building a WiFi-Connected Weather Station&lt;/h1&gt;
&lt;/header&gt;

&lt;h4&gt;&lt;a href=&quot;/sites/default/files/weather_station/WeatherStationComplete.zip&quot;&gt;Download Code and Documentation&lt;/a&gt;&lt;/h4&gt;

&lt;section&gt;
&lt;p&gt;In this tutorial we show how to build a WiFi-connected weather station with the help of an Arduino Pro Mini (or, alternatively, a Nano, UNO, or MEGA2560), an ESP8266 WiFi module, a DHT22 temperature and humidity sensor and an Android device (smartphone, tablet, watch, etc) for configuring the weather station and for observing the sensor data. The total cost of this project, excluding the Android device, is less than 30 €.&lt;/p&gt;

&lt;p&gt;The design goals of our project are:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;&lt;em&gt;simplicity&lt;/em&gt;: the solution must be simple and easy to build even for a beginner;&lt;/li&gt;
	&lt;li&gt;&lt;em&gt;usability&lt;/em&gt;: the temperature (in the range [-30, 50]°C) and humidity (in the range [10 - 100]%) values can be read over WiFi and visualized by using an Android device (smartphone, tablet, watch, etc);&lt;/li&gt;
	&lt;li&gt;&lt;em&gt;low cost&lt;/em&gt;: the target is 30€ or less, excluding the Android device;&lt;/li&gt;
	&lt;li&gt;&lt;em&gt;maintainability&lt;/em&gt;: must be possible to add new sensors and functionality when needed, and we should be able to repair it if something goes wrong.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One can buy devices with similar features, but the price range starts at about 75 EUR and more. Also, these devices cannot be easily modified, most of them using SMD (surface mount devices) and integrated ICs, thus a possible improvement or repair when needed is either hard or impossible.&lt;/p&gt;

&lt;p&gt;In addition, because it is easy to do and it costs nothing (except a few MCU cycles and a few minutes of programming), we can easily add a few other features:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;a voltmeter for the 5V power supply - it is fairly easy because the ATmega 328 (but also ATmega 168 and some other) MCU comes with a builtin voltmeter (voltage sensor), which has a relatively low accurracy if not calibrated, but provides valuable information with no additional costs;&lt;/li&gt;
	&lt;li&gt;the amount of free RAM for the Arduino MCU - mainly used for debugging reasons, it provides useful information for later improvements. Same as for the voltmeter, no additional hardware is required, and it only costs a few MCU cycles with respect to MCU usage;&lt;/li&gt;
	&lt;li&gt;compute the average temperature and humidity - this is done in the software, and provides useful information for the weather station user.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; working with electricity is dangerous. For this project we use 5V and 3.3V voltage levels, which is safe for the human body under any environment conditions. However, the low voltage is obtained from a mains connected power brick, and therefore we highly recommend you to take safety precautions and to use a trustful brand for the power supply. We cannot be held responsible for any caused damage! Do it at your own risk and/or ask help from an electronics engineer.&lt;/p&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h2&gt;Hardware configuration&lt;/h2&gt;
&lt;/header&gt;

&lt;p&gt;The hardware components required for this project are presented below. These components were mostly bought from eBay and Amazon, and the listed prices include postage costs within Germany (for some also in the EU). If you are willing to wait between two and five weeks to receive the items, you can also buy them from China online shops (Aliexpress, eBay, and so on), for less than half of the prices we show further.&lt;/p&gt;

&lt;table&gt;
	&lt;thead&gt;
		&lt;tr&gt;
			&lt;th style=&quot;min-width: 150px;&quot;&gt;Hardware Component&lt;/th&gt;
			&lt;th style=&quot;min-width: 120px;&quot;&gt;Estimative Price&lt;/th&gt;
			&lt;th&gt;Description&lt;/th&gt;
		&lt;/tr&gt;
	&lt;/thead&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;a href=&quot;https://www.arduino.cc/en/Main/ArduinoBoardProMini&quot;&gt;Arduino Pro Mini&lt;/a&gt;&lt;/td&gt;
			&lt;td&gt;3 - 5 EUR&lt;/td&gt;
			&lt;td&gt;We use a clone, but it has the same functionality as the original device. While the quality of the original Arduino Pro Mini is higher, so it is the price (two to four times higher).&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;a href=&quot;http://www.esp8266.com/wiki/doku.php?id=esp8266-module-family#esp-02&quot;&gt;ESP8266-02&lt;/a&gt; WiFi module&lt;/td&gt;
			&lt;td&gt;6 - 8 EUR&lt;/td&gt;
			&lt;td&gt;Most of these modules have a 4Mb (512KB) flash memory, allowing to use AT firmware version below 1.1.0 ( released on June 2015). New modules are now available, and the SPI flash IC was updated to an 8Mb (1MB) one, allowing them to use the latest AT firmware, which provides more and improved AT commands. We strongly recommend to use an ESP8266 module with 1MB flash and latest AT firmware.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;a href=&quot;https://learn.sparkfun.com/tutorials/using-the-logic-level-converter&quot;&gt;Logic Converter&lt;/a&gt; module&lt;/td&gt;
			&lt;td&gt;1 - 3 EUR&lt;/td&gt;
			&lt;td&gt;It is used to convert 5V to 3.3V required for the UART communication between the Arduino board and the ESP8266 WiFi module. Some of these devices support also 2.5V and 1.8V levels.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;a href=&quot;https://learn.adafruit.com/dht/overview&quot;&gt;DHT22 &lt;/a&gt; temperature and humidity sensor&lt;/td&gt;
			&lt;td&gt;4 - 6 EUR&lt;/td&gt;
			&lt;td&gt;May be replaced with DHT11 sensor module if negative temperatures are not required and its lower accuracy is ok for you. It contains a temperature and relative air humidity sensor in one package, and uses a 1-Wire digital custom interface for data communication.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;a href=&quot;http://www.ti.com/lit/ds/symlink/lm317.pdf&quot;&gt;LM317&lt;/a&gt; Step-Down Linear Voltage regulator&lt;/td&gt;
			&lt;td&gt;approx. 0.5 EUR per piece, 2 - 3 EUR for a set of 10&lt;/td&gt;
			&lt;td&gt;It requires two additional resistors (or one resistor and one potentiometer) and two additional capacitors, with a total cost of about 1 EUR. We use it to lower the voltage down to 3.3V but it can be adjusted for values between 1.25 and 37V. This device is capable to supply maximum 1.5A current with proper cooling (not required for our case).&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;One red/green Duo LED, or two separate red and green LEDs&lt;/td&gt;
			&lt;td&gt;approx. 0.5 EUR per piece of 2 EUR for a set of 10&lt;/td&gt;
			&lt;td&gt;A common cathode (GND in our case) LED is a good choice for the DUO LED. Two separate LEDs of any size and color may be used as long as they require less than 20-25mA and have a forward voltage less than 5V (supplied by the Arduino I/O pins).&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;5V@1A regulated power brick&lt;/td&gt;
			&lt;td&gt;3-5 EUR&lt;/td&gt;
			&lt;td&gt;A ±5% variation is allowed for the regulated power brick. Notice that cheap and low quality power supplies are not recommended since often they have a bad regulation and usually out of the ±5% error range, so it may produce damage to the other components or even put your live in danger. A power brick with a higher Ampere value can be used, but usually these are more expensive. In addition, one can use an USB port as power supply for our device, that is able to supply 500mA or more current (USB ports of some laptops are not appropriate).&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3&gt;Weather Station Hardware Design&lt;/h3&gt;

&lt;p&gt;There are applications one can use to design electronic schematics, but most of the time, these are not easy to understand for beginners. We choose to use &lt;a href=&quot;http://fritzing.org&quot;&gt;Fritzing&lt;/a&gt;, which allows to draw nice looking breadboard oriented designs, but also schematics and PCB layouts. It also provides a builtin environment which integrates with the Arduino Software and allows to write the Arduino code, compile it and deploy it on the Arduino board. The hardware prototype on a breadboard is shown in &lt;a href=&quot;#completeBreadboardFig&quot;&gt;Figure 1&lt;/a&gt;:&lt;/p&gt;

&lt;figure id=&quot;completeBreadboardFig&quot;&gt;&lt;img src=&quot;/sites/default/files/weather_station/full_schematic_breadboard.svg&quot; /&gt;
&lt;figcaption&gt;Figure 1: The Complete Breadboard Design for the Weather Station Hardware.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;The hardware is divided in a few blocks:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;&lt;em&gt;the power supply&lt;/em&gt;: Arduino Pro Mini board needs 5-12V (obtained from a 5V@1A power brick), but the ESP8266 WiFi module requires 3.3V regulated voltage which we obtain by using a step-down linear regulator.&lt;/li&gt;
	&lt;li&gt;&lt;em&gt;the sensor node controller&lt;/em&gt;: the Arduino Pro Mini board represents the controller board, which runs all the logic for this project;&lt;/li&gt;
	&lt;li&gt;&lt;em&gt;an WiFi communication module&lt;/em&gt;: we have used the cheap and easy to use ESP8266 module for the WiFi communication between the sensor node and the Android device;&lt;/li&gt;
	&lt;li&gt;&lt;em&gt;the sensor(s)&lt;/em&gt;: temperature and humidity values are obtained from a DHT22 sensor;&lt;/li&gt;
	&lt;li&gt;&lt;em&gt;logic level voltage converter&lt;/em&gt;: allows a voltage safe Serial/UART communication between the Arduino board which uses 5V signals and the ESP8266 module which requires 3.3V signals;&lt;/li&gt;
	&lt;li&gt;&lt;em&gt;WiFi status LEDs&lt;/em&gt;: a DUO, common cathode green/red LED, is used to visually indicate the WiFi state.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; many of the breadboards we are aware of, does not have a default connection between the GND lines for the two power grids, therefore you need to add a connection wire between the two GND lines, as shown in &lt;a href=&quot;#completeBreadboardFig&quot;&gt;Figure 1&lt;/a&gt;. Also, some breadboards have every power grid splited in two halfs, so you have to use a jumper wire if this is the case.&lt;/p&gt;

&lt;p&gt;For the breadboard schematic, red wires were used for +5V, orange for 3.3V and black for GND connections. For communication lines, we use green and blue for RX/TX lines, and yellow for data pin of DHT22 sensor. In &lt;a href=&quot;#fig2&quot;&gt;Figure 2&lt;/a&gt;, we show the full electronics schematic, of our weather station sensor node.&lt;/p&gt;

&lt;figure id=&quot;fig2&quot;&gt;&lt;img src=&quot;/sites/default/files/weather_station/full_schematic.png&quot; /&gt;
&lt;figcaption&gt;Figure 2: The Complete Schematic Design for Weather Station Hardware.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h3&gt;The ESP8266 3.3V Power Supply&lt;/h3&gt;
&lt;/header&gt;

&lt;p&gt;Our sensor node is powered by a regulated 5V@1A power brick. The Arduino Pro Mini board and most of components can directly use the 5V rail comming from the power brick. The regulation down to 3.3V, required by the ESP8266 WiFi module, is obtained by using the LM317T IC, an adjustable step-down linear voltage regulator. It only requires a few additional components: two resistors and two capacitors. It is able to provide up to 1.5A current, with appropriate cooling. However, for our example cooling is not needed, the average current being under 250mA (going up to 500mA but only for very short amounts of time, when the ESP8266 module transmits data). &lt;a href=&quot;#fig2&quot;&gt;Figure 3&lt;/a&gt; shows the 3.3V power supply built on a breadboard, and &lt;a href=&quot;#fig4&quot;&gt;Figure 4&lt;/a&gt; shows the corresponding electronics schematic..&lt;/p&gt;

&lt;figure id=&quot;fig3&quot;&gt;&lt;img src=&quot;/sites/default/files/weather_station/power_supply_breadboard.svg&quot; /&gt;
&lt;figcaption&gt;Figure 3: The 3.3V Power Supply on a Breadboard.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure id=&quot;fig4&quot;&gt;&lt;img src=&quot;/sites/default/files/weather_station/power_supply_schematic.svg&quot; /&gt;
&lt;figcaption&gt;Figure 4: The Schematics for the 3.3V Power Supply.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;The values of the R1 and R2 resistors are chosen according with the following rules:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;the value of R1 must be in the range 100 - 1000Ω, as specified in the LM317 IC datasheet;&lt;/li&gt;
	&lt;li&gt;both, R1 and R2 are standard resistor values, so easily available in any electronics shop;&lt;/li&gt;
	&lt;li&gt;the equation, provided by the LM317 IC datasheet, &lt;code&gt;Vout = 1.25 ( 1 + R2 / R1)&lt;/code&gt; is verified, when &lt;code&gt;Vout ~= 3.3&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The real output voltage, for &lt;code&gt;R1 = 330Ω&lt;/code&gt; and &lt;code&gt;R2 = 560Ω&lt;/code&gt; is &lt;code&gt;Vout ~= 3.37V&lt;/code&gt;, so the maximum ±5% error is within specifications. &lt;code&gt;C1&lt;/code&gt; is a ceramic capacitor with a value of &lt;code&gt;0.1µF&lt;/code&gt; ( &lt;code&gt;100nF&lt;/code&gt;), being used to filter high frequency spikes and to prevent internal oscillation for the &lt;code&gt;LM317T&lt;/code&gt; IC. &lt;code&gt;C2&lt;/code&gt; is an electrolytic capacitor with a value of &lt;code&gt;1µF&lt;/code&gt; (higher values, up to about &lt;code&gt;1000µF&lt;/code&gt; can be used), and its purpose is to smooth the output voltage (3.3V line). The designed voltage of &lt;code&gt;C2&lt;/code&gt; must be higher than &lt;code&gt;3.3V&lt;/code&gt;, and it is very important to mount the capacitor with the correct polarity. Electrolytic capacitors are very prone to small explosions if missused, such as mounting them in reverse polarity or use them with voltages over their specification.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; instead of the fixed value R2 resistor, a 1KΩ potentiometer can be used. In this case, a more precise output voltage is obtained if (and when) really needed. This way you can also use a lower value for R1, and a good choice is 240Ω, as recommended in the LM317 datasheet.&lt;/p&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h3&gt;Serial Communication via Voltage Lever Converter&lt;/h3&gt;
&lt;/header&gt;

&lt;p&gt;Arduino Pro Mini board is powered by a 5V power supply, so it allows to use 5V on the UART RX and TX communication lines. ESP8266 Wifi module on the other hand uses 3.3V power supply, and it is not 5V tolerant for the VCC, RX, TX or any of its other available I/O lines. Therefore a direct connection between the RX/TX lines of the Arduino board and the RX/TX lines of the ESP8266 module is not possible, and ignoring this warning may very likely result in damaging the ESP8266 module. A simple solution for this case is to use a readily available logic converter module. Its provides 3.3V lines (some also allows 1.8V, 2.5V and 2.8V) as well as 5V communication lines. Notice that such a module can provide very low current (in the range of a few mA) on each of the lines, therefore it must be used only for data communication and not as a voltage regulator. We use a four channel module, so it provides four low voltage (3.3V) lines with four corresponding high voltage (5V) lines. Two lines are used for UART communication and the other two are used for connecting the CH_PD and RESET lines of the ESP8266 module with the pin 2 and respectively 3 of the Arduino board.&lt;/p&gt;

&lt;p&gt;It is important to notice that the RX/TX line of the Arduino Pro Mini board have to be cross-connected with the RX/TX lines of the ESP8266 module. This means: the RX line of the Arduino board connects to the TX line of the ESP8266 module and the TX line of the Arduino board connects to the RX line of the ESP8266 module. These connection is made via the logic level converter module as already explained above and also shown in &lt;a href=&quot;#completeBreadboardFig&quot;&gt;Figure 1&lt;/a&gt; and &lt;a href=&quot;#fig2&quot;&gt;Figure 2&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;CH_PD&lt;/em&gt; (channel power down) and &lt;em&gt;RESET&lt;/em&gt; pins of the ESP8266 module needs to be connected to VCC (+3.3V) line via 3.3KΩ resistors. Normally, a 10KΩ resistor can be used, but we observed periodical resets of our WiFi module (we tested a few of them). Using test and trial method, we found that the 3.3KΩ resistor works the best for all our ESP8266 modules.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; the ESP8266-01 module is shown in the schematic, since this was available as Fritzing component, but actually in the real board we use an ESP8266-02 module. This should make no difference, and in general we should be able to use any version of these modules. There are about thirteen versions of ESP8266 modules, which differes in form, size and available I/O, but all have the same WiFi functionality.&lt;/p&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h3&gt;DHT22 Sensor&lt;/h3&gt;
&lt;/header&gt;

&lt;p&gt;The DHT22 sensor allows to obtain temperature readings in the range &lt;code&gt;[-40, 80]°C&lt;/code&gt; with a typical accuracy of &lt;code&gt;±0.5°C&lt;/code&gt; and a resolutin of &lt;code&gt;0.1 units (°C)&lt;/code&gt;. However, in real tests, the accuracy we could observe is closer to &lt;code&gt;±1°C&lt;/code&gt;. The sensor can also read humidity values in the range &lt;code&gt;[0, 100]%&lt;/code&gt;, with a typical accuracy of &lt;code&gt;±2 units (%)&lt;/code&gt; and a resolution of &lt;code&gt;0.1 units&lt;/code&gt;. In our real tests, the accuracy was about ±5%.&lt;/p&gt;

&lt;p&gt;The DHT22 sensor can be connected to either 3.3V line or to 5V line, and we decided to use the 5V line. The data pin of the sensor (check the &lt;a href=&quot;https://www.adafruit.com/datasheets/Digital%20humidity%20and%20temperature%20sensor%20AM2302.pdf&quot;&gt; datasheet &lt;/a&gt; for more details) is connected to 5V rail via one 10KΩ resistor, to avoid communication errors (this line must stay HIGH when the sensor does not communicate via the data pin). The sensor data pin is connected to digital pin 9 of the Arduino board.&lt;/p&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h3&gt;WiFi Status LEDs&lt;/h3&gt;
&lt;/header&gt;

&lt;p&gt;During the tests, we found that it is good to know the actual state of the ESP8266 module, specially because the module becomes unresponsive sometimes. We have used a DUO red/green LED, which is actually composed of one green and one red LEDs in a single physical package, and which share a common cathode (GND) connection. The green LED anode was connected to pin 8 of the Arduino Pro Mini board via a 560Ω resistor, thus allowing about 5mA current passing through the LED. The red LED anode was connected to pin 7 of the Arduino Pro Mini board via a 560Ω resistor, thus allowing about 6mA current passing through the LED.&lt;/p&gt;

&lt;p&gt;A LED should never be directly connected between the VCC and GND lines (or directly to I/O pins of an MCU) with the exception of special LEDs which are designed for this, on which case they have a builtin resistor or use other current limiting design. Instead one must use a series resistor to limit the current passing through the LED. Using &lt;a href=&quot;https://en.wikipedia.org/wiki/Ohm%27s_law&quot;&gt;Ohm&#039;s Law&lt;/a&gt; we can compute the value of the resistor by knowing the LED forward voltage (the voltage to which the LED starts conducting and emmiting light), the used supply voltage and the current we want to allow passing through the LED (which controls the LED brightness). A standard red LED has about 1.7V forward voltage, a green or orange LED has about 2V forward voltage, a white or blue led has about 2.7V forward voltage. Since we only need the LEDs to provide visual indication, they don&#039;t have to lighting very bright. After testing our DUO LED, we decided that a value of 6mA is desired for the red LED and a value of 5mA for the green LED (green light is more visible for human eye than other colors). Applying Ohm&#039;s Law, we have &lt;code&gt;V = IR&lt;/code&gt;, so &lt;code&gt;R = V / I&lt;/code&gt;. For our case, V is the difference between the power supply voltage (+5V) and the LED forward voltage. Solving the equation for the red LED we have &lt;code&gt;R = (5 - 1.7) / 0.006&lt;/code&gt;, which give us &lt;code&gt;R = 550Ω&lt;/code&gt;. Since 550Ω is not a standard value, the next available standard resistor value can be used, that being 560Ω. As homework, you can do the computations for the green LED.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; if you don&#039;t have a DUO LED, just use two normal LEDs. Also, you can use other LED colors if you like, and even different resistor values to obtain different brightness levels (use Ohm&#039;s Law to find the appropriate resistor value). A standard 3mm or 5mm LED usually stands up to 20mA of current, after this point it gets too warm and it is very likely that it gets burned. However some LEDs can stand much more current, but they need special drivers. Also, notice that you should not draw more than 20mA from each of the Arduino pins, or you may damage the board.&lt;/p&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h3&gt;Hardware Summary Overview&lt;/h3&gt;
&lt;/header&gt;
In the tables below, a summary of the hardware components connection is shown:

&lt;table&gt;
	&lt;thead&gt;
		&lt;tr&gt;
			&lt;th&gt;Arduino Pro Mini Pin&lt;/th&gt;
			&lt;th&gt;Connects to&lt;/th&gt;
		&lt;/tr&gt;
	&lt;/thead&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;RX&lt;/td&gt;
			&lt;td&gt;Logic Level Converter first RX HV pin&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;TX&lt;/td&gt;
			&lt;td&gt;Logic Level Converter first TX HV pin&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;2&lt;/td&gt;
			&lt;td&gt;Logic Level Converter second RX HV pin&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;3&lt;/td&gt;
			&lt;td&gt;Logic Level Converter second TX HV pin&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;7&lt;/td&gt;
			&lt;td&gt;Red anode of the DUO LED via R4 (560Ω) resistor&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;8&lt;/td&gt;
			&lt;td&gt;Green anode of the DUO LED via R4 (560Ω) resistor&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;9&lt;/td&gt;
			&lt;td&gt;Data pin of the DHT22 sensor&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;VCC&lt;/td&gt;
			&lt;td&gt;VCC (+5V) rail of the power supply&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;GND&lt;/td&gt;
			&lt;td&gt;GND rail of the power supply&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
	&lt;thead&gt;
		&lt;tr&gt;
			&lt;th&gt;Logic Level Converter PIN&lt;/th&gt;
			&lt;th&gt;Connects to&lt;/th&gt;
		&lt;/tr&gt;
	&lt;/thead&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;First TX LV&lt;/td&gt;
			&lt;td&gt;RX pin of the ESP8266 module&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;First RX LV&lt;/td&gt;
			&lt;td&gt;TX pin of the ESP8266 module&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;First TX HV&lt;/td&gt;
			&lt;td&gt;TX pin of the Arduino Pro Mini board&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;First RX HV&lt;/td&gt;
			&lt;td&gt;RX pin of the Arduino Pro Mini board&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Second TX LV&lt;/td&gt;
			&lt;td&gt;RESET pin of the ESP8266 module&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Second RX LV&lt;/td&gt;
			&lt;td&gt;CH_PD pin of the ESP8266 module&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Second TX HV&lt;/td&gt;
			&lt;td&gt;Pin 3 of the Arduino Pro Mini board&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Second RX HV&lt;/td&gt;
			&lt;td&gt;Pin 2 of the Arduino Pro Mini board&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;LV GND&lt;/td&gt;
			&lt;td&gt;GND rail of the power supply&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;HV GND&lt;/td&gt;
			&lt;td&gt;GND rail of the power supply&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;LV&lt;/td&gt;
			&lt;td&gt;3.3V rail, obtained from the LM317 IC output pin&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;HV&lt;/td&gt;
			&lt;td&gt;5V rail of the power supply&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
	&lt;thead&gt;
		&lt;tr&gt;
			&lt;th&gt;ESP8266 Module Pin&lt;/th&gt;
			&lt;th&gt;Connects to&lt;/th&gt;
		&lt;/tr&gt;
	&lt;/thead&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;RX&lt;/td&gt;
			&lt;td&gt;First LV TX pin of the Logic Converter Module&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;TX&lt;/td&gt;
			&lt;td&gt;First LV RX pin of the Logic Converter Module&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;RESET&lt;/td&gt;
			&lt;td&gt;Second LV TX pin of the Logic Converter Module&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;CH_PD&lt;/td&gt;
			&lt;td&gt;Second LV RX pin of the Logic Converter Module&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;GND&lt;/td&gt;
			&lt;td&gt;GND rail of the power supply&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;VCC&lt;/td&gt;
			&lt;td&gt;3.3V rail, obtained from LM317 output pin&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
	&lt;thead&gt;
		&lt;tr&gt;
			&lt;th&gt;LM317 IC Pin&lt;/th&gt;
			&lt;th&gt;Connects to&lt;/th&gt;
		&lt;/tr&gt;
	&lt;/thead&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;Input&lt;/td&gt;
			&lt;td&gt;5V rail of the power supply&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Output&lt;/td&gt;
			&lt;td&gt;3.3V rail&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Adj&lt;/td&gt;
			&lt;td&gt;Output 3.3V rail via R1 and to GND rail via R2&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;/section&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h2&gt;Software Configuration&lt;/h2&gt;
&lt;/header&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h3&gt;The Arduino Code&lt;/h3&gt;
&lt;/header&gt;

&lt;p&gt;The Arduino code can be written, compiled and deployed to the Arduino board by either using &lt;a href=&quot;http://fritzing.org/&quot;&gt;Fritzing&lt;/a&gt; or the &lt;a href=&quot;https://www.arduino.cc/&quot;&gt;Arduino IDE&lt;/a&gt; (this may be preferred in some cases, because it usually works out of the box). For our project, the following Arduino libraries are needed:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;https://github.com/dimircea/Arduino-ESP8266&quot;&gt;Arduino-ESP8266&lt;/a&gt;, used for the UART communication between the ESP8266 module and the Arduino board. Clone the library repository, rename the folder to &lt;em&gt;ESP8266&lt;/em&gt; and copy it to &lt;em&gt;libraries&lt;/em&gt; subfolder, part of the Arduino Software installation folder.&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;https://github.com/RobTillaart/Arduino/tree/master/libraries/DHTlib&quot;&gt;DHTLib&lt;/a&gt;, used for the communication with the DHT22 sensor. This library supports DHT11 sensors as well, in case you use it as a replacement for DHT22. Clone the library repository, rename it to &lt;em&gt;DHT&lt;/em&gt; and copy it to &lt;em&gt;libraries&lt;/em&gt; subfolder, part of the Arduino Software installation folder.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;An Arduino program (also known as sketch) has the following minimal structure:&lt;/p&gt;

&lt;pre&gt;
// 1. constants definition (optional if no constant is needed)
// 2. include headers for used libraries ( optional if no library is used)
// 3. define the global variables (optional if no global variable is required)

// program initialization
void setup() { 
  // write here the setup code.
}

// infinite loop cycle
void loop() { 
  // the code from this method loops as long as the Arduino board is powered.
}              &lt;/pre&gt;

&lt;p&gt;In the &lt;code&gt;setup&lt;/code&gt; method we write initialization code, which is executed only once, when the Arduino is powered or after a software or hardware reset. The &lt;code&gt;loop&lt;/code&gt; method contains the code which loops in the Arduino MCU as long as the board receives power.&lt;/p&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h4&gt;Constants Definition for Arduino Pins Configuration&lt;/h4&gt;
&lt;/header&gt;

&lt;p&gt;First we define the constants representing the used Arduino board pins. It is highly recommended to use constants instead of using the pin numbers all over the code. This way, one can easily change the constant value instead of trying to find all the places where the pin number was used, if you decide that another pin has to be used.&lt;/p&gt;

&lt;pre&gt;
// Arduino pin number used for the communication with DHT22 sensor.
#define DHT22_PIN 9
// pins number for WiFi disabled LED
#define WIFI_DISABLED_LED_PIN 7
// pins number for WiFi enabled/active LED
#define WIFI_ACTIVE_LED_PIN 8
// arduino pin used to connect to the CH_PD (Power Down) WiFi module pin
#define WIFI_CH_PD_PIN 2
// arduino pin used to connect to the RESET WiFi module pin
#define WIFI_RESET_PIN 3&lt;/pre&gt;

&lt;p&gt;Pin 9 is used for data communication with the DHT22 sensor, pins 7 and 8 are used for the red and green LEDs (WiFi status LEDs), pin 2 allows to put the WiFi into a sleep mode (and to wake it up) and pin 3 allows us perform a hardware reset of the WiFi module, which requires to pull it down (set pin to LOW) for at least 200ms.&lt;/p&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h4&gt;Import Required Libraries for DHT22 and ESP8266 Modules&lt;/h4&gt;
&lt;/header&gt;

&lt;p&gt;We need to specify the libraries used by our program. This is done in the standard C/C++ style by using the &lt;code&gt;#include&lt;/code&gt; directive:&lt;/p&gt;

&lt;pre&gt;
#include &amp;lt;dht.h&amp;gt;
#include &amp;lt;ESP8266.h&amp;gt;                        &lt;/pre&gt;

&lt;p&gt;When using this directive, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; tells to the compiler and linker to look in the &lt;em&gt;libraries&lt;/em&gt; subfolder of the Arduino IDE installation, while using double quotes means the library files are in the your arduino skecth folder.&lt;/p&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h4&gt;Define Program Global Variables&lt;/h4&gt;
&lt;/header&gt;

&lt;p&gt;As in many (if not all) Arduino programs, we use some global variables:&lt;/p&gt;

&lt;pre&gt;
// DHT22 sensor controller class
dht DHT;

// ESP8266 WiFi module controller
ESP8266 esp( Serial);

// store the average temperature and humidity 
// values, starting with last system reset
float avgTemperature = 0;
float avgHumidity = 0;

// utility variable used to compute the averate temperature value
unsigned long avgDhtStep = 1;

// data template for sensors
const char SENSORS_DATA_TEMPLATE[] PROGMEM = 
    &quot;{\&quot;temperature\&quot;: %s, \&quot;avgTemperature\&quot;: %s, \&quot;humidity\&quot;: %s, \&quot;avgHumidity\&quot;: %s, \&quot;voltage\&quot;: %s, \&quot;freeRam\&quot;: %d}&quot;;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;dht22&lt;/code&gt; variable represents an instance of the library which controls the communication with the DHT22 sensor. The &lt;code&gt;esp&lt;/code&gt; variable represents an instance of the ESP8266 library used to communicate with the WiFi module. As parameter for the constructor we provide the &lt;code&gt;Serial&lt;/code&gt; object, so the communication is made on the UART0 port of the Arduino board. When using Arduino Pro Mini (also Nano or UNO) board, this is the only serial port available. However, the library is designed to work with all the Arduino boards, and some of them have up to four UART ports, accessed via &lt;code&gt;Serial&lt;/code&gt;, &lt;code&gt;Serial1&lt;/code&gt;, &lt;code&gt;Serial2&lt;/code&gt; and &lt;code&gt;Serial3&lt;/code&gt; global objects.&lt;/p&gt;

&lt;p&gt;Since we like to know the average temperature and humidity values measured by our Weather Station, we define the &lt;code&gt;avgTemperature&lt;/code&gt;, &lt;code&gt;avgHumidity&lt;/code&gt; and &lt;code&gt;avgDhtStep&lt;/code&gt; variables. The first two are used to store the average temperature and humidity values, while the latter is used to count how many time the temperature value was read, so the correct average value can be computed according with the formula: &lt;code&gt;avg = (avg * (n - 1) + newValue) / n&lt;/code&gt;;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;SENSORS_DATA_TEMPLATE&lt;/code&gt; variable stores the template (JSON structure) used to communicate with the Android application. The special &lt;code&gt;PROGMEM&lt;/code&gt; variable modifier enforces the storage of the value in the flash memory instead of RAM, thus freeing up about 120Bytes of RAM (about 6% of the total RAM of the ATmega328P MCU, used by the Arduino Pro Mini, Nano and UNO boards).&lt;/p&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h4&gt;Initializing the ESP8266 WiFi Module&lt;/h4&gt;
&lt;/header&gt;

&lt;p&gt;The ESP8266 module communicates with the Arduino MCU via the UART protocol. A hardware reset for the WiFi module is recommended to ensure a correct module state before starting the UART communication.&lt;/p&gt;

&lt;pre&gt;
void setupWiFi() {
  // STEP 1:
  // Set pins used for WiFi status LEDs as OUTPUT.
  pinMode( WIFI_ACTIVE_LED_PIN, OUTPUT);
  pinMode( WIFI_DISABLED_LED_PIN, OUTPUT);

  // STEP 2:
  // Arduino pin connected to ESP8266 CH_PD pin is set to OUTPUT.
  // To keep the module active, this pin must be kept HIGH.
  pinMode( WIFI_CH_PD_PIN, OUTPUT);
  digitalWrite( WIFI_CH_PD_PIN, HIGH);
  // Arduino pin connected to ESP8266 RESET pin is set to OUTPUT.
  // To avoid random resents, we keep this HIGH.
  pinMode( WIFI_RESET_PIN, OUTPUT);
  digitalWrite( WIFI_RESET_PIN, HIGH);

  // STEP 3:
  // perform a hardware reset (ESP8266 RESET pin goes LOW)
  digitalWrite( WIFI_RESET_PIN, LOW);
  delay( 200);
  // allow ESP8266 module to boot
  digitalWrite( WIFI_RESET_PIN, HIGH);

  // STEP 4:
  // baud 115200, communication with ESP8266 module
  Serial.begin( 115200);

  // STEP 5:
  // wait for the ESP8266 module to start, after the forced hardware reset.
  // We check the wifi state once a second, until the ESP8266 WiFi module responds.
  while( !checkWiFi()) {
    delay( 1000);
  };

  // STEP 6:
  // start UDP connection - wait on all ports
  esp.atCipstartUdp();
} &lt;/pre&gt;

&lt;p&gt;The WiFi module related initialization requires the following steps:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;The Arduino pins used for the WiFi status LEDs (i.e., defined by the &lt;code&gt;WIFI_ACTIVE_LED_PIN&lt;/code&gt; and &lt;code&gt;WIFI_DISABLED_LED_PIN&lt;/code&gt; constants) are set to output.&lt;/li&gt;
	&lt;li&gt;The Arduino pins used to control the CH_PD and RESET lines of the ESP8266 module (i.e., defined by the &lt;code&gt;WIFI_CH_PD_PIN&lt;/code&gt; and &lt;code&gt;WIFI_RESET_PIN constants&lt;/code&gt;) are set to OUTPUT, so we can set them LOW or HIGH depending on the case. These two pins needs to stay HIGH during the normal operation.&lt;/li&gt;
	&lt;li&gt;Perform a hardware reset by pulling down the WiFi module RESET pin (set it LOW for about 200ms).&lt;/li&gt;
	&lt;li&gt;Start UART/Serial communication with the module at 115200 baud rate.&lt;/li&gt;
	&lt;li&gt;Wait for the WiFi module to boot, which takes two seconds or more.&lt;/li&gt;
	&lt;li&gt;Start UDP communications, and wait for incomming data on all the ports. We could have used only one specific port, but we like to be flexible.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;UDP communication is used for the WiFi data transmission between the Android device and our Weather Station sensor node. The &lt;code&gt;checkWiFi&lt;/code&gt; method used to check if the WiFi module is in active state (communicates via UART lines) is shown below:&lt;/p&gt;

&lt;pre&gt;
boolean checkWiFi() {
  if( esp.at() == ESP8266::Error::NONE) {
    digitalWrite( WIFI_DISABLED_LED_PIN, LOW);
    digitalWrite( WIFI_ACTIVE_LED_PIN, HIGH);
    return true;
  } else { 
    digitalWrite( WIFI_ACTIVE_LED_PIN, LOW);
    digitalWrite( WIFI_DISABLED_LED_PIN, HIGH);
    return false;
  }
}&lt;/pre&gt;

&lt;p&gt;This method returns &lt;code&gt;true&lt;/code&gt; if the ESP8266 module responds to &lt;code&gt;AT&lt;/code&gt; command, and &lt;code&gt;false&lt;/code&gt; otherwise. The &lt;code&gt;AT&lt;/code&gt; command is used to check if the module is active, and it does not represents a real command for the module. In addition, the &lt;code&gt;checkWiFi&lt;/code&gt; method enables (or disables) the red/green LED, providing visual indication of the current WiFi state.&lt;/p&gt;

&lt;p&gt;Since the WiFi setup must run only once, when the hardware powers up, we call the &lt;code&gt;setupWiFi&lt;/code&gt; module inside the Arduino specific &lt;code&gt;setup&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;
void setup() {
  // setup WiFi - ESP8266 module
  setupWiFi();
  // add other code here...
}&lt;/pre&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h4&gt;Reading Data from the DHT22 Temperature and Humidity Sensor&lt;/h4&gt;
&lt;/header&gt;

&lt;p&gt;The DHT22 sensor provides temperature and humidity values for our sensor node. It has a refresh rate of 0.5Hz, meaning that we can&#039;t read data from this sensor faster than once every two seconds. Reading data is fairly easy, because of all the hard code is hidden by the DHTLib library. We write a method to obtain these values and compute the temperature and humidity averaged values.&lt;/p&gt;

&lt;pre&gt;
void updateDHTData() {
  if ( dht22.read22( DHT22_PIN) == DHTLIB_OK) {
    avgTemperature = ( avgTemperature * (avgDhtStep - 1) + dht22.temperature) / (float)avgDhtStep;
    avgHumidity = ( avgHumidity * (avgDhtStep - 1) + dht22.humidity) / (float)avgDhtStep;
  }
}&lt;/pre&gt;

&lt;p&gt;The latest temperature and humidity values are available by reading the &lt;code&gt;temperature&lt;/code&gt; and &lt;code&gt;humidity&lt;/code&gt; properties of the &lt;code&gt;dht22&lt;/code&gt; object. The &lt;code&gt;read22&lt;/code&gt; method is used to perform a reading when DHT22 sensor is used, but instead, one can use &lt;code&gt;read11&lt;/code&gt; to get the same effect when the DHT11 sensor is used. The method returns &lt;code&gt;DHTLIB_OK&lt;/code&gt; when the reading was successful, and various error codes if problems were encountered. For simplicity reasons, we ignore the possible errors, but in a further tutorial we discuss also how to solve such possible problems.&lt;/p&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h4&gt;Reading 5V Supply Voltage Value by Using the Secret Builtin Arduino Voltmeter&lt;/h4&gt;
&lt;/header&gt;

&lt;p&gt;Some ATmega MCUs, such as ATmega328/168(p) have a builtin voltage sensor, which can be accessed by the code. This sensor is not very accurate (accuracy is within ±10% range). It uses the builtin 1.1V voltage reference available for these MCUs (some other ATmega MCUs also have a 2.56V internal voltage reference). The following code allows to read the AVcc line voltage, which by default is connected to VCC line of the Arduino board:&lt;/p&gt;

&lt;pre&gt;
float getVcc() {
  long result;
  // read 1.1V reference against AVcc
  ADMUX = _BV(REFS0) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
  // wait for Vref to settle
  delay(2); 
  // convert
  ADCSRA |= _BV(ADSC); 
  while (bit_is_set(ADCSRA,ADSC));
  result = ADCL;
  result |= ADCH&amp;lt;&amp;lt;8;
  // Back-calculate AVcc in mV
  result = 1103700L / result; 
  // return response in volts
  return result / 1000.0;
}&lt;/pre&gt;

&lt;p&gt;While this looks complicated, it actually uses a few MCU registers and some bits operations to read the VCC value agains the builtin 1.1V voltage reference, which has a pretty good stability once calibrated. By using a good quality multimeter and a stable voltage source, it is possible to &quot;software calibrate&quot; the internal voltage reference for individual MCUs when needed.&lt;/p&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h4&gt;Computing the Free Amounf of RAM&lt;/h4&gt;
&lt;/header&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; a complete guide related to RAM usage optimization for Arduino MCUs as well as details on how to get the free amount of RAM are described on our blog article &lt;a href=&quot;/node/30&quot;&gt;Optimize Arduino Memory Usage&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;One last piece of data we like to collect is the amount of free RAM available on our Arduino MCU. This can be achieved by calling the &lt;code&gt;getFreeMCUMemory&lt;/code&gt; method, available as part of the ESP8266 library. It returns an integer representing the number of RAM bytes which are not used by the MCU at the moment of calling the method.&lt;/p&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h4&gt;WiFi Communication with the Android Device&lt;/h4&gt;
&lt;/header&gt;

&lt;p&gt;All the sensor data we collect needs to be sent to the Android device. The first step in this direction is to listen for data requests from the Android device (periodical data requests are initiated). For this we use the loop method and wait for incomming data:&lt;/p&gt;

&lt;pre&gt;
void loop() {
  char data[10] = {0}, *ipdData = data;
  // Incomming data from ESP8266 module
  // Lengt must be greater than 7 bytes (&quot;+IPD,n:&quot;)
  if ( Serial.available() &amp;gt; 7 &amp;amp;&amp;amp; esp.ipd( ipdData) == ESP8266::Error::NONE) {
    // process the request
    processRequest( ipdData);
  }
  // a small delay before checking againd for WiFi incomming data
  delay( 25);
}&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;ipd&lt;/code&gt; method, part of the ESP8266 library is used to split the received data over WiFi, and retain only the important parts. The WiFi module sends data in the following format: &lt;code&gt;+IPD,n,id:ipdData&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the &lt;code&gt;length&lt;/code&gt; of the &lt;code&gt;ipdData&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt; is the communication link ID (an integer between 0 and 4), and &lt;code&gt;ipdData&lt;/code&gt; represents the relevant data bytes. The first parameter of the &lt;code&gt;ipd&lt;/code&gt; method is a reference parameter, a pointer to the received databytes. This method has additional optional parameters, providing information about the number of databytes and the connection id. Further, a method named &lt;code&gt;processRequest&lt;/code&gt; is used to decode the data and perform required actions.&lt;/p&gt;

&lt;p&gt;Since we expect data in the &lt;code&gt;+IPD,n:&lt;/code&gt; format, (the link id is not used), it makes sense to process data only after receiving at least 7 bytes. In addition, for this simple project, we expect only a single databyte, representing the data update request. In a further version of this project we like to support much more commands, therefore we use this generic form. Also, for the same reasons, we define an enumeration which defines the list of the available commands:&lt;/p&gt;

&lt;pre&gt;
enum class Command {
  GET_ALL_SENSORS_DATA = 97
};&lt;/pre&gt;

&lt;p&gt;The data we receive via TX line of the ESP8266 module (so RX line of our Arduino board) is: &lt;code&gt;+IPD,1:a&lt;/code&gt;. The ascii representation for 97 (the &lt;code&gt;Command::GET_ALL_SENSORS_DATA&lt;/code&gt; enumeration literal) is the char &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;processRequest&lt;/code&gt; method code is shown below:&lt;/p&gt;

&lt;pre&gt;
void processRequest( char *data) {
  char progmemData[150] = {0};
  char *pData = progmemData;
  // first char represents the command
  char cmd = *(data); 
  switch ( (Command)cmd) {
    &lt;strong&gt;case Command::GET_ALL_SENSORS_DATA:
      createSensorsDataFromTemplate( pData);
      esp.atCipsend( pData);
    break;&lt;/strong&gt;
    default:
      // nothing to do ...
    break;
  }
}&lt;/pre&gt;
&lt;/section&gt;

&lt;p&gt;Its main purpose is to decode the received command and to respond with the required data. As discussed earlier, we only have one command, so also only one action case, but this will be extended, so we use the general structure even for this simplest case. The relevant code regards the call to &lt;code&gt;createSensorsDataFromTemplate&lt;/code&gt; method. It uses the JSON based data template, replaces the placeholders with real data and send the response to the Android device by calling &lt;code&gt;atCipsend&lt;/code&gt; method, part of the ESP8266 library.&lt;/p&gt;

&lt;pre&gt;
void createSensorsDataFromTemplate( char *&amp;amp;data) {
  char buffTemp[7] = {0}, buffAvgTemp[7] = {0}, buffAvgHum[7] = {0},
    buffHum[7] = {0}, buffVcc[5] = {0}, tmpl[140] = {0};
  char *pTmpl = tmpl;
  uint8_t templateLen = -1;
  // read template from PROGMEM
  getPMData( SENSORS_DATA_TEMPLATE, pTmpl, templateLen);
  // create data string from template by replacing
  // parameters with their actual values from sensors
  sprintf( data, pTmpl, 
    dtostrf( dht22.temperature, 6, 1, buffTemp),
    dtostrf( avgTemperature, 6, 1, buffAvgTemp),
    dtostrf( dht22.humidity, 6, 1, buffHum), 
    dtostrf( avgHumidity, 6, 1, buffAvgHum),
    dtostrf( getVcc(), 4, 2, buffVcc),
    getFreeMCUMemory());
}&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;getPMData&lt;/code&gt; utility method (also part of the ESP8266 library), the data template string is read from the flash memory. Replacing the parameters with real values is made by using the standard &lt;code&gt;sprintf&lt;/code&gt; method. While for a fully fledged C/C++ environment one will use &lt;code&gt;%x.yf&lt;/code&gt; syntax with &lt;code&gt;sprintf&lt;/code&gt; for floating points numbers, this will not work with Arduino code. Instead we use &lt;code&gt;dtostrf&lt;/code&gt; to format the temperature and humidity values (we like values with just one digit after the decimal point).&lt;/p&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h4&gt;Program the Arduino Board&lt;/h4&gt;
&lt;/header&gt;

&lt;p&gt;&lt;strong&gt;Important:&lt;/strong&gt; the latest version of the Android software (v1.6.6+) is required for being able to compile and build the code for this project. One reason is that it uses C++11 specific constructs, such as &lt;code&gt;enum class&lt;/code&gt;, and the older Arduino Software versions does not support C++11. While it can be done also with older Arduino Software version, this requires to alter some configuration files, so it may create additional issues.&lt;/p&gt;

&lt;p&gt;We need to chose the right Arduino board by using the &lt;em&gt;Tools &amp;gt; Board&lt;/em&gt; selection list (within the Arduino IDE). If Arduino Pro Mini board was used, as discussed in this tutorial, we have to choose &lt;em&gt;Arduino Pro or Pro Mini&lt;/em&gt;. In addition, one needs to select the communication port (COM port) used for programming the Arduino board, available under &lt;em&gt;Tools &amp;gt; Port&lt;/em&gt; menu. Last, click on the arrow button located in the top-left corner to start the compile-and-deploy process.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The Arduino Pro Mini board does not have a builtin auto-reset feature, as found in Arduino Nano, UNO, MEGA2560, and other boards. This means we need to manually push the &lt;em&gt;reset&lt;/em&gt; button on the board as soon as the Arduion IDE says &lt;em&gt;uploading&lt;/em&gt;. It may take a few trials to get used with the right moment to push the button, but it must be shortly after the IDE says &lt;em&gt;uploading&lt;/em&gt;. In addition, you have to disconnect the ESP8266 TX line during the Arduino programming time, otherwise this operation fails. Since we have to do this on every code update, a jumper or a switch can be used to make task easier.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h3&gt;The Android Code&lt;/h3&gt;
&lt;/header&gt;

&lt;p&gt;An Android application is used to observe the Weather Station sensor node data. For the development of our Android application, &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA Ultimate&lt;/a&gt; was used. A free community version of this IDE is also available and can be used for our project. As an alternative, one cau use &lt;a href=&quot;http://developer.android.com/sdk/index.html&quot;&gt;Android Studion&lt;/a&gt;.&lt;/p&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h4&gt;Android Security Configuration&lt;/h4&gt;
&lt;/header&gt;

&lt;p&gt;The first thing you need to do after creating an empty Android application by using your preferred IDE, is to edit the application security settings. These can be found in the &lt;code&gt;AndroidManifest.xml&lt;/code&gt; file Since we need to use WiFi communication, the following two parameters need to be added:&lt;/p&gt;

&lt;pre&gt;
&amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&amp;gt;
&amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&amp;gt;&lt;/pre&gt;

&lt;p&gt;In addition, we like to disable the auto-lock feature of the Android device, as long as this application is active, which requires to set the following permission:&lt;/p&gt;

&lt;pre&gt;
&amp;lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&amp;gt;&lt;/pre&gt;

&lt;p&gt;The same &lt;code&gt;AndroidManifest.xml&lt;/code&gt; file defines the Android OS version required to run this application. We have tested this application with Android 4.3.1 (API 18) and 4.4.2 (API 19) and 5.0.1 (API 21). Therefore it is safe to set the miminum require version to API 18 by using the following parameter:&lt;/p&gt;

&lt;pre&gt;
&amp;lt;uses-sdk android:minSdkVersion=&quot;18&quot; android:targetSdkVersion=&quot;21&quot;/&amp;gt;&lt;/pre&gt;

&lt;p&gt;While this application may run on Android OS older than 4.3.1 (API 18), our tests with Android 2.3.3 (API 10) failed.&lt;/p&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h4&gt;Create the Android User Interface&lt;/h4&gt;
&lt;/header&gt;

&lt;p&gt;Creating the Android application user interface can be done by using the UI editor, or, if you are already familiar with Android, directly editing the layout file. In our case this file is named &lt;code&gt;main.xml&lt;/code&gt; and it is located under &lt;code&gt;res/layout&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;We use a &lt;code&gt;ScrollView&lt;/code&gt; container as the user interface parent, to support also small screen devices, with lower physical resolutions. As layout template, we use &lt;code&gt;TableLayout&lt;/code&gt;, with two columns: label and value plus measurement unit.&lt;/p&gt;

&lt;pre&gt;
&amp;lt;&lt;strong&gt;ScrollView&lt;/strong&gt; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
            android:layout_width=&quot;fill_parent&quot;
            android:layout_height=&quot;fill_parent&quot;
            android:fillViewport=&quot;true&quot;&amp;gt;
  &amp;lt;&lt;strong&gt;TableLayout&lt;/strong&gt; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
               android:layout_width=&quot;fill_parent&quot;
               android:layout_height=&quot;fill_parent&quot;
               android:id=&quot;@+id/main&quot;&amp;gt;
    &amp;lt;&lt;strong&gt;TableRow&lt;/strong&gt; android:layout_width=&quot;fill_parent&quot;
              android:layout_height=&quot;wrap_content&quot;&amp;gt;
      &amp;lt;!-- table row content --&amp;gt;
    &amp;lt;/TableRow&amp;gt;
    &amp;lt;!-- more table rows... --&amp;gt;
  &amp;lt;/TableLayout&amp;gt;
&amp;lt;/ScrollView&amp;gt;&lt;/pre&gt;

&lt;p&gt;For example, the row used to show the current temperature value is shown below:&lt;/p&gt;

&lt;pre&gt;
&amp;lt;TableRow android:layout_width=&quot;fill_parent&quot;
          android:layout_height=&quot;wrap_content&quot;&amp;gt;
  &amp;lt;TextView android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot;
            &lt;strong&gt;android:text=&quot;  Temperature:   &quot;&lt;/strong&gt;
            android:id=&quot;@+id/temperatureLabel&quot;/&amp;gt;
  &amp;lt;TextView android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot;
            android:text=&quot;N/A°C&quot;
            &lt;strong&gt;android:id=&quot;@+id/temperatureValueTextView&quot;&lt;/strong&gt;/&amp;gt;
&amp;lt;/TableRow&amp;gt;&lt;/pre&gt;

&lt;p&gt;Each UI element has an &lt;code&gt;android:id&lt;/code&gt; attribute, with an unique value, used to access the UI element from the Android Java code. The result user interface is shown in &lt;a href=&quot;#androidFullScreen&quot;&gt;Figure 5&lt;/a&gt;.&lt;/p&gt;

&lt;figure id=&quot;androidFullScreen&quot;&gt;&lt;img src=&quot;/sites/default/files/weather_station/android_full_screen.png&quot; /&gt;
&lt;figcaption&gt;Figure 5: Android Application User Interface.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h4&gt;Write the Android Java Code&lt;/h4&gt;
&lt;/header&gt;

&lt;p&gt;We use an Android activity to implement our class. This is the simplest way to create an Android application, specially this is your first Android application.&lt;/p&gt;

&lt;pre&gt;
public class MainActivity extends Activity {
  // ...here come all the properties and methods...
}&lt;/pre&gt;

&lt;p&gt;For the UDP communication with the Weather Station sensor node we use Java &lt;code&gt;DatagramSocket&lt;/code&gt;, and initialize it for port 1024 (other ports, starting with 1025, can be used as well). This code should execute before trying to send any UDP packet over the network. In this scenario, we request sensor data from the Weather Station node, once every 10 seconds. Feel free to modify it to another value if you like:&lt;/p&gt;

&lt;pre&gt;
public class MainActivity extends Activity {
  &lt;strong&gt;int udpPort = 1025;
  DatagramSocket socket;&lt;/strong&gt;
  
  // other properties....  
  
  @Override
  public void &lt;strong&gt;onCreate&lt;/strong&gt;( Bundle savedInstanceState) {
    // here are some other initializations
    (&lt;strong&gt;new Thread(new Runnable()&lt;/strong&gt; {
      @Override
      public void run() {
        try {
          socket = new DatagramSocket(udpPort);
          while (true) {
            if (appInBackground) continue;
            try {
              &lt;strong&gt;sendUdpData( Commands.GET_ALL_SENSORS_DATA, null);
              Thread.sleep( 10000);&lt;/strong&gt;
            } catch (Exception e) {
              e.printStackTrace();
            }
          }
        } catch (Exception e) {
          e.printStackTrace();
        }
      }
    })).&lt;strong&gt;start()&lt;/strong&gt;;
  }
}&lt;/pre&gt;
&lt;/section&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;p&gt;An anonymous Java thread is used to request periodical data updates. The 10 seconds delay is obtained by using the &lt;code&gt;Thread.sleep&lt;/code&gt; static method, and the data update request is performed by the &lt;code&gt;sendUdpData&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;
void sendUdpData( Commands cmd, byte[] params) {
  try {
    final DatagramPacket packet;
    int paramsLength = ( params != null ? params.length : 0);
    byte data[] = new byte[paramsLength + 1];
    byte command[] = new byte[1];
    command[0] = cmd.getValue();
    System.arraycopy( command, 0, data, 0, command.length);
    if ( params != null) System.arraycopy(params, 0, data, 1, params.length);
    &lt;strong&gt;packet = new DatagramPacket( data, data.length, getBroadcastAddress(), udpPort);
    socket.send( packet);&lt;/strong&gt;
  } catch( IOException e){
    e.printStackTrace();
  }
}&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;sendUdpData&lt;/code&gt; method takes two parameters: the command to send and its optional parameters. Remember, for the Arduino code, an enumeration was used to define all the available commands (well, just one command for now, but this will change later). Now, the same applies for the Android application: using a Java enumeration, we define the &lt;code&gt;GET_ALL_SENSORS_DATA&lt;/code&gt; command with the same command code, &lt;code&gt;97&lt;/code&gt; (this is what the Arduino application expects).&lt;/p&gt;

&lt;pre&gt;
&lt;strong&gt;enum Commands&lt;/strong&gt; {
  &lt;strong&gt;GET_ALL_SENSORS_DATA ( (byte)97);&lt;/strong&gt;
  private final byte id;
  Commands( byte id) { this.id = id; }
  public byte getValue() { return id; }
}&lt;/pre&gt;
&lt;/section&gt;

&lt;p&gt;Further, a &lt;code&gt;DatagramPacket&lt;/code&gt; is created, and the command (and when is the case, the command parameters too) is provided as an array of bytes (as required by the &lt;code&gt;DatagramPacket&lt;/code&gt; constructor). The UDP packet is then sent to the Weather Station sensor node. In response, the sensor node provides a JSON object containing the sensor data required to update the user interface. Since the UDP communication is asynchronous (we don&#039;t know how long it takes for the request to reach the sensor node and how long it takes until a response is received), a thread is used to continuously listen for incoming UDP packets.&lt;/p&gt;

&lt;pre&gt;
public void onCreate( Bundle savedInstanceState) {
  (new Thread(new Runnable() {
    @Override
    public void run() {
      while (true) {
        &lt;strong&gt;DatagramPacket udpPacket = receiveUdpData( udpPort);&lt;/strong&gt;
        if (udpPacket == null) continue;
        String udpPacketData =  new String( udpPacket.getData());
        try {
          &lt;strong&gt;JSONObject jsonObj = new JSONObject(udpPacketData);
          updateUserInterface( jsonObj);&lt;/strong&gt;
        } catch ( JSONException e) {
          e.printStackTrace();
        } 
      }
    }
  })).start();
}
DatagramPacket &lt;strong&gt;receiveUdpData&lt;/strong&gt;( int port) {
  try {
    byte[] data  = new byte[1024];
    &lt;strong&gt;DatagramPacket packet = new DatagramPacket( data, data.length);&lt;/strong&gt;
    if ( socket == null) return null;
    &lt;strong&gt;socket.receive(packet);&lt;/strong&gt;
    return packet;
  } catch( IOException e){
    e.printStackTrace();
    return null;
  }
}                &lt;/pre&gt;

&lt;p&gt;The received UDP data (stream of bytes) is converted to a JSON object and passed to &lt;code&gt;updateUserInterface&lt;/code&gt; method which is responsible to extract the sensor values and show them in the user interface. We show only the code which deals with the temperature value, but the same applies also for humidity, voltage, and the other values (see the full source code).&lt;/p&gt;

&lt;pre&gt;
void updateUserInterface( final JSONObject jsonObj) {
  try {
    &lt;strong&gt;final double temperature = jsonObj.getDouble(&quot;temperature&quot;);&lt;/strong&gt;
    &lt;strong&gt;temperatureValueTextView.post&lt;/strong&gt;(new Runnable() {
      public void run() {
        &lt;strong&gt;temperatureValueTextView.setText(String.valueOf(temperature) + &quot;°C&quot;);&lt;/strong&gt;
      }
    });
  } catch (JSONException e) {
    e.printStackTrace();
  }
}&lt;/pre&gt;

&lt;p&gt;Due to Android API restrictions, a UI component object can be modified only by the thread who created it. In our case, main application thread is the one which creates the GUI component objects, while the &lt;code&gt;updateUserInterface&lt;/code&gt; is invoked by the thread which listen for UDP data. In such case, the &lt;code&gt;post&lt;/code&gt; method can be used, thus being able to update the sensor values in the user interface components. Getting reference to the user interface components is made by using the corresponding implementation class (e.g. &lt;code&gt;TextView&lt;/code&gt;) and invoking the &lt;code&gt;findViewById&lt;/code&gt; method, as shown below.&lt;/p&gt;

&lt;pre&gt;
public class MainActivity extends Activity {
  // some other properties...

  &lt;strong&gt;TextView sensorsDataReceivedTimeTextView;&lt;/strong&gt;
            
  public void onCreate( Bundle savedInstanceState) {
    &lt;strong&gt;sensorsDataReceivedTimeTextView = (TextView) findViewById(R.id.sensorsDataReceivedTimeTextView);&lt;/strong&gt;
  }
  // some other methods...
}&lt;/pre&gt;

&lt;p&gt;One special requirement in our application is to provide a &quot;disable auto-sleep feature&quot; for the Android device, as long as the application runs. This means, the device screen stays on as long as the application is active. To obtain this behavior, we use the &lt;code&gt;addFlags&lt;/code&gt; method of the &lt;code&gt;window&lt;/code&gt; object (inherited from the &lt;code&gt;Activity&lt;/code&gt; super class), and provide the corresponding parameter. In our case, these parameters are defined as literalos of the &lt;code&gt;WindowManager.LayoutParams&lt;/code&gt; enumeration.&lt;/p&gt;

&lt;pre&gt;
window.addFlags( WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON); 
window.addFlags( WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &lt;/pre&gt;

&lt;p&gt;Remember, this requires to enable the &lt;code&gt;android.permission.WAKE_LOCK&lt;/code&gt; permission, by editing the &lt;code&gt;AndroidManifest.xml&lt;/code&gt; file as shows earlier on this tutorial.&lt;/p&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h2&gt;Download the Full Application Code&lt;/h2&gt;
&lt;/header&gt;

&lt;p&gt;The Arduino and Android code, as well as the documentation (including the fritzing project and diagrams) are available as open source on &lt;a href=&quot;https://github.com/dimircea/WeatherStation/tree/master/Minimal%20(v0.1)&quot;&gt;github&lt;/a&gt;. Feel free to copy or modify them as you like. Please provide a link to our tutorial page if you like to support us.&lt;/p&gt;
&lt;/section&gt;

&lt;section&gt;
&lt;header&gt;
&lt;h2&gt;Further improvements&lt;/h2&gt;
&lt;/header&gt;

&lt;p&gt;We can extend our project by considering the following improvements:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;SMS alerts by using a GSM module (costs about 15€). We can receiveSMS alerts on a mobile phone if some measured parameters are not in the predefined limits. For example, if the temperature goes below 0°C, we like to receive an SMS, because this may indicate an issue with the home heating system.&lt;/li&gt;
	&lt;li&gt;Improve the code by considering various problematic cases:
	&lt;ul&gt;
		&lt;li&gt;WiFi module does not respond - check the module periodically and perform a hardware reset when needed.&lt;/li&gt;
		&lt;li&gt;DHT22 sensor errors - provide a robust code which alert us if the temperature and humidity sensor becomes unstable or is damaged.&lt;/li&gt;
		&lt;li&gt;Use the Arduino EEPROM memory to store configuration parameters.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Improve the hardware design so it allows to be battery powered. This includes to replace our linear voltage regulator for the 3.3V line with a more power consumption efficient one ( a switch mode based one).&lt;/li&gt;
	&lt;li&gt;Allow to use solar energy to charge the batteries for Weather Station nodes (specially for the ones used outside, under direct sunlight).&lt;/li&gt;
	&lt;li&gt;Add soil moisture sensors, providing indication about the right moment to water our plants.&lt;/li&gt;
	&lt;li&gt;Add a light intensity sensor, providing a better way to create statistics related to temperature values with respect to day and night. Altough this can be done in the Android software, it requires to have your phone connected with the node for most of the time, which is general is not the case.&lt;/li&gt;
	&lt;li&gt;Add a real time clock (RTC) for our node, further improving the various statistics about measured environment characteristics.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Stay tuned! All these improvements are discussed in our further tutorials.&lt;/p&gt;
&lt;/section&gt;
&lt;/article&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;section class=&quot;field field-name-field-tags field-type-taxonomy-term-reference field-label-above view-mode-rss&quot;&gt;&lt;h2 class=&quot;field-label&quot;&gt;Tags:&amp;nbsp;&lt;/h2&gt;&lt;ul class=&quot;field-items&quot;&gt;&lt;li class=&quot;field-item even&quot; rel=&quot;dc:subject&quot;&gt;&lt;a href=&quot;/taxonomy/term/40&quot; typeof=&quot;skos:Concept&quot; property=&quot;rdfs:label skos:prefLabel&quot; datatype=&quot;&quot;&gt;WoT&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;field-item odd&quot; rel=&quot;dc:subject&quot;&gt;&lt;a href=&quot;/taxonomy/term/39&quot; typeof=&quot;skos:Concept&quot; property=&quot;rdfs:label skos:prefLabel&quot; datatype=&quot;&quot;&gt;Android&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;field-item even&quot; rel=&quot;dc:subject&quot;&gt;&lt;a href=&quot;/Arduino&quot; typeof=&quot;skos:Concept&quot; property=&quot;rdfs:label skos:prefLabel&quot; datatype=&quot;&quot;&gt;Arduino&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;field-item odd&quot; rel=&quot;dc:subject&quot;&gt;&lt;a href=&quot;/Java&quot; typeof=&quot;skos:Concept&quot; property=&quot;rdfs:label skos:prefLabel&quot; datatype=&quot;&quot;&gt;Java&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;div class=&quot;easy_social_box clearfix horizontal easy_social_lang_und&quot;&gt;
            &lt;div class=&quot;easy_social-widget easy_social-widget-twitter first&quot;&gt;&lt;a href=&quot;http://twitter.com/share&quot; class=&quot;twitter-share-button&quot;
data-url=&quot;https://web-engineering.info/node/52&quot;
data-count=&quot;horizontal&quot;
data-lang = &quot;en&quot;
data-via=&quot;&quot;
data-related=&quot;:Check it out!&quot;
data-text=&quot;Building a WiFi-connected weather station with an Android user interface for less than 30 Euro&quot;&gt;Tweet&lt;/a&gt;&lt;/div&gt;
          &lt;div class=&quot;easy_social-widget easy_social-widget-facebook&quot;&gt;&lt;fb:like href=&quot;https://web-engineering.info/node/52&quot; send=&quot;true&quot; layout=&quot;button_count&quot; width=&quot;88&quot; show_faces=&quot;true&quot; action=&quot;like&quot; colorscheme=&quot;light&quot; font=&quot;&quot;&gt;&lt;/fb:like&gt;&lt;/div&gt;
          &lt;div class=&quot;easy_social-widget easy_social-widget-googleplus&quot;&gt;&lt;div class=&quot;g-plusone&quot; data-size=&quot;medium&quot; data-annotation=&quot;bubble&quot; data-href=&quot;https://web-engineering.info/node/52&quot;&gt;&lt;/div&gt;&lt;/div&gt;
          &lt;div class=&quot;easy_social-widget easy_social-widget-linkedin last&quot;&gt;&lt;script type=&quot;in/share&quot; data-url=&quot;https://web-engineering.info/node/52&quot; data-counter=&quot;right&quot;&gt;&lt;/script&gt;&lt;/div&gt;
  &lt;/div&gt; &lt;!-- /.easy_social_box --&gt;</description>
 <pubDate>Thu, 17 Dec 2015 00:48:18 +0000</pubDate>
 <dc:creator>mdiaconescu</dc:creator>
 <guid isPermaLink="false">52 at https://web-engineering.info</guid>
 <comments>https://web-engineering.info/node/52#comments</comments>
</item>
</channel>
</rss>
