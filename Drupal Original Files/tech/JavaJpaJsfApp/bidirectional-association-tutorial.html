<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" vocab="http://schema.org/" typeof="TechArticle WebPage">

<!-- Mirrored from web-engineering.info/tech/JavaJpaJsfApp/bidirectional-association-tutorial.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 21 Jul 2023 10:53:07 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="UTF-8" />
  <title>Java EE Bidirectional Association App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="description" content="An advanced tutorial about managing bidirectional associations in Java/JPA/JSF web applications" />  
  <meta property="learningResourceType" content="Tutorial">
  <meta property="proficiencyLevel" content="Advanced">
  <meta property="isPartOf" content="../../index.html">
  <meta property="specialty" content="../../WebAppEngineering.html">
  <link rel="stylesheet" type="text/css" href="../docbook.css">
</head>
<body property="articleBody">
<aside>
 <nav>
  <ul>
  <li><a href="BidirectionalAssociationApp/index.html"><button type="button">Run the app</button></a></li>
  <li><a href="BidirectionalAssociationApp.zip"><button type="button">Get the code</button></a></li>
  <li><a href="../../forum/8.html"><button type="button">Ask a question</button></a></li>
  </ul>
 </nav>
 <div id="supportUs">
  <p>Please support <em>web-engineering.info</em> and buy our e-book <a href="https://gumroad.com/l/Epke">Building Back-End Web Apps with Java, JPA and JSF</a>.</p>
  <a href="https://gumroad.com/l/Epke"><img src="book-cover-180x270-Java.html" /></a>
 </div>
</aside>

   <div lang="en" class="book"><div class="titlepage"><div><div>
   <h3 style="color:grey"><em>Understanding</em> and <code>Implementing</code> Information Management Concepts and Techniques</h3>
   <h1 class="title"><a name="d5e1"></a>Java Back-End Web App Tutorial Part 5: Managing Bidirectional Associations</h1></div><div><h2 class="subtitle">Learn how
   to manage bidirectional associations between object types in a Java back-end web app, using Java
   Server Faces (JSF) as the user interface technology, the Java Persistence API (JPA) for
   object-to-storage mapping, and a MySQL database</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Gerd</span> <span class="surname">Wagner</span></h3><code class="email">&lt;<a class="email" href="../../cdn-cgi/l/email-protection.html#3e7910695f59505b4c7e5c134a4b105a5b"><span class="__cf_email__" data-cfemail="70375e2711171e150230125d04055e1415">[email&#160;protected]</span></a>&gt;</code></div><div class="author"><h3 class="author"><span class="firstname">Mircea</span> <span class="surname">Diaconescu</span></h3><code class="email">&lt;<a class="email" href="../../cdn-cgi/l/email-protection.html#ace182e8c5cdcfc3c2c9dfcfd9ecce81d8d982c8c9"><span class="__cf_email__" data-cfemail="0f42214b666e6c60616a7c6c7a4f6d227b7a216b6a">[email&#160;protected]</span></a>&gt;</code></div></div></div><div><p class="releaseinfo">Warning: This tutorial may still contain errors and may still be incomplete in
   certain respects. Please report any issue to Gerd Wagner at G<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="b09ee7d1d7ded5c2f0d29dc4c59ed4d5">[email&#160;protected]</a> or Mircea Diaconescu
   at <a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="d19cff95b8b0b2bebfb4a2b2a491b3fca5a4ffb5b4">[email&#160;protected]</a>.</p></div><div><p class="releaseinfo">This tutorial is also available in the following formats: <a class="link" href="bidirectional-association-tutorial.pdf" target="_top">PDF</a>. See also the <a class="link" href="../../index.html" target="_top">project page</a>, or <a class="link" href="BidirectionalAssociationApp/index-2.html" target="_top">run the example app</a> from our server,
   or <a class="link" href="BidirectionalAssociationApp.zip" target="_top">download it as a ZIP archive file</a>.
   
  </p></div><div><p class="copyright">Copyright &copy; 2015-2018 Gerd Wagner, Mircea Diaconescu</p></div><div><div class="legalnotice"><a name="d5e34"></a><p>This tutorial article, along with any associated source code, is licensed under <a class="link" href="http://www.codeproject.com/info/cpol10.aspx" target="_top">The Code Project Open License
     (CPOL)</a>, implying that the associated code is provided "as-is", can be modified to create
    derivative works, can be redistributed, and can be used in commercial applications, but the
    article must not be distributed or republished without the authors' consent.</p></div></div><div><p class="pubdate">2018-06-25</p></div><div><div class="revhistory"><table style="border-style:solid; width:100%;" summary="Revision History"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 0.3</td><td align="left">20150724</td><td align="left">gw</td></tr><tr><td align="left" colspan="3">improved entity class model</td></tr><tr><td align="left">Revision 0.2</td><td align="left">20150629</td><td align="left">gw</td></tr><tr><td align="left" colspan="3">various revisions</td></tr><tr><td align="left">Revision 0.1</td><td align="left">20150510</td><td align="left">md</td></tr><tr><td align="left" colspan="3">create first version</td></tr></table></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="preface"><a href="#d5e53">Foreword</a></span></dt><dt><span class="chapter"><a href="#chapBidirAssoc">1. Bidirectional Associations</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e112">1. Inverse Reference Properties</a></span></dt><dt><span class="section"><a href="#d5e261">2. Making an OO Class Model</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e264">2.1. The basic procedure</a></span></dt><dt><span class="section"><a href="#secElimNAE">2.2. How to eliminate unidirectional associations</a></span></dt><dt><span class="section"><a href="#d5e287">2.3. How to eliminate bidirectional associations</a></span></dt><dt><span class="section"><a href="#d5e344">2.4. The resulting OO class model</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d5e355">2. Implementing Bidirectional Associations with Java EE</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e368">1. Make a Java Entity Class Model</a></span></dt><dt><span class="section"><a href="#d5e437">2. Write the Model Code </a></span></dt><dd><dl><dt><span class="section"><a href="#d5e440">2.1. New issues</a></span></dt><dt><span class="section"><a href="#d5e522">2.2. Summary</a></span></dt><dt><span class="section"><a href="#d5e550">2.3. Code each class of the Java Entity class model</a></span></dt><dt><span class="section"><a href="#d5e601">2.4. Code the setter operations</a></span></dt><dt><span class="section"><a href="#d5e612">2.5. Code the add and remove operations</a></span></dt><dt><span class="section"><a href="#d5e650">2.6. Take care of deletion dependencies</a></span></dt><dt><span class="section"><a href="#d5e681">2.7. EntityManagers and Cached Entities </a></span></dt></dl></dd><dt><span class="section"><a href="#d5e711">3. Exploiting Derived Inverse Reference Properties in the User Interface</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e718">3.1. Show information about published books in the <span class="italic">List
					Publishers</span> use case</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e750">4. Run the App and Get the Code</a></span></dt></dl></dd></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>1.1. <a href="#figPublisherBookPersonIDM">The Publisher-Book-Author information design model with two bidirectional
			associations</a></dt><dt>1.2. <a href="#figDesM2AFM1">Turn a bidirectional one-to-one association into a master-slave pair of mutually
        inverse single-valued reference properties </a></dt><dt>1.3. <a href="#figDesM2AFM2">Turn a bidirectional many-to-many association into a master-slave pair of mutually
        inverse multi-valued reference properties </a></dt><dt>1.4. <a href="#figBidirAFM">The OO class model</a></dt><dt>2.1. <a href="#d5e431">The Java Entity class model</a></dt></dl></div><div class="preface"><div class="titlepage"><div><div><h1 class="title"><a name="d5e53"></a>Foreword</h1></div></div></div><p>This tutorial is Part 5 of our series of <a class="link" href="../../JavaJpaJsfApp.html" target="_top">six tutorials</a> about model-based
   development of back-end web applications with Java, using JPA and JSF. It shows how to build a
   web app that takes care of the three object types <code class="code">Book</code>, <code class="code">Publisher</code> and
    <code class="code">Author</code>, as well as of the two bidirectional associations that assign a publisher
   and (one or more) authors to a book and the inverse associations which assign books to authors
   and to publishers . </p><p>A <span class="italic">distributed web app</span> is composed of at least two parts:
   a front-end part, which, at least, renders the user interface (UI) pages, and a back-end part,
   which, at least, takes care of persistent data storage. A <span class="italic">back-end web
    app</span> is a distributed web app where essentially all work is performed by the back-end
   component, including data validation and UI page creation, while the front-end only consists of a
   web browser's rendering of HTML-forms-based UI pages. Normally, a distributed web app can be
   accessed by multiple users, possibly at the same time, over HTTP connections.</p><p>In the case of a Java/JPA/JSF back-end app, the back-end part of the app can be executed by
   a server machine that runs a web server supporting the Java EE specifications <span class="italic">Java Servlets</span>, <span class="italic">Java Expression Language
    (EL)</span>, <span class="italic">JPA</span> and <span class="italic">JSF</span>, such as the open source server <a class="link" href="http://tomee.apache.org/apache-tomee.html" target="_top">Tomcat/TomEE</a>.</p><p>The app supports the four standard data management operations (<span class="bold"><strong>C</strong></span>reate/<span class="bold"><strong>R</strong></span>ead/<span class="bold"><strong>U</strong></span>pdate/<span class="bold"><strong>D</strong></span>elete). It extends the unidirectional
   association example app by adding code for handling the <span class="bold"><strong>bidirectional
    functional</strong></span> (many-to-one) association between <code class="code">Book</code> and
    <code class="code">Publisher</code>, and the <span class="bold"><strong>bidirectional non-functional</strong></span>
   (many-to-many) association between <code class="code">Book</code> and <code class="code">Author</code>. The other parts of
   the tutorial are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="minimal-tutorial.html" target="_top">Part 1</a>: Building a <span class="bold"><strong>minimal</strong></span> app.</p></li><li class="listitem"><p><a class="link" href="validation-tutorial.html" target="_top">Part 2</a>: Handling 
		   <span class="bold"><strong>constraint validation</strong></span>.</p></li><li class="listitem"><p><a class="link" href="enumeration-tutorial.html" target="_top">Part 3</a>: Dealing with 
		   <span class="bold"><strong>enumerations</strong></span>.</p></li><li class="listitem"><p><a class="link" href="unidirectional-association-tutorial.html" target="_top">Part 4</a>: Managing
      <span class="bold"><strong>unidirectional associations</strong></span>, such as the associations between
     books and publishers, assigning a publisher to a book, and between books and authors, assigning
     authors to a book.</p></li><li class="listitem"><p><a class="link" href="subtyping-tutorial.html" target="_top">Part 6</a>: Handling <span class="bold"><strong>subtype</strong></span> (inheritance) relationships between object types.</p></li></ul></div></div><div lang="" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="chapBidirAssoc"></a>Chapter&nbsp;1.&nbsp;Bidirectional Associations</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d5e112">1. Inverse Reference Properties</a></span></dt><dt><span class="section"><a href="#d5e261">2. Making an OO Class Model</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e264">2.1. The basic procedure</a></span></dt><dt><span class="section"><a href="#secElimNAE">2.2. How to eliminate unidirectional associations</a></span></dt><dt><span class="section"><a href="#d5e287">2.3. How to eliminate bidirectional associations</a></span></dt><dt><span class="section"><a href="#d5e344">2.4. The resulting OO class model</a></span></dt></dl></dd></dl></div><p>In OO modeling and programming, a <span class="italic">bidirectional</span>
  association is an association that is represented as a pair of mutually inverse reference
  properties, which allow `navigation&acute; (object access) in both directions.</p><p>The model shown in Figure <a class="xref" href="#figPublisherBookPersonIDM" title="Figure&nbsp;1.1.&nbsp;The Publisher-Book-Author information design model with two bidirectional associations">1.1</a> below (about publishers, books and their authors) serves
		as our running example in all other parts of the tutorial. Notice that it contains two
		bidirectional associations, as indicated by the ownership dots at both association
		ends.</p><div class="figure"><a name="figPublisherBookPersonIDM"></a><p class="title"><b>Figure&nbsp;1.1.&nbsp;The Publisher-Book-Author information design model with two bidirectional
			associations</b></p><div class="figure-contents"><div class="mediaobject"><img src="../fig/Publisher-Book-Author_Bidir_DesM.svg" alt="The Publisher-Book-Author information design model with two bidirectional associations"></div></div></div><br class="figure-break"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e112"></a>1.&nbsp;Inverse Reference Properties</h2></div></div></div><p>For being able to easily retrieve the committees that are chaired or co-chaired by a club
   member, we add two reference properties to our <span class="italic">Committee-ClubMember</span> example model: the property of a club member to be the chair of
   a committee (<code class="code">ClubMember</code>::<code class="code">chairedCommittee</code>) and the property of a club
   member to be the co-chair of a committee
    (<code class="code">ClubMember</code>::<code class="code">coChairedCommittee</code>). We assume that any club member may
   chair or co-chair at most one committee (where the disjunction is non-exclusive). So, we get the
   following model:</p><div class="mediaobject"><img src="../fig/CommitteeChairAndCochair_AFM1.svg"></div><p>Notice that there is a close correspondence between the two reference properties
				<code class="code">Committee</code>::<code class="code">chair</code> and
				<code class="code">ClubMember</code>::<code class="code">chairedCommittee</code>. They are the <span class="bold"><strong><span class="italic">inverse</span></strong></span> of each other: when the club member
			Tom is the chair of the budget committee, expressed by the tuple <span class="italic">("budget committee", "Tom")</span>, then the budget committee is the committee chaired
			by the club member Tom, expressed by the inverse tuple <span class="italic">("Tom", "budget
				committee")</span>. For expressing this inverse correspondence in the diagram, we append
			an inverse property constraint, <code class="code">inverse of chair</code>, in curly braces to the
			declaration of the property <code class="code">ClubMember</code>::<code class="code">chairedCommittee</code>, and a
			similar one to the property <code class="code">Committee</code>::<code class="code">chair</code>, as shown in the
			following diagram:</p><div class="mediaobject"><img src="../fig/CommitteeChairAndCochair_AFM2.svg"></div><p>Using the reference path notation of OOP languages, with <span class="italic">c</span> referencing a <code class="code">Committee</code> object, we obtain the equation:</p><div class="equation"><a name="d5e143"></a><p class="title"><b>Equation&nbsp;1.1.&nbsp;</b></p><div class="equation-contents"><span class="mathphrase">c.chair.chairedCommittee = c</span></div></div><br class="equation-break"><p>Or, the other way around, with <span class="italic">m</span> referencing a
    <code class="code">ClubMember</code> object, we obtain the equation:</p><div class="equation"><a name="d5e148"></a><p class="title"><b>Equation&nbsp;1.2.&nbsp;</b></p><div class="equation-contents"><span class="mathphrase">m.chairedCommittee.chair = m</span></div></div><br class="equation-break"><p>Notice that when a property <span class="italic">p<sub>2</sub></span> is
   the inverse of a property <span class="italic">p<sub>1</sub></span>, this
   implies that, the other way around, <span class="italic">p<sub>1</sub></span>
   is the inverse of <span class="italic">p<sub>2</sub></span>. Therefore, when
   we declare the property <code class="code">ClubMember</code>::<code class="code">chairedCommittee</code> to be the inverse
   of <code class="code">Committee</code>::<code class="code">chair</code>, then, implicitly,
    <code class="code">Committee</code>::<code class="code">chair</code> is the inverse of
    <code class="code">ClubMember</code>::<code class="code">chairedCommittee</code>. We therefore call
    <code class="code">Committee</code>::<code class="code">chair</code> and
    <code class="code">ClubMember</code>::<code class="code">chairedCommittee</code> a <span class="bold"><strong><span class="italic">pair of mutually inverse reference properties</span></strong></span>. Having such
   a pair in a model implies <span class="bold"><strong><span class="italic">redundancy</span></strong></span> because each of the two involved reference properties can be
   derived from the other by inversion. This type of redundancy implies <span class="italic">data
    storage overhead</span> and <span class="italic">update overhead</span>, which is the
   price to pay for the bidirectional navigability that supports efficient object access in both
   directions.</p><p>For maintaining the duplicate information of a mutually inverse reference property pair, it
   is common to treat one of the two involved properties as the <span class="italic">master</span>, and the other one as the <span class="italic">slave</span>, and take
   this distinction into consideration in the code of the change methods (such as the property
   setters) of the affected model classes. We indicate the slave of an inverse reference property
   pair in a model diagram by declaring the slave property to be a <span class="bold"><strong><span class="italic">derived</span></strong></span> property using the UML notation of a slash
    (<code class="code">/</code>) as a prefix of the property name as shown in the following diagram:</p><div class="mediaobject"><img src="../fig/CommitteeChairAndCochair_AFM3.svg"></div><p>The property <code class="code">chairedCommittee</code> in <code class="code">ClubMember</code> is now <span class="italic">derived</span> (as indicated by its slash prefix). Its annotation <code class="code">{inverse of
    chair}</code> defines a <span class="italic">derivation rule</span> according to which it
   is derived by inverting the property <code class="code">Committee</code>::<code class="code">chair</code>. </p><p>There are two ways how to realize the derivation of a property: it may be <span class="italic">derived on read</span> via a read-time computation of its value, or it may be
    <span class="italic">derived on update</span> via an update-time computation performed
   whenever one of the variables in the derivation expression (typically, another property) changes
   its value. The latter case corresponds to a <span class="italic">materialized view</span>
   in a database. While a reference property that is derived on read may not guarantee efficient
   navigation, because the on-read computation may create unacceptable latencies, a reference
   property that is derived on update does provide efficient navigation.</p><p>When we designate an inverse reference property as derived by prefixing its name with a
   slash (<code class="code">/</code>), we indicate that it is derived on update. For instance, the property
    <code class="code">/chairedCommittee</code> in the example above is derived on update from the property
    <code class="code">chair</code>. </p><p>In the case of a derived reference property, we have to deal with <span class="bold"><strong><span class="italic">life cycle dependencies</span></strong></span> between the affected
   model classes requiring special change management mechanisms based on the functionality type of
   the represented association (either <span class="italic">one-to-one</span>, <span class="italic">many-to-one</span> or <span class="italic">many-to-many</span>). </p><p>In our example of the derived inverse reference property
				<code class="code">ClubMember</code>::<code class="code">chairedCommittee</code>, which is single-valued and optional,
		 this means that</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>whenever a new committee object is created (with a mandatory <code class="code">chair</code>
						assignment), the corresponding <code class="code">ClubMember</code>::<code class="code">chairedCommittee</code>
						property has to be assigned accordingly;</p></li><li class="listitem"><p>whenever the <code class="code">chair</code> property is updated (that is, a new chair is assigned to
      a committee), the corresponding <code class="code">ClubMember</code>::<code class="code">chairedCommittee</code>
      property has to be unset for the club member who was the previous chair and set for the one
      being the new chair; </p></li><li class="listitem"><p>whenever a committee object is destroyed, the corresponding
       <code class="code">ClubMember</code>::<code class="code">chairedCommittee</code> property has to be unset.</p></li></ol></div><p>In the case of a derived inverse reference property that is multi-valued while its inverse
			base property is single-valued (like <code class="code">Publisher</code>::<code class="code">publishedBooks</code> in
			Figure <a class="xref" href="#figBidirAFM" title="Figure&nbsp;1.4.&nbsp;The OO class model">1.4</a> below being derived from
		 <code class="code">Book</code>::<code class="code">publisher</code>), the life cycle dependencies imply that</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>whenever a new 'base object' (such as a book) is created, the corresponding inverse
						property has to be updated by adding a reference to the new base object to its value set
						(like adding a reference to the new book object to
							<code class="code">Publisher</code>::<code class="code">publishedBooks</code> );</p></li><li class="listitem"><p>whenever the base property is updated (e.g., a new publisher is assigned to a book),
						the corresponding inverse property (in our example,
							<code class="code">Publisher</code>::<code class="code">publishedBooks</code>) has to be updated as well by
						removing the old object reference from its value set and adding the new one;</p></li><li class="listitem"><p>whenever a base object (such as a book) is destroyed, the corresponding inverse
						property has to be updated by removing the reference to the base object from its value
						set (like removing a reference to the book object to be destroyed from
							<code class="code">Publisher</code>::<code class="code">publishedBooks</code> ).</p></li></ol></div><p>Notice that from a purely computational point of view, we are free to choose either of the
   two mutually inverse reference properties (like <code class="code">Book</code>::<code class="code">authors</code> and
    <code class="code">Author</code>::<code class="code">authoredBooks</code>) to be the master. However, in many cases,
   associations represent asymmetrical ontological existence dependencies that dictate which of the
   two mutually inverse reference properties is the master. For instance, the authorship association
   between the classes <code class="code">Book</code> and <code class="code">Author</code> represents an ontological existence
   dependency of books on their authors. A book existentially depends on its author(s), while an
   author does not existentially depend on any of her books. Consequently, the corresponding object lifecycle dependency between <code class="code">Book</code> and <code class="code">Author</code> implies that their bidirectional association is maintained by maintaining <code class="code">Author</code> references in <code class="code">Book</code>::<code class="code">authors</code> as the natural choice of master property, while <code class="code">Author</code>::<code class="code">authoredBooks</code> is the slave property, which is derived from <code class="code">Book</code>::<code class="code">authors</code>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e261"></a>2.&nbsp;Making an OO Class Model</h2></div></div></div><p>Since classical OO programming languages do not support explicit associations as first class
   citizens, but only classes with reference properties representing implicit associations, we have
   to eliminate all explicit associations for obtaining an OO class model.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e264"></a>2.1.&nbsp;The basic procedure</h3></div></div></div><p>The starting point of our <span class="bold"><strong><span class="italic">association
      elimination</span></strong></span> procedure is an information design model with various kinds
    of unidirectional and bidirectional associations, such as the model shown in <a class="xref" href="#figPublisherBookPersonIDM" title="Figure&nbsp;1.1.&nbsp;The Publisher-Book-Author information design model with two bidirectional associations">Figure&nbsp;1.1</a> above. If the model still
    contains any non-directed associations, we first have to turn them into directed ones by making
    a decision on the ownership of their ends, which is typically based on navigability
    requirements.</p><p>Notice that both associations in the <span class="italic">Publisher-Book-Author</span> information design model, <span class="italic">publisher-publishedBooks</span> and <span class="italic">authoredBooks-authors</span> (or <span class="italic">Authorship</span>), are
				bidirectional as indicated by the ownership dots at both association ends. For eliminating
				all explicit associations from an information design model, we have to perform the following
				steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="bold"><strong><span class="italic">Eliminate unidirectional
								associations</span></strong></span>, connecting a source with a target class, by
						replacing them with a reference property in the source class such that the target class
						is its range.</p></li><li class="listitem"><p><span class="bold"><strong><span class="italic">Eliminate bidirectional
								associations</span></strong></span> by replacing them with a pair of mutually inverse
						reference properties. </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="secElimNAE"></a>2.2.&nbsp;How to eliminate unidirectional associations</h3></div></div></div><p>A unidirectional association connecting a source with a target class is replaced with a
				corresponding reference property in its source class having the target class as its range.
				Its multiplicity is the same as the multiplicity of the target association end. Its name is
				the name of the association end, if there is any, otherwise it is set to the name of the
				target class (possibly pluralized, if the reference property is multi-valued).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e287"></a>2.3.&nbsp;How to eliminate bidirectional associations</h3></div></div></div><p>A bidirectional association, such as the authorship association between the classes
     <code class="code">Book</code> and <code class="code">Author</code> in the model shown in Figure <a class="xref" href="#figPublisherBookPersonIDM" title="Figure&nbsp;1.1.&nbsp;The Publisher-Book-Author information design model with two bidirectional associations">1.1</a> above, is replaced with a
    pair of mutually inverse reference properties, such as <code class="code">Book</code>::<code class="code">authors</code>
    and <code class="code">Author</code>::<code class="code">authoredBooks</code>. Since both reference properties represent
    the same information (the same set of binary relationships), it's an option to consider one of
    them being the "master" and the other one the "slave", which is derived from the master. We
    discuss the two cases of a one-to-one and a many-to-many association</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>In the case of a bidirectional one-to-one association, this leads to a pair of mutually
      inverse single-valued reference properties, one in each of the two associated classes. Since
      both of them represent essentially the same information (the same collection of
      links/relationships), one has to choose which of them is considered the master property, such
      that the other one is the slave property, which is derived from the master property by
      inversion. In the class diagram, the slave property is designated as a <span class="italic">derived property</span> that is automatically updated whenever 1) a new master object is
      created, 2) the master reference property is updated, or 3) a master object is
      destroyed.</p><div class="figure"><a name="figDesM2AFM1"></a><p class="title"><b>Figure&nbsp;1.2.&nbsp;Turn a bidirectional one-to-one association into a master-slave pair of mutually
        inverse single-valued reference properties </b></p><div class="figure-contents"><div class="informaltable"><table frame="void"><tbody><tr>
									<td>
										<div class="mediaobject"><img src="../fig/CommitteeChair_DesM3.svg"></div>
									</td>
								</tr><tr>
									<td align="center">
										<div class="mediaobject"><img src="../fig/Downarrow.svg"></div>
									</td>									
								</tr><tr>
									<td>
										<div class="mediaobject"><img src="../fig/Committee-ClubMember-Bidir_OoDesM.svg"></div>
									</td>									
								</tr></tbody></table></div></div></div><br class="figure-break"></li><li class="listitem"><p>A bidirectional many-to-many association is mapped to a pair of mutually inverse
      multi-valued reference properties, one in each of the two classes participating in the
      association. Again, in one of the two classes, the multi-valued reference property
      representing the (inverse) association is designated as a <span class="italic">derived
       property</span> that is automatically updated whenever the corresponding property in the
      other class (where the association is maintained) is updated. </p><div class="figure"><a name="figDesM2AFM2"></a><p class="title"><b>Figure&nbsp;1.3.&nbsp;Turn a bidirectional many-to-many association into a master-slave pair of mutually
        inverse multi-valued reference properties </b></p><div class="figure-contents"><div class="informaltable"><table frame="void"><tbody><tr>
									<td>
										<div class="mediaobject"><img src="../fig/Book-Author_DesM.svg"></div>
									</td>
								</tr><tr>
									<td align="center">
										<div class="mediaobject"><img src="../fig/Downarrow.svg"></div>
									</td>									
								</tr><tr>
									<td>
										<div class="mediaobject"><img src="../fig/Book-Author_AFM.svg"></div>
									</td>									
								</tr></tbody></table></div></div></div><br class="figure-break"></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e344"></a>2.4.&nbsp;The resulting OO class model</h3></div></div></div><p>After replacing both bidirectional associations with reference properties, we obtain the
				following OO class model:</p><div class="figure"><a name="figBidirAFM"></a><p class="title"><b>Figure&nbsp;1.4.&nbsp;The OO class model</b></p><div class="figure-contents"><div class="mediaobject"><img src="../fig/Publisher-Book-Author_Bidir_AFM.svg" alt="The OO class model"></div></div></div><br class="figure-break"><p>Since books are entities that existentially depend on authors and possibly on publishers,
    and not the other way around, it's natural to maintain the master references in book objects,
    and consider the inverse references in publisher and author objects as derived (or slave) data.
    Therefore, we define <code class="code">publishedBooks</code> and <code class="code">authoredBooks</code> as derived
    inverse reference properties, which is indicated by their slash prefix in the OO class
    model.</p></div></div></div><div lang="" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="d5e355"></a>Chapter&nbsp;2.&nbsp;Implementing Bidirectional Associations with Java EE</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d5e368">1. Make a Java Entity Class Model</a></span></dt><dt><span class="section"><a href="#d5e437">2. Write the Model Code </a></span></dt><dd><dl><dt><span class="section"><a href="#d5e440">2.1. New issues</a></span></dt><dt><span class="section"><a href="#d5e522">2.2. Summary</a></span></dt><dt><span class="section"><a href="#d5e550">2.3. Code each class of the Java Entity class model</a></span></dt><dt><span class="section"><a href="#d5e601">2.4. Code the setter operations</a></span></dt><dt><span class="section"><a href="#d5e612">2.5. Code the add and remove operations</a></span></dt><dt><span class="section"><a href="#d5e650">2.6. Take care of deletion dependencies</a></span></dt><dt><span class="section"><a href="#d5e681">2.7. EntityManagers and Cached Entities </a></span></dt></dl></dd><dt><span class="section"><a href="#d5e711">3. Exploiting Derived Inverse Reference Properties in the User Interface</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e718">3.1. Show information about published books in the <span class="italic">List
					Publishers</span> use case</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e750">4. Run the App and Get the Code</a></span></dt></dl></div><p>In this chapter of our tutorial, we show</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>how to derive a Java <span class="bold"><strong><span class="italic">Entity class
       model</span></strong></span> from an OO class model (that has been derived from an information
     design model),</p></li><li class="listitem"><p>how to code the Entity class model in the form of entity classes (representing
      <span class="italic">model classes</span>),</p></li><li class="listitem"><p>how to write the view and controller code based on the entity classes.</p></li></ol></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e368"></a>1.&nbsp;Make a Java Entity Class Model</h2></div></div></div><p>The starting point for making a Java Entity class model is an OO class model like the
	  one shown in <a class="xref" href="#figBidirAFM" title="Figure&nbsp;1.4.&nbsp;The OO class model">Figure&nbsp;1.4</a> above. Notice that this model contains 
   two bidirectional associations, each of them having two opposite association end dots corresponding to a pair 
   of mutually inverse reference properties:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The first pair is <code class="code">Book</code>::<code class="code">publisher</code> and
       <code class="code">Publisher</code>::<code class="code">/publishedBooks</code>.</p></li><li class="listitem"><p>The second pair is <code class="code">Book</code>::<code class="code">authors</code> and
       <code class="code">Author</code>::<code class="code">/authoredBooks</code>.</p></li></ol></div><p>We now show how to derive a Java Entity class model from the OO class model: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Turn each class into an <code class="code">&laquo;Entity&raquo;</code> class, making all properties private.</p></li><li class="listitem"><p>Replace the platform-independent datatype names of the OO class model with corresponding
     Java datatype classes (Integer, Float, etc.).</p></li><li class="listitem"><p>Add a <code class="code">&laquo;get/set&raquo;</code> stereotype to all non-derived properties for indicating that
     they need getters and setters.</p></li><li class="listitem"><p>Add a <code class="code">&laquo;get&raquo;</code> stereotype to all derived properties for indicating that they
     need getters, only.</p></li><li class="listitem"><p>For any reference property, depending on the functionality type of the association
     represented by it, add a corresponding keyword as property modifier. For the given OO class
     model, add the following property modifiers:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">oneToMany</code> to the derived reference property
         <code class="code">Publisher</code>::<code class="code">/publishedBooks</code>,</p></li><li class="listitem"><p><code class="code">manyToOne</code> to the reference property
         <code class="code">Book</code>::<code class="code">publisher</code></p></li><li class="listitem"><p><code class="code">manyToMany</code> to the reference property
         <code class="code">Book</code>::<code class="code">authors</code></p></li><li class="listitem"><p><code class="code">manyToMany</code> to the derived reference property
         <code class="code">Author</code>::<code class="code">/authoredBooks</code></p></li></ul></div></li><li class="listitem"><p>For any derived reference property designated as the inverse of another reference
     property, replace its {inverse of ...} property modifier with a corresponding {mappedBy="..."}
     property modifier. </p></li><li class="listitem"><p>Create the required property constraint check operations.</p></li><li class="listitem"><p>Create an <span class="italic">add</span>, and a <span class="italic">remove</span> operation for each <span class="italic">multi-valued</span>
     property.</p></li></ol></div><p>This leads to the following Java Entity class model:</p><div class="figure"><a name="d5e431"></a><p class="title"><b>Figure&nbsp;2.1.&nbsp;The Java Entity class model</b></p><div class="figure-contents"><div class="mediaobject"><img src="../fig/Publisher-Book-Author_Bidir_JavaEE.html"></div></div></div><br class="figure-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e437"></a>2.&nbsp;Write the Model Code </h2></div></div></div><p>The Java Entity class model can be directly coded for getting the model layer code of our
   Java back-end app.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e440"></a>2.1.&nbsp;New issues</h3></div></div></div><p>Compared to the <span class="italic">unidirectional association app</span>
				discussed in a previous tutorial, we have to deal with a number of new technical issues: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>In the <span class="italic">model code</span> you now have to take care of
							maintaining the derived inverse reference properties by maintaining the derived (sets
							of) inverse references that form the values of a derived inverse reference property.
							This requires in particular that</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>whenever the value of a <span class="italic"><span class="bold"><strong>single-valued</strong></span></span> master reference property is <span class="bold"><strong><span class="italic">initialized or
											updated</span></strong></span> with the help of a setter (such as assigning a
										reference to an <code class="code">Publisher</code> instance <code class="code">p</code> to
											<code class="code">b.publisher</code> for a <code class="code">Book</code> instance <code class="code">b</code>), an
										inverse reference has to be assigned or added to the corresponding value of the
										derived inverse reference property (such as adding <code class="code">b</code> to
											<code class="code">p.publishedBooks</code>); when the value of the master reference
										property is <span class="italic">updated</span> and the derived inverse
										reference property is <span class="italic">multi-valued</span>, then the
										obsolete inverse reference to the previous value of the single-valued master
										reference property has to be deleted;</p></li><li class="listitem"><p>whenever the value of an optional <span class="italic"><span class="bold"><strong>single-valued</strong></span></span> master reference property is
											<span class="italic"><span class="bold"><strong>unset</strong></span></span>
										(e.g. by assigning <code class="code">null</code> to <code class="code">b.publisher</code> for a
											<code class="code">Book</code> instance <code class="code">b</code>), the inverse reference has to be
										removed from the corresponding value of the derived inverse reference property
										(such as removing <code class="code">b</code> from <code class="code">p.publishedBooks</code>), if the
										derived inverse reference property is multi-valued, otherwise the corresponding
										value of the derived inverse reference property has to be unset or
										updated;</p></li><li class="listitem"><p>whenever a reference is <span class="bold"><strong><span class="italic">added</span></strong></span> to the value of a <span class="bold"><strong><span class="italic">multi-valued</span></strong></span> master reference property with the help
          of an add method (such as adding an <code class="code">Author</code> reference <code class="code">a</code> to
           <code class="code">b.authors</code> for a <code class="code">Book</code> instance <code class="code">b</code>), an inverse
          reference has to be assigned or added to the corresponding value of the derived inverse
          reference property (such as adding <code class="code">b</code> to <code class="code">a.authoredBooks</code>);</p></li><li class="listitem"><p>whenever a reference is <span class="bold"><strong><span class="italic">removed</span></strong></span> from the value of a <span class="bold"><strong><span class="italic">multi-valued</span></strong></span> master reference
										property with the help of a <code class="code">remove</code> method (such as removing a
										reference to an <code class="code">Author</code> instance <code class="code">a</code> from
											<code class="code">b.authors</code> for a <code class="code">Book</code> instance <code class="code">b</code>), the
										inverse reference has to be removed from the corresponding value of the derived
										inverse reference property (such as removing <code class="code">b</code> from
											<code class="code">a.authoredBooks</code>), if the derived inverse reference property is
										multi-valued, otherwise the corresponding value of the derived inverse reference
										property has to be unset or updated;</p></li><li class="listitem"><p>whenever an object with a single reference or with multiple references as the value
          of a master reference property is <span class="bold"><strong><span class="italic">destroyed</span></strong></span> (e.g., when a <code class="code">Book</code> instance <code class="code">b</code>
          with a single reference <code class="code">b.publisher</code> to a <code class="code">Publisher</code> instance
           <code class="code">p</code> is destroyed), the derived inverse references have to be removed first
          (e.g., by removing <code class="code">b</code> from <code class="code">p.publishedBooks</code>).</p></li></ol></div><p>Notice that when a new object is created with a single reference or with multiple
							references as the value of a master reference property (e.g., a new <code class="code">Book</code>
							instance <code class="code">b</code> with a single reference <code class="code">b.publisher</code>), its setter
							or add method will be invoked and will take care of creating the derived inverse
							references. </p></li><li class="listitem"><p>In the <span class="italic">UI code</span> we can now exploit the inverse
							reference properties for more efficiently creating a list of inversely
							associated objects in the <span class="italic">list
								objects</span> use case. For instance, we can more efficiently
							create a list of all published books for each publisher. </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e522"></a>2.2.&nbsp;Summary</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Code each class of the Java Entity class model as a corresponding entity class.</p></li><li class="listitem"><p>Code an {id} property modifier with the JPA annotation <code class="code">@Id</code></p></li><li class="listitem"><p>Code any property modifier denoting the functionality type of a reference property, such
      as {manyToOne}, with the corresponding JPA annotation, such as <code class="code">@ManyToOne</code>.</p></li><li class="listitem"><p>Code the integrity constraints specified in the model with the help of Java Bean
      Validation annotations (or custom validation annotations).</p></li><li class="listitem"><p>Code the getters and setters as well as the <span class="italic">add</span> and
       <span class="italic">remove</span> methods for multi-valued properties.</p></li><li class="listitem"><p>Code the <code class="code">create</code>, <code class="code">retrieve</code>, <code class="code">update</code> and
       <code class="code">delete</code> storage management operations as class-level methods.</p></li><li class="listitem"><p>Take care of the inverse relation management in the <code class="code">create</code> and
       <code class="code">update</code> methods.</p></li></ol></div><p>These steps are discussed in more detail in the following sections.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e550"></a>2.3.&nbsp;Code each class of the Java Entity class model</h3></div></div></div><p>In the <code class="code">Publisher</code> class, we add the <code class="code">publishedBooks</code> property and we
    use the <code class="code">@OneToMany</code> annotation corresponding to <code class="code">@ManyToOne</code> from the
     <code class="code">Book</code> class, representing the inverse relation: </p><pre class="programlisting">@Entity
public class <span class="bold"><strong>Publisher</strong></span> { 
  ...
  <span class="bold"><strong>@OneToMany</strong></span>( fetch=FetchType.EAGER, <span class="bold"><strong>mappedBy="publisher"</strong></span>)
  private Set&lt;Book&gt; <span class="bold"><strong>publishedBooks</strong></span>;
  ...
}</pre><p>The <code class="code">mappedBy</code> parameter of the <code class="code">@OneToMany</code> annotation of the
     <code class="code">Publisher::publishedBooks</code> property specifies the property that implements the
     <code class="code">@ManyToOne</code> relation in the <code class="code">Book</code>
    class:</p><pre class="programlisting">@Entity
public class <span class="bold"><strong>Book</strong></span> { 
  ...
  <span class="bold"><strong>@ManyToOne</strong></span>( fetch=FetchType.EAGER)
  @JoinColumn( name="PUBLISHER_NAME")
  private Publisher <span class="bold"><strong>publisher</strong></span>;
  ...
}</pre><p>In the <code class="code">Author</code> class we add the <code class="code">authoredBooks</code> property with the
					<code class="code">@ManyToMany</code> annotation corresponding to <code class="code">@ManyToMany</code>
				from the <code class="code">Book</code> class representing the inverse
				relation:</p><pre class="programlisting">@Entity
public class <span class="bold"><strong>Author</strong></span> {
  ...
  <span class="bold"><strong>@ManyToMany</strong></span>( fetch=FetchType.EAGER, mappedBy="authors")
  private Set&lt;Book&gt; <span class="bold"><strong>authoredBooks</strong></span>;
  ...
}</pre><p>The <code class="code">mappedBy</code> property of the <code class="code">@ManyToMany</code> annotation for
					<code class="code">authoredBooks</code> property of the <code class="code">Author</code> class specifies
				the property name which implements the <code class="code">@ManyToMany</code> relation in the
					<code class="code">Book</code>
				class:</p><pre class="programlisting">@Entity...
public class <span class="bold"><strong>Book</strong></span> {
  ...
  @ManyToMany( fetch=FetchType.EAGER)
  @JoinTable( name="books_authors", 
      <span class="bold"><strong>joinColumns</strong></span> = { @JoinColumn( name="BOOK_ISBN") }, 
      <span class="bold"><strong>inverseJoinColumns</strong></span> = { @JoinColumn( name="AUTHOR_PERSONID") })
  private Set&lt;Author&gt; <span class="bold"><strong>authors</strong></span>;
  ...
}</pre><p>We also use the <code class="code">@JoinTable</code> annotation to specify the join table name for the
					<span class="italic">Many-To-Many</span> relation and the corresponding
				colum names for the join table, e.g., the table is <code class="code">books_authors</code> and
				the columns are named <code class="code">BOOK_ISBN</code> and
				<code class="code">AUTHOR_PERSONID</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e601"></a>2.4.&nbsp;Code the setter operations</h3></div></div></div><p>Any setter for a reference property that is coupled to a derived inverse reference property
				(implementing a bidirectional association), now also needs to assign/add/remove
				inverse references to/from the corresponding value (set) of the inverse property. An
				example of such a setter is the following <code class="code">setPublisher</code> method:</p><pre class="programlisting">public class <span class="bold"><strong>Book</strong></span> {
  ...
  public void <span class="bold"><strong>setPublisher</strong></span>( Publisher <span class="bold"><strong>publisher</strong></span>) {
    // remove the book from the publishedBooks 
    // of the old publisher (if not null)
    if ( this.publisher != null) {
      <span class="bold"><strong>this.publisher.removePublishedBook( this);</strong></span>
    }
    // add the book to publishedBooks 
    // of the new publisher (if not null)
    if ( publisher != null) {
      <span class="bold"><strong>publisher.addPublishedBook( this);</strong></span>
    }
    <span class="bold"><strong>this.publisher = publisher;</strong></span>
  }
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e612"></a>2.5.&nbsp;Code the add and remove operations</h3></div></div></div><p>For any multi-valued reference property that is coupled to a derived inverse reference
    property, both the <span class="italic">add</span> and the <span class="italic">remove</span> method also have to assign/add/remove corresponding references to/from (the
    value set of) the inverse property.</p><p>For instance, for the multi-valued reference property <code class="code">Book::authors</code> that is
    coupled to the derived inverse reference property <code class="code">Author:authoredBooks</code> for
    implementing the bidirectional authorship association between <code class="code">Book</code> and
     <code class="code">Author</code>, the <code class="code">addAuthor</code> method is coded in the following way:</p><pre class="programlisting">public class <span class="bold"><strong>Book</strong></span> {
  ...
  public void <span class="bold"><strong>addAuthor</strong></span>( Author <span class="bold"><strong>author</strong></span>) {
    if ( this.authors == null) {
      this.authors = new HashSet&lt;Author&gt;();
    }
    if ( !this.authors.contains( author)) {
      // add the new author reference
      <span class="bold"><strong>this.authors.add( author);</strong></span>
      // add the derived inverse reference
      <span class="bold"><strong>author.addAuthoredBook( this);</strong></span>
    }
  }
}</pre><p>For the remove operation <code class="code">removeAuthor</code> we obtain the following code:</p><pre class="programlisting">public class <span class="bold"><strong>Book</strong></span> {
  ...
  public void <span class="bold"><strong>removeAuthor</strong></span>( Author <span class="bold"><strong>author</strong></span>) {
    if ( this.authors != null &amp;&amp; author != null &amp;&amp; this.authors.contains( author)) {
      // delete the author reference
      <span class="bold"><strong>this.authors.remove( author);</strong></span>
      // delete the derived inverse reference 
      <span class="bold"><strong>author.removeAuthoredBook( this);</strong></span>
    }
  }
}</pre><p>Remember, for a Java <code class="code">Collection</code>, such as <code class="code">Set</code> or
				<code class="code">List</code>, the <code class="code">contains</code> method compares two objects by using
				the <code class="code">equals</code> method of the objects. For example, for using the
					<code class="code">contains</code> method over a <code class="code">Set&lt;Authors&gt;</code>, such as
					<code class="code">publishedBooks</code>, in the <code class="code">Author</code> class we implement the
				following <code class="code">equals</code> method (two authors are equal if their
					<code class="code">personId</code> property values are equal):
				</p><pre class="programlisting">public class Author {
  ...
  @Override
  public boolean equals( Object obj) {
    if (obj instanceof Author) {
      Author author = (Author) obj;
      return ( this.personId.equals( author.personId));
    } else return false;
  }
  ...
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e650"></a>2.6.&nbsp;Take care of deletion dependencies</h3></div></div></div><p>When a <code class="code">Book</code> instance <code class="code">b</code>, with a single reference
					<code class="code">b.publisher</code> to a <code class="code">Publisher</code> instance <code class="code">p</code> and
				multiple references <code class="code">b.authors</code> to <code class="code">Author</code> instances, is
				destroyed, the derived inverse references have to be removed first (e.g., by
				removing <code class="code">b</code> from <code class="code">p.publishedBooks)</code>. This is accomplished by
				calling the set methods for the single and multi-valued properties with a
					<code class="code">null</code> parameter, e.g., <code class="code">b.setPublisher(null)</code> and
					<code class="code">b.setAuthors(null)</code> within the <code class="code">Book.destroy</code>
				method:</p><pre class="programlisting">public class <span class="bold"><strong>Book</strong></span> {
  ...
  public static void <span class="bold"><strong>destroy</strong></span>( EntityManager em, UserTransaction ut, String isbn) throws Exception {
    ut.begin();
    Book b = em.find( Book.class, isbn);
    <span class="bold"><strong>b.setPublisher( null);
    b.setAuthors( null);</strong></span>
    em.remove( b);
    ut.commit();  
  }
}</pre><p>In the same way, we have to take care of deleting the references with the <code class="code">Book</code>
				when deleting a <code class="code">Publisher</code> or an <code class="code">Author</code>
				instance:</p><pre class="programlisting">public class <span class="bold"><strong>Author</strong></span> {
  ...
  public static void <span class="bold"><strong>destroy</strong></span>( EntityManager em, UserTransaction ut, Integer personId) throws Exception {
    ut.begin();
    Author a = em.find( Author.class, personId);
    <span class="bold"><strong>a.setAuthoredBooks( null);</strong></span>
    em.remove( a);
    ut.commit();
  }
}

public class <span class="bold"><strong>Publisher</strong></span> { 
  public static void <span class="bold"><strong>destroy</strong></span>( EntityManager em, UserTransaction ut, String name) throws Exception {
    ut.begin();
    Publisher p = em.find( Publisher.class, name);
    <span class="bold"><strong>p.setPublishedBooks( null);</strong></span>
    em.remove( p);
    ut.commit();
  }
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e681"></a>2.7.&nbsp;EntityManagers and Cached Entities </h3></div></div></div><p>Unfortunately, JPA does not provide automatic maintenance of derived inverse references.
    According to the <a class="link" href="https://en.wikibooks.org/wiki/Java_Persistence/Relationships#Object_corruption.2C_one_side_of_the_relationship_is_not_updated_after_updating_the_other_side" target="_top">Java Persistence Wiki</a>, we have to implement the (direct and inverse) relations
    management within set/add/remove methods: <span class="italic">A common problem with
     bidirectional relationships is the application updates one side of the relationship, but the
     other side does not get updated, and becomes out of sync. In JPA, as in Java in general, it is
     the responsibility of the application or the object model to maintain relationships. If your
     application adds to one side of a relationship, then it must add to the other side. This is
     commonly resolved through add or set methods in the object model that handle both sides of the
     relationships, so the application code does not need to worry about it. There are two ways to
     go about this: you can either add the relationship maintenance code to only one side of the
     relationship, and only use the setter from that side (such as making the other side protected),
     or add it to both sides and ensure you avoid an infinite loop</span>. </p><p>We have used for each controller class an entity manager. Every entity manager maintains a
				set of cached entities which can be "shared" with other entity managers by using the
					<code class="code">merge</code> method. In our example code, as part of the <code class="code">create</code>
				and <code class="code">update</code> static methods of each model class, we have to merge the
				updated entities which belongs to another entity manager. For example, for the in
				the case of <code class="code">Book.create</code> method, we need to merge the
					<code class="code">publisher</code> (managed by the entity manager used by the
					<code class="code">PublisherController</code> class) and all the authors (managed by the
				entity manager used by the <code class="code">AuthorController</code> class) which were
				referenced in the new <code class="code">Book</code>
				instance:</p><pre class="programlisting">public class Book {
  public static void create( EntityManager em, UserTransaction ut, 
                          String isbn, String title, Integer year, 
                          Publisher publisher, Set&lt;Author&gt; authors) 
                     throws Exception {
    ut.begin();
    Book book = new Book( isbn, title, year, publisher, authors);
    em.persist( book);
    if ( publisher != null) {
      <span class="bold"><strong>em.merge( publisher);</strong></span>
    }
    if ( authors != null)
      <span class="bold"><strong>for ( Author a : authors) {
        em.merge( a);
      }</strong></span>
    }
    ut.commit();
  }
}</pre><p>Without using <code class="code">merge</code>, the <code class="code">publisher</code> as well as all author instances
				from the <code class="code">authors</code> list, does not represents references to the originally
				cached entities, and are not going to retain our changes, e.g., when needs to be
				reused later with other <code class="code">Book</code> instances. For more details, please check
				the <a class="link" href="http://www.objectdb.com/java/jpa/persistence/detach#Explicit_Merge_" target="_top">Java Persistence Documentation</a> related to this matter.</p><p>It is also possible to disable the JPA caching, so the entities are reloaded from
				database for every new instance, e.g., when <code class="code">EntityManager.find</code> method
				is called. This can be achieved by adding the following line in the
					<code class="code">persistence.xml</code>
				file:</p><pre class="programlisting">&lt;property name = "eclipselink.cache.shared.default" value = "false"/&gt;</pre><p>The above configuration works for <code class="code">eclipselink</code> impelementation and it
				may be different for other API implementations. Notice that disabling entity caching
				is not recommended without a serious reason, while it comes with performance loss
				and may produce unpredicted behavior in some cases, such as using
					<code class="code">@SessionScoped</code> managed entities.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e711"></a>3.&nbsp;Exploiting Derived Inverse Reference Properties in the User Interface</h2></div></div></div><p>We can now exploit the derived inverse reference properties
				<code class="code">Publisher::publishedBooks</code> and <code class="code">Author::authoredBooks</code> for more
			efficiently creating a list of associated books in the <span class="italic">list
				publishers</span> and <span class="italic">list authors</span> use cases. </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e718"></a>3.1.&nbsp;Show information about published books in the <span class="italic">List
					Publishers</span> use case</h3></div></div></div><p>For showing information about published books in the <span class="italic">list
					publishers</span> use case, we can now exploit the derived inverse reference property
					<code class="code">publishedBooks</code>:</p><pre class="programlisting">&lt;ui:composition template="/WEB-INF/templates/page.xhtml"&gt;
  &lt;ui:define name="content"&gt;
    &lt;h:dataTable value="#{publisherController.publishers}" var="p"&gt;
      ...
      <span class="bold"><strong>&lt;h:column&gt;
        &lt;f:facet name="header"&gt;Published books&lt;/f:facet&gt;
        &lt;h:outputText value="#{p.publishedBooks}" escape="false" converter="pl.m.converter.BookListConverter"/&gt;
      &lt;/h:column&gt;</strong></span>
    &lt;/h:dataTable&gt;
    &lt;h:button value="Back" outcome="index" /&gt;
  &lt;/ui:define&gt;
&lt;/ui:composition&gt;</pre><p>In the case of unidirectional associations, for the case of <span class="italic">list
					books</span> use case, we have used a method in the <code class="code">Book</code> model
				class, i.e., <code class="code">getAuthorNames()</code>, which returns a text containing the
				comma separed author names of the
				book:</p><pre class="programlisting">public class Book {
  ...
  public String getAuthorNames() {
    String result = "";
    int i = 0, n = 0;
    if ( this.authors != null) {
      n = this.authors.size();
      for ( Author author : this.authors) {
        result += author.getName();
        if ( i &lt; n - 1) {
          result += ", ";
        }
        i++;
      }
    }
    return result;
  } 
}</pre><p>This
				makes sense in the case of a book, since the number of authors is in general limited
				to a small number. However, a <code class="code">Publisher</code> may have a large number of
				published books. As a better alternative to our string serialization, we can use a
				JSF converter class which allows us to present the list of authors in a custom way.
				In our case, we choose to present it as list of names, where every name is presented
				on a separat line. For this, we implement the
					<code class="code">pl.m.converter.BookListConverter</code> class and we annotate it with
					<span class="bold"><strong>@FacesConverter</strong></span> as
				follows:</p><pre class="programlisting"><span class="bold"><strong>@FacesConverter( value = "pl.m.converter.BookListConverter")</strong></span>
public class BookListConverter implements Converter {
  @Override
  public Object getAsObject( FacesContext context, UIComponent component, String value) {
    // no need for mapping to object...
    return null;
  }
  @Override
  <span class="bold"><strong>public String getAsString( FacesContext context, UIComponent component, Object value) </strong></span>{
    String result = "";
    int i = 0, n = 0;
    if ( value == null) {
      return null;
    } else if ( value instanceof Set&lt;?&gt;) {
      n = ((Set&lt;Book&gt;) value).size();
      for ( Book b : (Set&lt;Book&gt;) value) {
        result += b.getTitle();
        if ( i &lt; n - 1) {
          result += "&lt;br /&gt;";
        }
        i++;
      }
      return result;
    }
    return null;
  }
}
</pre><p>Then, we use the <code class="code">converter</code> attribute in the facelet to specify that our
				converter class, e.g., <code class="code">pl.m.converter.BookListConverter</code>,  has to be
				used when the respective view component needs to be
				rendered:</p><pre class="programlisting">&lt;h:column&gt;
  &lt;f:facet name="header"&gt;Published books&lt;/f:facet&gt;
  <span class="bold"><strong>&lt;h:outputText value="#{p.publishedBooks}" escape="false" converter="pl.m.converter.BookListConverter"/&gt;</strong></span>
&lt;/h:column&gt;</pre><p>Since the serialization text contains HTML elements, i.e., <code class="code">&lt;br /&gt;</code> to produce
				HTML new lines, we have to specify the <span class="bold"><strong>@escape =
					"false"</strong></span> attribute, otherwise <code class="code">&lt;</code> and <code class="code">&gt;</code>
				will be replaced with the corresponding <code class="code">&amp;lt;</code> and
					<code class="code">&amp;gt;</code> entities.</p><p>The main advantage of using JSF converters is that we do not mix model code with
				view specific code, so our model classes remains clean and later, if we like to
				replace JSF with other framework, then our model class reamins unchanged, and we
				just need to take care of a corresponding converter for the new framework. </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e750"></a>4.&nbsp;Run the App and Get the Code</h2></div></div></div><p>Running your application is simple. First stop (if
			already started, otherwise skip this part) your Tomcat/TomEE server by using
			<code class="code">bin/shutdown.bat</code> for Windows OS or <code class="code">bin/shutdown.sh</code> for Linux.
			Next, download and unzip the <a class="link" href="BidirectionalAssociationApp.zip" target="_top">ZIP archive file</a> containing all the source code of the application and also the ANT
			script file which you have to edit and modify the <code class="code">server.folder</code> property value.
			Now, execute the following command in your console or terminal: <code class="code">ant deploy
				-Dappname=bidirectionalassociationapp</code>. Last, start your Tomcat web server (by using
			<code class="code">bin/startup.bat</code> for Windows OS or <code class="code">bin/startup.sh</code> for Linux).
			Please be patient, this can take some time depending on the speed of your computer. It will be
			ready when the console display the following info: <code class="code">INFO: Initializing Mojarra [some
				library versions and paths are shonw here] for context '/bidirectionalassociationapp'</code>. Finally,
			open a web browser and type:
			<code class="code">http://localhost:8080/bidirectionalassociationapp/faces/views/app/index.xhtml</code></p><p>You may want to download the<a class="link" href="lib.html" target="_top"> ZIP
			archive</a> containing all the dependency libaries, or <a class="link" href="http://yew.informatik.tu-cottbus.de/tutorials/java/bidirectionalassociationapp/" target="_top">run the
				unidirectional association app</a> directly from our server.</p></div></div><script data-cfasync="false" src="../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','../../../www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48105674-1', 'tu-cottbus.de');
  ga('send', 'pageview');

</script></div></body>
<!-- Mirrored from web-engineering.info/tech/JavaJpaJsfApp/bidirectional-association-tutorial.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 21 Jul 2023 10:54:49 GMT -->
</html>