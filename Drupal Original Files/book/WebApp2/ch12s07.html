<html>
<!-- Mirrored from web-engineering.info/book/WebApp2/ch12s07.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 21 Jul 2023 11:00:19 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>7.&nbsp;Subtyping and Inheritance in Computational Languages</title><link rel="stylesheet" type="text/css" href="html.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index-2.html" title="Web Applications with JavaScript or Java"><link rel="up" href="ch12.html" title="Chapter&nbsp;12.&nbsp;Subtyping and Inheritance"><link rel="prev" href="ch12s06.html" title="6.&nbsp;The Class Hierarchy Merge Design Pattern"><link rel="next" href="ch12s08.html" title="8.&nbsp;Quiz Questions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">7.&nbsp;Subtyping and Inheritance in Computational Languages</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch12s06.html"><img src="images/prev.svg" alt="Prev"></a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;12.&nbsp;Subtyping and Inheritance</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch12s08.html"><img src="images/next.svg" alt="Next"></a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e4292"></a>7.&nbsp;Subtyping and Inheritance in Computational Languages</h2></div></div></div><p>Subtyping and inheritance have been supported in <span class="italic">Object-Oriented Programming (OOP)</span>, in database languages (such as <span class="italic">SQL99</span>), in the XML schema definition language <span class="italic">XML Schema</span>, and in other computational languages, in various ways and to different degrees. At its core, subtyping in computational languages is about defining type hierarchies and the inheritance of features: properties, constraints and methods in OOP; table columns and constraints in SQL99; elements, attributes and constraints in XML Schema.</p><p>In general, it is desirable to have support for <span class="italic">multiple classification</span> and <span class="italic">multiple inheritance</span> in type hierarchies. Both language features are closely related and are considered to be advanced features, which may not be needed in many applications or can be dealt with by using workarounds.</p><p><span class="bold"><strong><span class="italic">Multiple classification</span></strong></span><a class="indexterm" name="d5e4304"></a> means that an object has more than one direct type. This is mainly the case when an object plays multiple roles at the same time, and therefore directly instantiates multiple classes defining these roles.</p><p><span class="bold"><strong><span class="italic">Multiple inheritance</span></strong></span><a class="indexterm" name="d5e4309"></a> is typically also related to role classes. For instance, a student assistant is a person playing both the role of a student and the role of an academic staff member, so a corresponding OOP class <code class="code">StudentAssistant</code> inherits from both role classes <code class="code">Student</code> and <code class="code">AcademicStaffMember</code>. In a similar way, in our example model above, an <code class="code">AmphibianVehicle</code> inherits from both role classes <code class="code">LandVehicle</code> and <code class="code">WaterVehicle</code>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e4317"></a>7.1.&nbsp;Subtyping and inheritance in OOP</h3></div></div></div><p>The minimum level of support for subtyping in OOP, as provided, for instance, by Java and C#, allows defining inheritance of properties and methods in single-inheritance hierarchies, which can be inspected with the help of an <span class="bold"><strong><span class="italic">is-instance-of</span></strong></span> predicate that allows testing if a class is the direct or an indirect type of an object. In addition, it is desirable to be able to inspect inheritance hierarchies with the help of</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>a predefined instance-level property for retrieving <span class="bold"><strong><span class="italic">the direct type of an object</span></strong></span> (or its <span class="italic">direct types</span>, if multiple classification is allowed);</p></li><li class="listitem"><p>a predefined type-level property for retrieving <span class="bold"><strong><span class="italic">the direct supertype of a type</span></strong></span> (or its <span class="italic">direct supertypes</span>, if multiple inheritance is allowed).</p></li></ol></div><p>A special case of an OOP language is JavaScript, which did originally not have an explicit language element for defining classes, but only for defining constructor functions. Due to its dynamic programming features, JavaScript allows using various code patterns for implementing classes, subtyping and inheritance. In modern JavaScript, starting from ES2015, defining a superclass and a subclass is straightforward. First, we define a base class, <code class="code">Person</code>, with two properties, <code class="code">firstName</code> and <code class="code">lastName</code>:</p><pre class="programlisting"><span class="bold"><strong>class</strong></span> Person {
  <span class="bold"><strong>constructor</strong></span> (first, last) {
    // assign base class properties
    this.firstName = first; 
    this.lastName = last; 
  }
}</pre><p>Then, we define a subclass, <code class="code">Student</code>, with one additional property, <code class="code">studentNo</code>:</p><pre class="programlisting">
class Student <span class="bold"><strong>extends</strong></span> Person {
  constructor (first, last, studNo) {
    // invoke constructor of superclass
    <span class="bold"><strong>super</strong></span>( first, last);
    // assign additional properties
    this.studentNo = studNo;
  }
}</pre><p>Notice how the constructor of the superclass is invoked with <code class="code">super( first, last)</code> for assigning the superclass properties.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e4348"></a>7.2.&nbsp;Subtyping and inheritance with XML Schema</h3></div></div></div><p>In XML Schema, a subtype can be defined by <span class="italic">extending</span> or by <span class="italic">restricting</span> an existing complex type. While extending a complex type means <span class="bold"><strong><span class="italic">extending its intension</span></strong></span> by adding elements or attributes, restricting a complex type means <span class="bold"><strong><span class="italic">restricting its extension</span></strong></span> by adding constraints.</p><p>We can define a complex type <code class="code">Person</code> and a subtype <code class="code">Student</code> by extending <code class="code">Person</code> in the following way:</p><pre class="programlisting">&lt;xs:complexType name="<span class="bold"><strong>Person</strong></span>"&gt;
  &lt;xs:attribute name="firstName" type="xs:string" /&gt;
  &lt;xs:attribute name="lastName" type="xs:string" /&gt;
  &lt;xs:attribute name="gender" type="GenderValue" /&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="<span class="bold"><strong>Student</strong></span>"&gt;
  &lt;xs:<span class="bold"><strong>extension</strong></span> base="Person"&gt;
    &lt;xs:attribute name="studentNo" type="xs:string" /&gt;
  &lt;/xs:extension&gt;
&lt;/xs:complexType&gt;</pre><p>We can define a subtype <code class="code">FemalePerson</code> by restricting <code class="code">Person</code> in the following way:</p><pre class="programlisting">&lt;xs:complexType name="FemalePerson"&gt;
  &lt;xs:<span class="bold"><strong>restriction</strong></span> base="Person"&gt;
    &lt;xs:attribute name="firstName" type="xs:string" /&gt;
    &lt;xs:attribute name="lastName" type="xs:string" /&gt;
    &lt;xs:attribute name="gender" type="GenderValue" 
        <span class="bold"><strong>use="fixed" value="f"</strong></span> /&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:complexType&gt;</pre><p>Notice that by fixing the value of the <code class="code">gender</code> attribute to "f", we define a constraint that is only satisfied by the female instances of <code class="code">Person</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e4374"></a>7.3.&nbsp;Subtyping and inheritance with OWL</h3></div></div></div><p>In the Web Ontology Language OWL, property definitions are separated from class definitions and properties are not single-valued, but multi-valued by default. Consequently, standard properties need to be declared as <span class="italic">functional</span>. Thus, we obtain the following code for expressing that <code class="code">Person</code> is a class having the property <code class="code">name</code>:</p><pre class="programlisting">&lt;owl:<span class="bold"><strong>Class</strong></span> rdf:ID="<span class="bold"><strong>Person</strong></span>"/&gt;
&lt;owl:<span class="bold"><strong>DatatypeProperty</strong></span> rdf:ID="<span class="bold"><strong>name</strong></span>"&gt;
    &lt;rdfs:<span class="bold"><strong>domain</strong></span> rdf:resource="#Person"/&gt;
    &lt;rdfs:<span class="bold"><strong>range</strong></span> rdf:resource="xsd:string"/&gt;
    &lt;rdf:type rdf:resource="owl:FunctionalProperty"/&gt;
&lt;/owl:DatatypeProperty&gt;</pre><p>OWL allows stating that a class is a subclass of another class in the following way:</p><pre class="programlisting">&lt;owl:Class rdf:ID="<span class="bold"><strong>Student</strong></span>"&gt;
    &lt;rdfs:<span class="bold"><strong>subClassOf</strong></span> rdf:resource="#<span class="bold"><strong>Person</strong></span>"/&gt;
&lt;/owl:Class&gt;
&lt;owl:DatatypeProperty rdf:ID="<span class="bold"><strong>studentNo</strong></span>"&gt;
    &lt;rdfs:domain rdf:resource="#Student"/&gt;
    &lt;rdfs:range rdf:resource="xsd:string"/&gt;
    &lt;rdf:type rdf:resource="owl:FunctionalProperty"/&gt;
&lt;/owl:DatatypeProperty&gt;</pre><p>For better usability, OWL should allow to define the properties of a class within a class definition, using the case of functional properties as the default case.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="secInheritTbl"></a>7.4.&nbsp;Representing class hierarchies with SQL database tables</h3></div></div></div><p>A standard DBMS stores information (objects) in the rows of tables, which have been conceived as set-theoretic relations in classical <span class="italic">relational</span> database systems. The relational database language SQL is used for defining, populating, updating and querying such databases. But there are also simpler data storage techniques that allow to store data in the form of table rows, but do not support SQL. In particular, key-value storage systems, such as JavaScript's Local Storage API, allow storing a serialization of a <span class="bold"><strong><span class="italic">JS entity table</span></strong></span> (a map of entity records) as the string value associated with the table name as a key.</p><p>While in the classical version of SQL (SQL92) there is no support for subtyping and inheritance, this has been changed in SQL99. However, the subtyping-related language elements of SQL99 have only been implemented in some DBMS, for instance in the open source DBMS <span class="italic">PostgreSQL</span>. As a consequence, for making a design model that can be implemented with various frameworks using various SQL DBMSs (including weaker technologies such as <span class="italic">MySQL</span> and <span class="italic">SQLite</span>), we cannot use the SQL99 features for subtyping, but have to model inheritance hierarchies in database design models by means of plain tables and foreign key dependencies. This mapping from class hierarchies to relational tables (and back) is the business of <span class="italic"><span class="bold"><strong>Object-Relational-Mapping</strong></span></span><a class="indexterm" name="d5e4406"></a> frameworks such as <a class="link" href="https://en.wikibooks.org/wiki/Java_Persistence/What_is_JPA%3F" target="_top">JPA</a> Providers (like <a class="link" href="https://en.wikipedia.org/wiki/Hibernate_(Java)" target="_top">Hibernate</a>), Microsoft's <a class="link" href="https://docs.microsoft.com/en-us/ef/" target="_top">Entity Framework</a>, or the <a class="link" href="http://guides.rubyonrails.org/association_basics.html" target="_top">Active Record</a> approach of the <a class="link" href="http://rubyonrails.org/" target="_top">Rails</a> framework.</p><p>There are essentially three alternative approaches how to represent a class hierarchy with database tables:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="italic"><span class="bold"><strong> <a class="link" href="http://www.martinfowler.com/eaaCatalog/singleTableInheritance.html" target="_top">Single Table Inheritance</a></strong></span> (STI)<a class="indexterm" name="d5e4420"></a></span> is the simplest approach, where the entire class hierarchy is represented by a single table, containing columns for all attributes of the root class and of all its subclasses, and named after the name of the root class.</p></li><li class="listitem"><p><span class="italic"><span class="bold"><strong> <a class="link" href="https://en.wikibooks.org/wiki/Java_Persistence/Inheritance#Joined.2C_Multiple_Table_Inheritance" target="_top">Table per Class Inheritance</a></strong></span> (TCI)</span><a class="indexterm" name="d5e4428"></a> is an approach, where each class of the hierarchy is represented by a corresponding table containing also columns for inherited properties, thus repeating the columns of the tables that represent its superclasses.</p></li><li class="listitem"><p><span class="italic"><span class="bold"><strong><a class="link" href="https://en.wikibooks.org/wiki/Java_Persistence/Inheritance#Joined.2C_Multiple_Table_Inheritance" target="_top">Joined Tables Inheritance</a></strong></span> (JTI)</span><a class="indexterm" name="d5e4436"></a> is a more logical approach, where each segment subclass is represented by a corresponding table (subtable) connected to the table representing its superclass (supertable) via its primary key referencing the primary key of the supertable, such that the (inherited) properties of the superclass are not represented as columns in subtables.</p></li></ol></div><p>Notice that the STI approach is closely related to the <span class="italic">Class Hierarchy Merge</span> design pattern discussed in <a class="xref" href="ch12s06.html" title="6.&nbsp;The Class Hierarchy Merge Design Pattern">Section&nbsp;6</a> above. Whenever this design pattern has already been applied in the design model, or the design model has already been re-factored according to this design pattern, the class hierarchies concerned (their subclasses) have been eliminated in the design, and consequently also in the data model to be coded in the form of class definitions in the app's model layer, so there is no need anymore to map class hierarchies to single tables. Otherwise, the design model contains a class hierarchy that is implemented with a corresponding class hierarchy in the app's model layer, which would be mapped to database tables with the help of the STI approach.</p><p>We illustrate the use of these approaches with the help of two simple examples. The first example is the <code class="code">Book</code> class hierarchy, which is shown in <a class="xref" href="ch12s01.html#figBookClassHierarchy" title="Figure&nbsp;12.1.&nbsp;The object type Book with two subtypes: TextBook and Biography">Figure&nbsp;12.1</a> above. The second example is the class hierarchy of the <code class="code">Person</code> roles <code class="code">Employee</code>, <code class="code">Manager</code> and <code class="code">Author</code>, shown in the class diagram in <a class="xref" href="ch12s07.html#figPersonRoles1" title="Figure&nbsp;12.8.&nbsp;An information design model with a Person roles hierarchy">Figure&nbsp;12.8</a> below.</p><div class="figure"><a name="figPersonRoles1"></a><div class="figure-title">Figure&nbsp;12.8.&nbsp;An information design model with a <code class="code">Person</code> roles hierarchy</div><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="320"><tr><td><img src="resources/PersonRoleHierarchy.png" width="320" alt="An information design model with a Person roles hierarchy"></td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e4456"></a>7.4.1.&nbsp;Single Table Inheritance</h4></div></div></div><p>Consider the single-level class hierarchy shown in <a class="xref" href="ch12s01.html#figBookClassHierarchy" title="Figure&nbsp;12.1.&nbsp;The object type Book with two subtypes: TextBook and Biography">Figure&nbsp;12.1</a> above, which is an incomplete disjoint segmentation of the class <code class="code">Book</code>, as the design for the model classes of an MVC app. In such a case, whenever we have a model class hierarchy with only one level (or only a few levels) of subtyping and each subtype has only a few additional properties, it's preferable to use STI<a class="indexterm" name="d5e4461"></a>, so we model a single table containing columns for all attributes such that the columns representing additional attributes of segment subclasses ("segment attributes") are optional, as shown in the SQL table model in <a class="xref" href="ch12s07.html#figTextBookIsaBookSingleTableInheritSqlM" title="Figure&nbsp;12.9.&nbsp;An SQL table model with a single table representing the Book class hierarchy">Figure&nbsp;12.9</a> below.</p><div class="figure"><a name="figTextBookIsaBookSingleTableInheritSqlM"></a><div class="figure-title">Figure&nbsp;12.9.&nbsp;An SQL table model with a single table representing the <code class="code">Book</code> class hierarchy</div><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="400"><tr><td><img src="resources/BookClassHierarchy_SqlM.png" width="400" alt="An SQL table model with a single table representing the Book class hierarchy"></td></tr></table></div></div></div><p>It is a common approach to add a special <span class="italic">discriminator column</span><a class="indexterm" name="d5e4473"></a> for representing the category of each row corresponding to the subclass instantiated by the represented object. Such a column would normally be string-valued, but constrained to one of the names of the subclasses. If the DBMS supports enumerations, it could also be enumeration-valued. We use the name <code class="code">category</code> for the discriminator column, which, in the case of our <code class="code">Book</code> class hierarchy example, has a frozen value constraint since the textbook-biography segmentation is rigid.</p><p>Based on the <code class="code">category</code> of a book, we have to enforce that if and only if it is "TextBook", its attribute <code class="code">subjectArea</code> has a value, and if and only if it is "Biography", its attribute <code class="code">about</code> has a value. This implied constraint is expressed in the invariant box attached to the <code class="code">Book</code> table class in the class diagram above, where the logical operator keyword "IFF" represents the logical equivalence operator "if and only if". It needs to be implemented in the database, e.g., with an SQL table CHECK clause or with SQL triggers.</p><p>When the given segmentation is disjoint, a single-valued enumeration attribute <code class="code">category</code> is used for representing the information to which subclass an instance belongs. Otherwise, if it is non-disjoint, a multi-valued enumeration attribute <code class="code">categories</code> is used for representing the information to which subclasses an instance belongs. Such an attribute can be implemented in SQL by defining a string-valued column for representing a set of enumeration codes or labels as corresponding string concatenations.</p><p>Consider the class hierarchy shown in <a class="xref" href="ch12s07.html#figPersonRoles1" title="Figure&nbsp;12.8.&nbsp;An information design model with a Person roles hierarchy">Figure&nbsp;12.8</a> above. With only three additional attributes defined in the subclasses <code class="code">Employee</code>, <code class="code">Manager</code> and <code class="code">Author</code>, this class hierarchy can again be mapped with the STI approach, as shown in the SQL table model <a class="xref" href="ch12s07.html#figPersonRolesSingleTableInheritance" title="Figure&nbsp;12.10.&nbsp;An STI table model representing the Person roles hierarchy">Figure&nbsp;12.10</a> below.</p><div class="figure"><a name="figPersonRolesSingleTableInheritance"></a><div class="figure-title">Figure&nbsp;12.10.&nbsp;An STI table model representing the <code class="code">Person</code> roles hierarchy</div><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="400"><tr><td><img src="resources/PersonRoles_SingleTblSqlM.png" width="400" alt="An STI table model representing the Person roles hierarchy"></td></tr></table></div></div></div><p>Notice that now the discriminator column <code class="code">categories</code> is multi-valued, since the segmentation of <code class="code">Person</code> is not disjoint, but overlapping, implying that a <code class="code">Person</code> object may belong to several categories. Notice also that, since a role segmentation (like <span class="italic">Employee</span>, <span class="italic">Manager</span>, <span class="italic">Author</span>) is not rigid, the discriminator column <code class="code">categories</code> does not have a frozen value constraint.</p><p>An example of an admissible population for this model is the following:</p><div class="informaltable"><table frame="box" rules="all"><thead><tr><th colspan="6">people</th></tr><tr><th>person_id</th><th>name</th><th>categories</th><th>biography</th><th>emp_no</th><th>department</th></tr></thead><tbody><tr><td>1001</td><td>Harry Wagner</td><td>Author, Employee</td><td>Born in Boston, MA, in 1956, ...</td><td>21035</td><td></td></tr><tr><td>1002</td><td>Peter Boss</td><td>Manager</td><td></td><td>23107</td><td>Sales</td></tr><tr><td>1003</td><td>Tom Daniels</td><td></td><td></td><td></td><td></td></tr><tr><td>1077</td><td>Immanuel Kant</td><td>Author</td><td>Immanuel Kant (1724-1804) was a German philosopher ...</td><td></td><td></td></tr></tbody></table></div><p>Notice that the <code class="code">Person</code> table contains four different types of people:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A person, Harry Wagner, who is both an author (with a biography) and an employee (with an employee number).</p></li><li class="listitem"><p>A person, Peter Boss, who is a manager (a special type of employee), managing the Sales department.</p></li><li class="listitem"><p>A person, Tom Daniels, who is neither an author nor an employee.</p></li><li class="listitem"><p>A person, Immanuel Kant, who is an author (with a biography).</p></li></ol></div><p><span class="bold"><strong>Pros</strong></span> of the STI approach: It leads to a faithful representation of the subtype relationships expressed in the original class hierarchy; in particular, any row representing a subclass instance (an employee, manager or author) also represents a superclass instance (a person).</p><p><span class="bold"><strong>Cons</strong></span>: (1) In the case of a multi-level class hierarchy where the subclasses have little in common, the STI approach does not lead to a good representation. (2) The structure of the given class hierarchy in terms of its elements (classes) is only implicitly preserved.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e4562"></a>7.4.2.&nbsp;Table per Class Inheritance</h4></div></div></div><p>In a more realistic model, the subclasses of <code class="code">Person</code> shown in <a class="xref" href="ch12s07.html#figPersonRoles1" title="Figure&nbsp;12.8.&nbsp;An information design model with a Person roles hierarchy">Figure&nbsp;12.8</a> above would have many more attributes, so the STI approach would be no longer feasible. In the TCI<a class="indexterm" name="d5e4567"></a> approach we get the SQL table model shown in <a class="xref" href="ch12s07.html#figPersRoles_MTI_SQL" title="Figure&nbsp;12.11.&nbsp;A TCI table model representing the Person roles hierarchy">Figure&nbsp;12.11</a> below. A TCI model represents each concrete class of the class hierarchy as a table, such that each segment subclass is represented by a table that also contains columns for inherited properties, thus repeating the columns of the table that represents the superclass.</p><div class="figure"><a name="figPersRoles_MTI_SQL"></a><div class="figure-title">Figure&nbsp;12.11.&nbsp;A TCI table model representing the <code class="code">Person</code> roles hierarchy</div><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="360"><tr><td><img src="resources/PersonRoles_TCI.png" width="360" alt="A TCI table model representing the Person roles hierarchy"></td></tr></table></div></div></div><p>A TCI table model can be derived from the information design model by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Replacing the standard ID property modifier {id} in all classes with {pkey} for indicating that the standard ID property is a <span class="italic">primary key</span>.</p></li><li class="listitem"><p>Replacing the singular (capitalized) class names (<span class="italic">Person</span>, <span class="italic">Author</span>, etc.) with pluralized lowercase table names (<span class="italic">people</span>, <span class="italic">authors</span>, etc.), and replacing camel case property names (<span class="italic">personId</span> and <span class="italic">empNo</span>) with lowercase underscore-separated names for columns (<span class="italic">person_id</span> and <span class="italic">emp_no</span>).</p></li><li class="listitem"><p>Adding a &laquo;table&raquo; stereotype to all class rectangles.</p></li><li class="listitem"><p>Replacing the platform-independent datatype names with SQL datatype names.</p></li><li class="listitem"><p>Dropping all generalization/inheritance arrows and adding all columns of supertables (such as <code class="code">person_id</code> and <code class="code">name</code> from <code class="code">people</code>) to their subtables (<code class="code">authors</code> and <code class="code">employees</code>).</p></li></ol></div><p>Each table would only be populated with rows corresponding to the direct instances of the represented class. An example of an admissible population for this model is the following:</p><div class="informaltable"><table frame="box" rules="all"><thead><tr><th colspan="2">people</th></tr><tr><th>personId</th><th>name</th></tr></thead><tbody><tr><td>1003</td><td>Tom Daniels</td></tr></tbody></table></div><div class="informaltable"><table frame="box" rules="all"><thead><tr><th colspan="3">authors</th></tr><tr><th>person_id</th><th>name</th><th>biography</th></tr></thead><tbody><tr><td>1001</td><td>Harry Wagner</td><td>Born in Boston, MA, in 1956, ...</td></tr><tr><td>1077</td><td>Immanuel Kant</td><td>Immanuel Kant (1724-1804) was a German philosopher ...</td></tr></tbody></table></div><div class="informaltable"><table frame="box" rules="all"><thead><tr><th colspan="3">employees</th></tr><tr><th>person_id</th><th>name</th><th>emp_no</th></tr></thead><tbody><tr><td>1001</td><td>Harry Wagner</td><td>21035</td></tr></tbody></table></div><div class="informaltable"><table frame="box" rules="all"><thead><tr><th colspan="4">managers</th></tr><tr><th>person_id</th><th>name</th><th>emp_no</th><th>department</th></tr></thead><tbody><tr><td>1002</td><td>Peter Boss</td><td>23107</td><td>Sales</td></tr></tbody></table></div><p><span class="bold"><strong>Pros</strong></span> of the TCI approach: (1) The structure of the given class hierarchy in terms of its elements (classes) is explicitly preserved. (2) When the segmentations of the given class hierarchy are disjoint, TCI leads to memory-efficient non-redundant storage.</p><p><span class="bold"><strong>Cons</strong></span>: (1) The TCI approach does not yield a faithful representation of the subtype relationships expressed in the original class hierarchy. In particular, for any row representing a subclass instance (an employee, manager or author) there is no information that it represents a superclass instance (a person). Thus, the TCI database schema does not inform about the represented subtype relationships; rather, this meta-information, which is kept in the app's class model, is de-coupled from the database. (2) The TCI approach requires repeating column definitions, which is a form of schema redundancy. (3) The TCI approach may imply data redundancy whenever the segment subclasses overlap. In our example, authors can also be employees, so for any person in the overlap, we would need to duplicate the data storage for all columns representing properties of the superclass (in our example, this only concerns the property <code class="code">name</code>).</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e4665"></a>7.4.3.&nbsp;Joined Tables Inheritance</h4></div></div></div><p>For avoiding the data redundancy problem of TCI in the case of overlapping segmentations, we could take the JTI<a class="indexterm" name="d5e4668"></a> approach as exemplified in the SQL table model shown in <a class="xref" href="ch12s07.html#figPersonRolesSqlM" title="Figure&nbsp;12.12.&nbsp;A JTI table model representing the Person roles hierarchy">Figure&nbsp;12.12</a> below. This model connects tables representing subclasses (<span class="italic">subtables</span>) to tables representing their superclasses (<span class="italic">supertables</span>) by defining their primary key column(s) to be at the same time a foreign key referencing their supertable's primary key. Notice that foreign keys are visualized in the form of UML dependency arrows stereotyped with &laquo;fkey&raquo; and annotated at their source table side with the name of the foreign key column.</p><div class="figure"><a name="figPersonRolesSqlM"></a><div class="figure-title">Figure&nbsp;12.12.&nbsp;A JTI table model representing the <code class="code">Person</code> roles hierarchy</div><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="450"><tr><td><img src="resources/PersonRoles_JoinTablesInheritSqlM.png" width="450" alt="A JTI table model representing the Person roles hierarchy"></td></tr></table></div></div></div><p>An example of an admissible population for this model is the following:</p><div class="informaltable"><table frame="box" rules="all"><thead><tr><th colspan="2">people</th></tr><tr><th>person_id</th><th>name</th></tr></thead><tbody><tr><td>1001</td><td>Harry Wagner</td></tr><tr><td>1002</td><td>Peter Boss</td></tr><tr><td>1003</td><td>Tom Daniels</td></tr><tr><td>1077</td><td>Immanuel Kant</td></tr></tbody></table></div><div class="informaltable"><table frame="box" rules="all"><thead><tr><th colspan="2">authors</th></tr><tr><th>person_id</th><th>biography</th></tr></thead><tbody><tr><td>1001</td><td>Born in Boston, MA, in 1956, ...</td></tr><tr><td>1077</td><td>Immanuel Kant (1724-1804) was a German philosopher ...</td></tr></tbody></table></div><div class="informaltable"><table frame="box" rules="all"><thead><tr><th colspan="4">employees</th></tr><tr><th>person_id</th><th>emp_no</th></tr></thead><tbody><tr><td>1001</td><td>21035</td></tr><tr><td>1002</td><td>23107</td></tr></tbody></table></div><div class="informaltable"><table frame="box" rules="all"><thead><tr><th colspan="4">managers</th></tr><tr><th>person_id</th><th>department</th></tr></thead><tbody><tr><td>1002</td><td>Sales</td></tr></tbody></table></div><p><span class="bold"><strong>Pros</strong></span> of the JTI approach: (1) Subtyping relationships and the structure of class hierarchies are explicitly preserved. (2) Data redundancy in the case of overlapping segmentations is avoided.</p><p><span class="bold"><strong>Cons</strong></span>: (1) The main disadvantage of the JTI approach is that for querying a subclass, <span class="italic">join queries</span> (for joining the segregated entity data) are required, which may create performance issues.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch12s06.html"><img src="images/prev.svg" alt="Prev"></a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch12.html"><img src="images/up.svg" alt="Up"></a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch12s08.html"><img src="images/next.svg" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">6.&nbsp;The <span class="italic">Class Hierarchy Merge</span> Design Pattern&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index-2.html"><img src="images/home.svg" alt="Home"></a></td><td width="40%" align="right" valign="top">&nbsp;8.&nbsp;Quiz Questions</td></tr></table></div></body>
<!-- Mirrored from web-engineering.info/book/WebApp2/ch12s07.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 21 Jul 2023 11:00:21 GMT -->
</html>