<html>
<!-- Mirrored from web-engineering.info/book/WebApp2/ch13s03.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 21 Jul 2023 11:00:22 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>3.&nbsp;Case Study 2: Implementing a Class Hierarchy</title><link rel="stylesheet" type="text/css" href="html.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index-2.html" title="Web Applications with JavaScript or Java"><link rel="up" href="ch13.html" title="Chapter&nbsp;13.&nbsp;Subtyping with Plain JS"><link rel="prev" href="ch13s02.html" title="2.&nbsp;Case Study 1: Eliminating a Class Hierarchy"><link rel="next" href="ch13s04.html" title="4.&nbsp;Quiz Questions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.&nbsp;Case Study 2: Implementing a Class Hierarchy</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch13s02.html"><img src="images/prev.svg" alt="Prev"></a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;13.&nbsp;Subtyping with Plain JS</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch13s04.html"><img src="images/next.svg" alt="Next"></a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e5118"></a>3.&nbsp;Case Study 2: Implementing a Class Hierarchy</h2></div></div></div><p>Whenever a class hierarchy is more complex, we cannot simply eliminate it, but have to implement it (1) in the app's model code, (2) in the underlying database and (3) in its user interface.</p><p>The starting point for our case study is the design model shown in <a class="xref" href="ch12s07.html#figPersonRoles1" title="Figure&nbsp;12.8.&nbsp;An information design model with a Person roles hierarchy">Figure&nbsp;12.8</a> above. In the following sections, we derive a <span class="italic">JS class model</span> and a <span class="italic">JS entity table model</span> from the design model. The entity table model is used as a design for the object-to-storage mapping that we need for storing the objects of our app with the browsers' Local Storage technology.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e5125"></a>3.1.&nbsp;Make a JS class model</h3></div></div></div><p>We design the <span class="italic">model classes</span> of our example app with the help of a <span class="italic">JS class model</span> that we derive from the <span class="italic">design model</span> by essentially leaving the generalization arrows as they are and just adding <span class="italic">get/set</span> methods and static <span class="italic">check</span> functions to each class. However, in the case of our example app, it is natural to apply the <span class="italic">Class Hierarchy Merge</span> design pattern (discussed in <a class="xref" href="ch12s06.html" title="6.&nbsp;The Class Hierarchy Merge Design Pattern">Section&nbsp;6</a>) to the single-subclass-segmentation of <code class="code">Employee</code> for simplifying the class model by eliminating the <code class="code">Manager</code> subclass. This leads to the model shown in <a class="xref" href="ch13s03.html#figPersonRolesJsM" title="Figure&nbsp;13.2.&nbsp;The JS class model of the Person roles class hierarchy">Figure&nbsp;13.2</a> below. Notice that a <code class="code">Person</code> may be an <code class="code">Employee</code> or an <code class="code">Author</code> or both.</p><div class="figure"><a name="figPersonRolesJsM"></a><div class="figure-title">Figure&nbsp;13.2.&nbsp;The JS class model of the <code class="code">Person</code> roles class hierarchy</div><div class="figure-contents"><div class="mediaobject"><img src="resources/PersonRoleHierarchy_JsM.png"></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e5148"></a>3.2.&nbsp;Make a JS entity table model</h3></div></div></div><p>Since we use the browsers' <span class="italic">Local Storage</span> as the persistent storage technology for our example app, we have to deal with simple key-value storage. For each design model class with a singular (capitalized) name <code class="code">Entity</code>, we use its pluralized lowercase name <code class="code">entities</code> as the corresponding table name and as a key such that its associated string value is obtained by serializing the object collection <code class="code">Entity.instances</code> with the help of the <code class="code">JSON.stringify</code> method.</p><p>We design a set of suitable JS entity tables in the form of a <span class="italic">JS entity table model</span> that we derive from the information design model. We have to make certain choices how to organize our data store and how to derive a corresponding entity table model.</p><p>The first choice to make concerns using either the <span class="italic">Single Table Inheritance (STI)</span>, the <span class="italic">Table per Class Inheritance (TCI)</span> or the <span class="italic">Joined Tables Inheritance (JTI)</span> approach, which are introduced in <a class="xref" href="ch12s07.html#secInheritTbl" title="7.4.&nbsp;Representing class hierarchies with SQL database tables">Section&nbsp;7.4</a>. In the STI approach, a segmentation (or an entire class hierarchy) is represented with a single table, containing columns for all attributes of all classes involved, as shown in the following example.</p><div class="figure"><a name="figPersonRolesSingleTbl"></a><div class="figure-title">Figure&nbsp;13.3.&nbsp;An STI model of the <code class="code">Person</code> roles class hierarchy</div><div class="figure-contents"><div class="mediaobject"><img src="resources/PersonRoles_STI_JS.png"></div></div></div><p>Since the given segmentation is non-disjoint, a multi-valued enumeration attribute <code class="code">categories</code> is used for representing the information to which subclasses an instance belongs.</p><p>Using the STI approach is feasible for the given example, since the role hierarchy does not have many levels and the segment subclasses do not add many attributes. But, in a more realistic example, we would have a lot more attributes in the segment subclasses of the given role hierarchy. The STI approach is not really an option for representing a multi-level role hierarchy. However, we may choose it for representing the single-segment class hierarchy <code class="code">Manager</code>-is-subclass-of-<code class="code">Employee</code>.</p><p>For simplicity, and because the browsers' <span class="italic">Local Storage</span> does not support foreign keys as required by JTI, we choose the TCI approach, where we obtain a separate table for each class of the <code class="code">Person</code> segmentation, but without foreign keys. Our choices result in the model shown in <a class="xref" href="ch13s03.html#figPersonRoles_TCI" title="Figure&nbsp;13.4.&nbsp;A TCI model of the Person roles class hierarchy">Figure&nbsp;13.4</a> below, which has been derived from the design model shown in Figure <a class="xref" href="ch12s07.html#figPersonRoles1" title="Figure&nbsp;12.8.&nbsp;An information design model with a Person roles hierarchy">Figure&nbsp;12.8</a> by</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Merging the <code class="code">Manager</code> subclass into its superclass <code class="code">Employee</code>, according to the <span class="italic">Class Hierarchy Merge</span> design pattern described in <a class="xref" href="ch12s06.html" title="6.&nbsp;The Class Hierarchy Merge Design Pattern">Section&nbsp;6</a>.</p></li><li class="listitem"><p>Replacing the standard ID property modifier {id} of the <code class="code">personId</code> attribute of <code class="code">Person</code>, <code class="code">Author</code> and <code class="code">Employee</code> with {pkey} for indicating that the attribute is a <span class="italic">primary key</span>.</p></li><li class="listitem"><p>Replacing the singular (capitalized) class names (<span class="italic">Person</span>, <span class="italic">Author</span> and <span class="italic">Employee</span>) with pluralized lowercase table names (<span class="italic">people</span>, <span class="italic">authors</span> and <span class="italic">employees</span>).</p></li><li class="listitem"><p>Adding the &laquo;JS entity table&raquo; stereotype to all class rectangles (<code class="code">people</code>, <code class="code">authors</code> and <code class="code">employees</code>).</p></li><li class="listitem"><p>Replacing the platform-independent datatype names with JS datatype names.</p></li><li class="listitem"><p>Dropping all generalization/inheritance arrows and adding all attributes of supertables (<code class="code">personId</code> and <code class="code">name</code>) to their subtables (<code class="code">authors</code> and <code class="code">employees</code>).</p></li></ol></div><div class="figure"><a name="figPersonRoles_TCI"></a><div class="figure-title">Figure&nbsp;13.4.&nbsp;A TCI model of the <code class="code">Person</code> roles class hierarchy</div><div class="figure-contents"><div class="mediaobject"><img src="resources/PersonRoles_TCI-STI.png"></div></div></div><p>In the case of using the JTI approach, in addition to the steps 1-5 above, we would</p><div class="orderedlist"><ol class="orderedlist" start="6" type="1"><li class="listitem"><p>Copy the primary key column (<code class="code">personId</code>) of the root table (<code class="code">people</code>) to all subtables (<code class="code">authors</code> and <code class="code">employees</code>).</p></li><li class="listitem"><p>Replace the generalization arrows with &laquo;fkey&raquo;-stereotyped dependency arrows (representing <span class="italic">foreign key dependencies</span>) that are annotated at their source end with the name of the subtable's primary key (here: <code class="code">personId</code>).</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e5234"></a>3.3.&nbsp;New issues</h3></div></div></div><p>Compared to the model of our first case study, shown in <a class="xref" href="ch13s02.html#figBookClassHierarchyJsM" title="Figure&nbsp;13.1.&nbsp;The JS class model of the merged Book class hierarchy">Figure&nbsp;13.1</a> above, we have to deal with a number of new issues in the <span class="italic">model code</span>: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Defining the subclass relationships between <code class="code">Employee</code> and <code class="code">Person</code>, as well as between <code class="code">Author</code> and <code class="code">Person</code>, using the JS keyword <code class="code">extends</code> discussed in <a class="xref" href="ch13s01.html" title="1.&nbsp;Subtyping with Constructor-Based Classes">Section&nbsp;1</a>.</p></li><li class="listitem"><p>When loading the instances of the root class (<code class="code">Person.instances</code>) from persistent storage (in <code class="code">Person.retrieveAll</code>), we load (1) the records of the table representing the root class (<code class="code">people</code>) for creating its direct instances and (2) also the records of all other tables representing its subclasses (<code class="code">authors</code> and <code class="code">employees</code>) for creating their direct instances, while also adding their object references to the root class population (to <code class="code">Person.instances</code>). In this way, the root class population does not only contain direct instances, but all instances.</p></li><li class="listitem"><p>When saving the instances of <code class="code">Employee</code> and <code class="code">Author</code> as records of the JS entity tables <code class="code">employees</code> and <code class="code">authors</code> to persistent storage in <code class="code">Employee.saveAll</code> and <code class="code">Author.saveAll</code> (invoked in <code class="code">pl.v.employees.manage.exit</code> and <code class="code">pl.v.authors.manage.exit</code>), we also save the direct instances of <code class="code">Person</code> as records of the <code class="code">people</code> table.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e5268"></a>3.4.&nbsp;Code the model classes of the JS class model</h3></div></div></div><p>The JS class model shown in <a class="xref" href="ch13s03.html#figPersonRolesJsM" title="Figure&nbsp;13.2.&nbsp;The JS class model of the Person roles class hierarchy">Figure&nbsp;13.2</a> above can be directly coded for getting the code of the model classes <code class="code">Person</code>, <code class="code">Employee</code> and <code class="code">Author</code> as well as for the enumeration type <code class="code">EmployeeCategoryEL</code>.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e5276"></a>3.4.1.&nbsp;Defining subtype relationships</h4></div></div></div><p>We define the subtype relationships between <code class="code">Employee</code> and <code class="code">Person</code>, as well as between <code class="code">Author</code> and <code class="code">Person</code>, with <code class="code">extends</code>. For instance, in <code class="code">m/Employee.js</code> we define:</p><pre class="programlisting"><span class="bold"><strong>EmployeeCategoryEL</strong></span> =  new Enumeration(["Manager"]);

class <span class="bold"><strong>Employee</strong></span> <span class="bold"><strong>extends</strong></span> <span class="bold"><strong>Person</strong></span> {
  constructor ({personId, name, empNo, category, department}) {
    super({personId, name});
    this.empNo = empNo;
    if (category) this.category = category;
    if (department) this.department = department;
  }
  ...
}</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e5290"></a>3.4.2.&nbsp;Loading the instances of the root class <code class="code">Person</code></h4></div></div></div><p>When retrieving the instances of a class hierarchy's root class (in our example, <code class="code">Person</code>) from a persistent data store organized according to the TCI approach, we have to retrieve not only its direct instances from the table representing the root class (<code class="code">people</code>), but also all indirect instances from all tables representing its subclasses (<code class="code">employees</code> and <code class="code">authors</code>), as shown in the following code:</p><pre class="programlisting">Person.<span class="bold"><strong>retrieveAll</strong></span> = function () {
  var people={}, employees={}, authors={};
  if (!localStorage["authors"]) localStorage["authors"] = "{}";
  if (!localStorage["employees"]) localStorage["employees"] = "{}";
  if (!localStorage["people"]) localStorage["people"] = "{}";
  try {
    people = JSON.parse( localStorage["people"]);
    employees = JSON.parse( localStorage["employees"]);
    authors = JSON.parse( localStorage["authors"]);
  } catch (e) {
    console.log("Error when reading from Local Storage\n" + e);
  }
  for (let key of Object.keys( <span class="bold"><strong>authors</strong></span>)) {
    try {  // convert record to (typed) object
      Author.instances[key] = new Author( authors[key]);
      // create superclass extension
      Person.instances[key] = Author.instances[key];
    } catch (e) {
      console.log(`${e.constructor.name} while deserializing` +
          `author ${key}: ${e.message}`);
    }
  }
  ...
}</pre><p>Each record of the <code class="code">authors</code> table is retrieved and converted to an <code class="code">Author</code> object, a reference to which is copied to <code class="code">Person.instances</code>. Also the records of the <code class="code">employees</code> table are processed in this way, while the records of the <code class="code">people</code> table are simply retrieved and converted to <code class="code">Person</code> objects:</p><pre class="programlisting">Person.<span class="bold"><strong>retrieveAll</strong></span> = function () {
  ...
  for (let key of Object.keys( <span class="bold"><strong>employees</strong></span>)) {
    ...
  }
  for (let key of Object.keys( <span class="bold"><strong>people</strong></span>)) {
    try {  // convert record to (typed) object
      Person.instances[key] = new Person( people[key]);
    } catch (e) {
      console.log(`${e.constructor.name} while deserializing` +
          `author ${key}: ${e.message}`);
    }
  }
}</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e5312"></a>3.4.3.&nbsp;Saving the supertable when saving a subtable</h4></div></div></div><p>Since the app's data is kept in main memory as long as the app is running (which is as long as the app's webpage is kept open in the browser), the data has to be saved to persistent storage when the app is exited (e.g., by closing its browser tab), When saving the instances of <code class="code">Employee</code> and <code class="code">Author</code> (as records of the JS entity tables <code class="code">employees</code> and <code class="code">authors</code>) to persistent storage in <code class="code">pl.v.employees.manage.exit</code> and <code class="code">pl.v.authors.manage.exit</code>, we also save the direct instances of <code class="code">Person</code> (as records of the <code class="code">people</code> table). This is necessary because changes to <code class="code">Employee</code> or <code class="code">Author</code> instances may imply changes of <code class="code">Person.instances</code>.</p><p>For instance, for <code class="code">Employee</code> data management, we define in <code class="code">v/employees.js</code>:</p><pre class="programlisting">pl.v.<span class="bold"><strong>employees</strong></span>.<span class="bold"><strong>manage</strong></span> = {
  ...
  <span class="bold"><strong>exit</strong></span>: function () {
    Employee.saveAll();
    Person.saveAll();
  },
  ...
} </pre></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch13s02.html"><img src="images/prev.svg" alt="Prev"></a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch13.html"><img src="images/up.svg" alt="Up"></a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch13s04.html"><img src="images/next.svg" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">2.&nbsp;Case Study 1: Eliminating a Class Hierarchy&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index-2.html"><img src="images/home.svg" alt="Home"></a></td><td width="40%" align="right" valign="top">&nbsp;4.&nbsp;Quiz Questions</td></tr></table></div></body>
<!-- Mirrored from web-engineering.info/book/WebApp2/ch13s03.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 21 Jul 2023 11:00:22 GMT -->
</html>