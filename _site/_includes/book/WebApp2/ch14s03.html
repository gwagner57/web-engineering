<html>
<!-- Mirrored from web-engineering.info/book/WebApp2/ch14s03.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 21 Jul 2023 11:00:23 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>3.&nbsp;Case Study 2: Implement a Class Hierarchy with Joined Table Inheritance</title><link rel="stylesheet" type="text/css" href="html.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index-2.html" title="Web Applications with JavaScript or Java"><link rel="up" href="ch14.html" title="Chapter&nbsp;14.&nbsp;Subtyping with Java EE"><link rel="prev" href="ch14s02.html" title="2.&nbsp;Case Study 1: Implement a Class Hierarchy with Single Table Inheritance"><link rel="next" href="ch14s04.html" title="4.&nbsp;Run the App"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.&nbsp;Case Study 2: Implement a Class Hierarchy with <span class="italic">Joined Table Inheritance</span></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch14s02.html"><img src="images/prev.svg" alt="Prev"></a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;14.&nbsp;Subtyping with Java EE</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch14s04.html"><img src="images/next.svg" alt="Next"></a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e5647"></a>3.&nbsp;Case Study 2: Implement a Class Hierarchy with <span class="italic">Joined Table Inheritance</span></h2></div></div></div><p>The starting point for our case study is the design model shown in <a class="xref" href="ch12s07.html#figPersonRoles1" title="Figure&nbsp;12.8.&nbsp;An information design model with a Person roles hierarchy">Figure&nbsp;12.8</a> above. In the following sections, we show how to eliminate the <code class="code">Manager</code> class by using the <span class="italic">Class Hierarchy Merge</span> design pattern and how to implement the <code class="code">Person</code> hierarchy and use <span class="italic">Joined, Multiple Table Inheritance</span> storage with the help of JPA framework.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e5656"></a>3.1.&nbsp;Make the Java Entity class model</h3></div></div></div><p>We design the <span class="italic">model classes</span> of our example app with the help of a Java <span class="italic">Entity class model</span><a class="indexterm" name="d5e5661"></a> that we derive from the <span class="italic">design model</span> by essentially leaving the generalization arrows as they are and just adding <span class="italic">getters</span> and <span class="italic">setters</span> to each class. However, in the case of our example app, it is natural to apply the <span class="italic">Class Hierarchy Merge</span> design pattern to the segmentation of <code class="code">Employee</code> for simplifying the data model by eliminating the <code class="code">Manager</code> subclass. This leads to the model shown in <a class="xref" href="ch14s03.html#figPersonRolesJavaM" title="Figure&nbsp;14.2.&nbsp;The Java Entity class model of the Person class hierarchy">Figure&nbsp;14.2</a> below. Notice that we have also made two technical design decisions: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>We have declared the segmentation of <code class="code">Person</code> into <code class="code">Employee</code> and <code class="code">Author</code> to be <span class="italic">disjoint</span> and <span class="italic">complete</span>, that is, any person is either an employee or an author. Since Java does not <span class="italic">support multiple classification</span>, we cannot implement an overlapping segmentation, as needed when modeling roles, with Java.</p></li><li class="listitem"><p>We have turned <code class="code">Person</code> into an <span class="bold"><strong><span class="italic">abstract class</span></strong></span> (indicated by its name written in italics in the class rectangle), which means that it cannot have direct instances, but only indirect ones via its subclasses <code class="code">Employee</code> and <code class="code">Author</code>. This technical design decision is compatible with the fact that any <code class="code">Person</code> is an <code class="code">Employee</code> or an <code class="code">Author</code> (or both), and consequently there is no need for any object to instantiate <code class="code">Person</code> directly.</p></li></ol></div><div class="figure"><a name="figPersonRolesJavaM"></a><div class="figure-title">Figure&nbsp;14.2.&nbsp;The Java Entity class model of the Person class hierarchy</div><div class="figure-contents"><div class="mediaobject"><img src="resources/PersonRoleHierarchy_JavaM.png"></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e5696"></a>3.2.&nbsp;New issues</h3></div></div></div><p>Compared to the model of our first case study, shown in <a class="xref" href="ch14s02.html#figBookClassHierarchyJEE" title="Figure&nbsp;14.1.&nbsp;The Java Entity class model of the Book class hierarchy">Figure&nbsp;14.1</a> above, we have to define the category relationships between <code class="code">Employee</code> and <code class="code">Person</code>, as well as between <code class="code">Author</code> and <code class="code">Person</code>, using the JPA annotation.</p><p>In the <span class="italic">UI code</span> we have to take care of:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Adding the views (in the folders <code class="code">WebContent/views/authors</code> and <code class="code">WebContent/views/employees</code>) and controller classes (<code class="code">AuthorController</code> and <code class="code">EmployeeController</code>) for the corresponding <code class="code">Author</code> and <code class="code">Employee</code> model classes.</p></li><li class="listitem"><p>Deal with the <code class="code">Manager</code> case, by adding a "Special type" select control, in the forms of the "Create book" and "Update book" use cases in <code class="code">WebContent/views/books/create.xhtml</code> and <code class="code">WebContent/views/books/update.xhtml</code>. Segment property form fields (i.e., department in our example) are only displayed, and their validation is performed, when a corresponding employee type has been selected.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e5720"></a>3.3.&nbsp;Code the model classes of the Java Entity class model</h3></div></div></div><p>The Java Entity class model shown in <a class="xref" href="ch14s03.html#figPersonRolesJavaM" title="Figure&nbsp;14.2.&nbsp;The Java Entity class model of the Person class hierarchy">Figure&nbsp;14.2</a> above is coded by using the JavaBeans <code class="code">Person</code>, <code class="code">Employee</code> and <code class="code">Author</code> as well as for the enumeration type <code class="code">EmployeeCategoryEL</code>.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e5728"></a>3.3.1.&nbsp;Define the category relationships</h4></div></div></div><p>We define the category relationships between <code class="code">Employee</code> and <code class="code">Person</code>, as well as between <code class="code">Author</code> and <code class="code">Person</code>, using the JPA annotations. At first we create the <code class="code">Person</code> class as shown below:</p><pre class="programlisting">@Entity @Table(name="persons")
<span class="bold"><strong>@Inheritance(strategy=InheritanceType.JOINED)</strong></span>
@DiscriminatorColumn(name="category", 
    discriminatorType=DiscriminatorType.STRING, length=16)
public abstract class <span class="bold"><strong>Person</strong></span> {
  @Id @NotNull(message="A person ID is required!")
  private Integer <span class="bold"><strong>personId</strong></span>;
  @NotNull(message="A name is required!") @Column(nullable=false)
  private String <span class="bold"><strong>name</strong></span>;
  ...
}</pre><p>Comparing with the <code class="code">Book</code> hierarchy shown in <span class="italic">Test Case 1</span>, the <code class="code">@Inheritance</code> annotations defines now the <code class="code">strategy=InheritanceType.JOINED</code>. This means, for every class in the inheritance hierarchy, a database table is used. The <code class="code">@DiscriminatorColumn(name="category")</code> specifies the column in the corresponding table (i.e., <code class="code">persons</code>) of the top hierarchy class (i.e., <code class="code">Person</code>) which stores the discriminator values used to identify the stored type of each entry (table row).</p><p>Notice that the Java class <code class="code">Person</code> is declared as being <code class="code">abstract</code>, which means it can't be initialized, instead we can and we initialize subclasses derived from it (i.e., <code class="code">Employee</code> and <code class="code">Author</code>). This also mean that we don't declare a <code class="code">@DiscriminatorValue</code> because no direct instance of <code class="code">Person</code> is stored in the database table.</p><p>Further, we define the <code class="code">Author</code> class as follows: </p><pre class="programlisting">@Entity @Table(name="authors")
<span class="bold"><strong>@DiscriminatorValue( value="AUTHOR")</strong></span>
@ManagedBean(name="author") @ViewScoped
public class <span class="bold"><strong>Author</strong></span> extends Person {
  @NotNull(message="A biography is required!")
  private String <span class="bold"><strong>biography</strong></span>;
  ...
}</pre><p>The <code class="code">Author</code> class inherits <code class="code">Person</code>, therefore the get and set methods corresponding to <code class="code">personId</code> and <code class="code">name</code> properties are available. The <code class="code">@DiscriminatorValue(value="AUTHOR")</code> specifies that the column category of the <code class="code">persons</code> table stores the value <code class="code">AUTHOR</code> for every entry which comes from persisting an <code class="code">Author</code> instance.</p><p>Finally, we define the <code class="code">Employee</code> class:</p><pre class="programlisting">@Entity @Table(name="employees")
@DiscriminatorValue(value="EMPLOYEE")
@ManagedBean(name="employee") @ViewScoped
public class <span class="bold"><strong>Employee</strong></span> extends Person {
  @Column( nullable=false)
  @NotNull( message="An employee ID is required!")
  private Integer <span class="bold"><strong>empNo</strong></span>;
  @Column( nullable=false, length=32)
  @Enumerated( EnumType.STRING)
  private <span class="bold"><strong>EmployeeCategoryEL type</strong></span>;
  @Column( nullable=true, length=64)
  private String department;
  ...
}</pre><p>Notice the <code class="code">type</code> property used to identify the <code class="code">Employee</code> type, such as <code class="code">Manager</code>. Its values are defined by the <code class="code">EmployeeCategoryEL</code> enumeration.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e5782"></a>3.3.2.&nbsp;Database schema for joined table class hierarchy</h4></div></div></div><p>As a result of the annotation </p><pre class="programlisting">@Inheritance( strategy = InheritanceType.JOINED)</pre><p>for each class in the inheritance hierarchy, one database table is created. The corresponding simplified SQL-DDL scripts used by JPA to create the <code class="code">persons</code>, <code class="code">authors</code> and <code class="code">employees</code> tables are shown below: </p><pre class="programlisting">CREATE TABLE IF NOT EXISTS `persons` (
  `PERSONID` int(11) NOT NULL,
  `category` varchar(16) DEFAULT NULL,
  `NAME` varchar(255) NOT NULL
);
CREATE TABLE IF NOT EXISTS `authors` (
  `PERSONID` int(11) NOT NULL,
  `BIOGRAPHY` varchar(255) DEFAULT NULL
);
ADD CONSTRAINT `FK_authors_PERSONID` FOREIGN KEY (`PERSONID`) 
    REFERENCES `persons` (`PERSONID`);
CREATE TABLE IF NOT EXISTS `employees` (
  `PERSONID` int(11) NOT NULL,
  `DEPARTMENT` varchar(64) DEFAULT NULL,
  `EMPNO` int(11) NOT NULL,
  `TYPE` varchar(32) DEFAULT NULL
);
ADD CONSTRAINT `FK_employees_PERSONID` FOREIGN KEY (`PERSONID`) 
  REFERENCES `persons` (`PERSONID`);</pre><p>As we can see, every table contains the direct properties as defined by the corresponding Java bean class. Additionally, the <code class="code">authors</code> and <code class="code">employees</code> tables are created with a foreign key constraing for the <code class="code">PERSONID</code> column refering to to the <code class="code">PERSONID</code> column from the <code class="code">persons</code> table.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e5796"></a>3.4.&nbsp;Write the View and Controller Code</h3></div></div></div><p>In the user interface, for every Java bean class, we have a controller class which contains the <code class="code">create</code>, <code class="code">update</code> and <code class="code">delete</code> CRUD methods. The <code class="code">PersonController</code> class is defined as abstract and contains the <code class="code">checkPersonIdAsId</code> method, which is common to all subclasses. The <code class="code">AuthorController</code> and <code class="code">EmployeeController</code> inherits the <code class="code">PersonController</code>.</p><p>For every non-abstract entity class in the inheritance hierarchy we define a set of views corresponding to CRUD operations. For example, in the case of <code class="code">Author</code> we have the files <code class="filename">retrieveAndListAll.xhtml</code>, <code class="filename">create.xhtml</code>, <code class="filename">update.xhtml</code>, and <code class="filename">delete.xhtml</code> in the folder <code class="filename">WebContent/views/authors/</code>. In the case of <code class="code">Employee</code>, the <span class="italic">Retrieve/List All Employees</span> use case requires to display the <span class="italic">Special type of employee</span> column:</p><pre class="programlisting">&lt;h:column&gt;
  &lt;f:facet name="header"&gt;Special type of employee&lt;/f:facet&gt;
  #{e.type != null ? e.type.label.concat(" of ").concat( 
                       e.department).concat(" department") : ""}
&lt;/h:column&gt;</pre><p>Notice that within EL expressions we cannot use the + (plus) operator for concatenating strings. EL allows the <code class="code">+</code> operator to be used only for numeric addition. However, we can use the <code class="code">concat</code> method instead.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch14s02.html"><img src="images/prev.svg" alt="Prev"></a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch14.html"><img src="images/up.svg" alt="Up"></a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch14s04.html"><img src="images/next.svg" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">2.&nbsp;Case Study 1: Implement a Class Hierarchy with <span class="italic">Single Table Inheritance</span>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index-2.html"><img src="images/home.svg" alt="Home"></a></td><td width="40%" align="right" valign="top">&nbsp;4.&nbsp;Run the App</td></tr></table></div></body>
<!-- Mirrored from web-engineering.info/book/WebApp2/ch14s03.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 21 Jul 2023 11:00:24 GMT -->
</html>