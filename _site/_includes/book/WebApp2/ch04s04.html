<html>
<!-- Mirrored from web-engineering.info/book/WebApp2/ch04s04.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 21 Jul 2023 11:00:11 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>4.&nbsp;Write the Model Code</title><link rel="stylesheet" type="text/css" href="html.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index-2.html" title="Web Applications with JavaScript or Java"><link rel="up" href="ch04.html" title="Chapter&nbsp;4.&nbsp;Implementing Unidirectional Functional Associations with Java EE"><link rel="prev" href="ch04s03.html" title="3.&nbsp;New Issues"><link rel="next" href="ch04s05.html" title="5.&nbsp;The View and Controller Layers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4.&nbsp;Write the Model Code</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s03.html"><img src="images/prev.svg" alt="Prev"></a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;4.&nbsp;Implementing Unidirectional Functional Associations with Java EE</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch04s05.html"><img src="images/next.svg" alt="Next"></a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e1861"></a>4.&nbsp;Write the Model Code</h2></div></div></div><p>The Java Entity class model can be directly coded for getting the model layer code of our Java back-end app.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1864"></a>4.1.&nbsp;Summary</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Code each class from the Java Entity class model as a corresponding entity class.</p></li><li class="listitem"><p>Code an {id} property modifier with the JPA annotation <code class="code">@Id</code></p></li><li class="listitem"><p>Code any property modifier denoting the functionality type of a reference property, such as {manyToOne}, with the corresponding JPA annotation, such as <code class="code">@ManyToOne</code>.</p></li><li class="listitem"><p>Code the integrity constraints specified in the model with the help of Java Bean Validation annotations (or custom validation annotations).</p></li><li class="listitem"><p>Code the getters and setters.</p></li><li class="listitem"><p>Code the <code class="code">create</code>, <code class="code">retrieve</code>, <code class="code">update</code> and <code class="code">delete</code> storage management operations as class-level methods.</p></li></ol></div><p>These steps are discussed in more detail in the following sections.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1886"></a>4.2.&nbsp;Code each class of the Entity class model</h3></div></div></div><p>Each class <code class="code">C</code> of the Java Entity class model<a class="indexterm" name="d5e1890"></a> is coded as an annotated bean class with name <code class="code">C</code> having a default constructor (with no parameters) and a constructor with entity creation parameters.</p><p>For instance, the <code class="code">Book</code> class from the Entity class model is coded in the following way:</p><pre class="programlisting">@Entity @Table( name="books")
@ViewScoped @ManagedBean( name="book")
public class <span class="bold"><strong>Book</strong></span> {
  @Id @NotNull( message="An ISBN is required!")
  private String <span class="bold"><strong>isbn</strong></span>;
  @Column( nullable=false)
  @NotNull( message="A title is required!")
  private String <span class="bold"><strong>title</strong></span>;
  @Column( nullable=false)
  @NotNull( message="A year is required!")
  private Integer <span class="bold"><strong>year</strong></span>;
  <span class="bold"><strong>@ManyToOne</strong></span>( fetch=FetchType.EAGER)
  private Publisher <span class="bold"><strong>publisher</strong></span>;

  public Book() {}
  public Book( String isbn, String title, 
      Integer year, Publisher publisher) {
    this.setIsbn( isbn);
    this.setTitle( title);
    this.setYear( year);
    this.setPublisher( publisher);
  }
  ...  // getters, setters, etc.
}</pre><p>The <code class="code">@ManyToOne</code> annotation on the property <code class="code">publisher</code> is used for specifying the functionality type of the association <span class="italic">Book has Publisher</span> represented by the reference property <code class="code">publisher</code> since it holds that <span class="italic">a book has one publisher</span> and <span class="italic">a publisher has many books</span>. This annotation also allows to specify a <span class="italic">fetch type</span><a class="indexterm" name="d5e1910"></a> with the parameter <code class="code">fetch</code> taking one of the following two possible values:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">FetchType.EAGER</code>, implying that a retrieval of an entity includes a retrieval of the associated entity referenced by the entity with this property. In our example, this means that when a <code class="code">Book</code> entity is retrieved, the <code class="code">Publisher</code> entity referenced by the book's <code class="code">publisher</code> property is also retrieved. This behavior is very useful and it should be used whenever the data to be retrieved can be handled in main memory.</p></li><li class="listitem"><p><code class="code">FetchType.LAZY</code>, implying that referenced entities are not automatically retrieved when a referencing entity is retrieved. In our example, this means that the referenced <code class="code">Publisher</code> entity is not retrieved together with a referencing <code class="code">Book</code> entity, leaving the value of the <code class="code">publisher</code> property set to <code class="code">null</code>. With this fetching behavior, a referenced entity has to be retrieved separately by invoking the reference property's getter in the context of a transaction (in our example by invoking <code class="code">getPublisher</code>).</p></li></ul></div><p>In the case of a <span class="italic">single-valued</span> reference property (representing a <span class="italic">functional</span> association) annotated with either <code class="code">@OneToOne</code> or <code class="code">@ManyToOne</code>, the default value is <code class="code">FetchType.EAGER</code>, so referenced entities are fetched together with referencing entities, while in the case of a <span class="italic">non-functional</span> association (with either <code class="code">@OneToMany</code> or <code class="code">@ManyToMany</code>), the default value is <code class="code">FetchType.LAZY</code>, so referenced entities are not fetched together with referencing entities, but have to be retrieved separately, if needed.</p><p>As a result of these JPA annotations, the following SQL table creation statement for creating the <code class="code">books</code> table is generated:</p><pre class="programlisting">CREATE TABLE IF NOT EXISTS `<span class="bold"><strong>books</strong></span>` (
  `ISBN` varchar(10) NOT NULL,
  `TITLE` varchar(255) NOT NULL,
  `YEAR` int(11) NOT NULL,
  `PUBLISHER_NAME` varchar(255) DEFAULT NULL 
      FOREIGN  KEY (`PUBLISHER_NAME`) REFERENCES `publishers` (`NAME`)
);</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1942"></a>4.3.&nbsp;Code the constraints</h3></div></div></div><p>Take care that all property constraints specified in the entity class model are properly coded by using suitable Bean Validation annotations, as explained in <span class="phrase">Part 2</span>. For instance, for the <code class="code">name</code> attribute, we have to use the JPA annotation <code class="code">@Id</code> for specifying that the attribute corresponds to the primary key column of the database table to which the entity class is mapped, and the Bean Validation annotation <code class="code">@NotNull</code> for defining a mandatory value constraint that is checked before an entity is saved to the database.</p><p>In the case of the <code class="code">address</code> attribute, we have to define a mandatory value constraint in two forms: with the JPA annotation <code class="code">@Column( nullable=false)</code> for the corresponding table column, and with the Bean Validation annotation <code class="code">@NotNull</code> for the attribute.</p><pre class="programlisting">@Id @NotNull( message="A name is required!")
private String <span class="bold"><strong>name</strong></span>;

@Column( nullable=false)
@NotNull( message="An address is required!")
private String <span class="bold"><strong>address</strong></span>;</pre><p><span class="bold"><strong><span class="italic">Notice that, unfortunately, the current Java EE technology requires defining the same constraint twice, once for the database in the form of a JPA annotation, and once for the Java app in the form of a Bean Validation annotation.</span></strong></span></p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1959"></a>4.4.&nbsp;Code getters and setters</h3></div></div></div><p>Code the setter operations as (instance-level) methods. The setters only assign values and do not perform any validation, since the property constraints are only checked before save by the Java EE execution environment. The getters simply return the actual values of properties.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1962"></a>4.5.&nbsp;Implement a deletion policy</h3></div></div></div><p>For any reference property, we have to choose and implement a deletion policy for taking care of the corresponding object destruction dependency in the <code class="code">delete</code> method of the reference property's range class. In our case, we have to choose between </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>deleting all books published by the deleted publisher;</p></li><li class="listitem"><p>dropping from all books published by the deleted publisher the reference to the deleted publisher.</p></li></ol></div><p>We choose the second policy, which can only be used inf the case of an optional reference property such as <code class="code">book.publisher</code>. This is shown in the following code of the <code class="code">Publisher.delete</code> method where for all <code class="code">book</code> entities concerned the property <code class="code">book.publisher</code> is cleared:</p><pre class="programlisting">public static void <span class="bold"><strong>delete</strong></span>( EntityManager em, UserTransaction ut, 
    String name) throw Exception {
  ut.begin();
  Publisher publisher = em.find( Publisher.class, name);
  // find all Books which have this publisher
  Query query = em.createQuery( 
      "SELECT b FROM Book b WHERE b.publisher.name = :name");
  query.setParameter( "name", name);
  List&lt;Book&gt; books = query.getResultList();
  // clear these books' publisher reference
  <span class="bold"><strong>for ( Book b: books) { b.setPublisher( null);}</strong></span>
  em.remove( publisher);
  ut.commit();
}</pre><p>The method loops through all <code class="code">Book</code> entities referencing the publisher to be destroyed and sets their <code class="code">publisher</code> property to <code class="code">null</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1983"></a>4.6.&nbsp;Serialization and De-Serialization</h3></div></div></div><p>Based on JPA annotations, together with suitable converter classes when needed, serialization (from Java objects to table rows) as well as the corresponding de-serialization (from table columns to Java objects) are performed automatically.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s03.html"><img src="images/prev.svg" alt="Prev"></a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch04.html"><img src="images/up.svg" alt="Up"></a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch04s05.html"><img src="images/next.svg" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">3.&nbsp;New Issues&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index-2.html"><img src="images/home.svg" alt="Home"></a></td><td width="40%" align="right" valign="top">&nbsp;5.&nbsp;The View and Controller Layers</td></tr></table></div></body>
<!-- Mirrored from web-engineering.info/book/WebApp2/ch04s04.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 21 Jul 2023 11:00:11 GMT -->
</html>