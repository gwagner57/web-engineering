<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="role-ebook-page" lang="de">
<!-- Mirrored from web-engineering.info/book/InformationManagement/Constraints.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 21 Jul 2023 11:02:29 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head><meta charset="UTF-8" /><title>7.2. Integrity Constraints</title><link href="_res/pageNavigation.css" rel="stylesheet" type="text/css" /><link href="_res/ebook.css" rel="stylesheet" type="text/css" /><link href="_res/icons/index.html" type="inode/directory" /></head><body><header class="page-navigation"><table><tr><td class="page-navigation-to-first"><a href="InformationManagement.html"><span class="page-navigation-to-first-icon" title="Erste Seite
Information Management"></span></a></td><td class="page-navigation-to-previous"><a href="TablesAttributes.html"><span class="page-navigation-to-previous-icon" title="Vorherige Seite
7.1. Basic Concepts"></span></a></td><td class="page-navigation-previous"><span>7.1. Basic Concepts</span></td><td class="page-navigation-current"><span>7.2. Integrity Constraints</span> <span class="page-navigation-current-page">(35 / 42)</span></td><td class="page-navigation-next"><span>7.3. Inserting, Updating and Deleting Records</span></td><td class="page-navigation-to-next"><a href="DataManipulation.html"><span class="page-navigation-to-next-icon" title="Nächste Seite
7.3. Inserting, Updating and Deleting Records"></span></a></td><td class="page-navigation-to-last"><a href="_index.html"><span class="page-navigation-to-last-icon" title="Letzte Seite
Index"></span></a></td></tr></table></header><main><section class="role-section1" id="Constraints"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">7.2</span>. </span>Integrity Constraints</h2><p>TO BE TRANSLATED...</p><p>Die einfachste Art von Integritätsbedingungen sind <i>Attributbeschränkungen</i>. Wenn sie im Kontext eines Attributs definiert sind, legen sie die zulässigen Werte für dieses Attribut fest. </p><section><h4>Obligatorische Werte</h4><p>In einer SQL-Tabellendefinition kann die Integritätsbedingung <em>obligatorische Werte</em> für ein Attribut mit Hilfe der Angabe <code>NOT NULL</code> vereinbart werden. Beispielsweise wird in folgender Tabellendefinition das Attribut <code>title</code> als obligatorisch deklariert:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">CREATE TABLE books {
  isbn    TEXT(10) PRIMARY KEY,
  title   TEXT(80) <b>NOT NULL</b>
  edition INTEGER
}</pre></td></tr></tbody></table><p>Da ein Primärschlüssel immer obligatorisch ist, gibt es in dieser Tabellendefinition zwei obligatorische Attribute (<code>isbn</code> und <code>title</code>) sowie ein optionales Attribut (<code>edition</code>).</p></section><section><h4>Schlüssel</h4><p>Eine wichtige Art von Attributbeschränkung sind <em>Eindeutigkeitsbeschränkungen</em> bzw. <em>Schlüsseldefinitionen</em>, die verlangen, dass es nicht mehr als eine Tabellenzeile mit einem bestimmten Wert für das Schlüsselattribut (bzw. die Schlüsselattribute) geben darf. </p><p>Im vorhergehenden Abschnitt wurde bereits erklärt, dass jede Entitätstabelle mindestens einen Schlüssel haben sollte, der in einer SQL-Tabellendefinition mit <code>PRIMARY KEY</code> als Primärschlüssel deklariert wird. Wenn es weitere Schlüssel gibt, werden sie mit UNIQUE ausgezeichnet, wie in folgendem Beispiel, wo es außer dem (Primär-)Schlüssel <code>isbn</code> für Entitäten vom Typ <i>books</i> noch einen zweiten Schlüssel <code>doi</code> gibt, der einen <i>Digital Object Identifier (DOI)</i> repräsentiert:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">CREATE TABLE books {
  isbn    TEXT(10) PRIMARY KEY,
  title   TEXT(80) <b>NOT NULL</b>,
  doi     TEXT(50) <b>UNIQUE</b>,
  edition INTEGER
}</pre></td></tr></tbody></table><p>Es ist zu beachten, dass ein Primärschlüssel-Attribut, wie <code>isbn</code>, nicht nur <em>eindeutig</em>, sondern auch <em>obligatorisch</em> ist, also für jede Tabellenzeile einen eindeutigen Wert haben muss. Beide Integritätsbedingungen, <em>eindeutige Werte</em> und <em>obligatorische Werte</em>, werden durch die SQL-Angabe <code>PRIMARY KEY</code> impliziert. Dies ist bei einfachen, mit <code>UNIQUE</code> definierten Schlüsseln nicht der Fall: sie können auch <em>optional</em> sein, also zulassen, dass es Tabellenzeilen ohne Wert gibt, wie es z.B. bei dem Attribut <code>doi</code> der Tabelle <i>books</i> der Fall ist.</p><p>Ein Schlüssel kann auch aus mehreren Attributen zusammengesetzt sein. Zum Beispiel wird in folgendem Tabellenschema ein aus den Attributen <code>isbn</code> und <code>lending_date</code> zusammengesetzter Primärschlüssel definiert:</p><div class="informalfigure"><b><i>book_lendings</i></b> = ⟨ <u>isbn</u>, person_id, <u>lending_date</u>, return_date⟩<p>Ein zusammengesetzter Schlüssel muss eine <em>minimale</em> Menge von Attributen sein, deren Wertekombination eindeutig ist. Deswegen ist z.B. die Attributmenge <code>isbn</code>, <code>person_id</code>, <code>lending_date</code>, obwohl eindeutig, kein Schlüssel.</p></div></section><section><h4>Fremdschlüssel und Referentielle Integrität</h4><p>Tabellenzeilen einer Tabelle B können in einer Tabelle A mit Hilfe eines Attributs referenziert werden, das Werte für den Primärschlüssel von B enthält. Ein solches Attribut ist ein <em>Fremdschlüssel</em>-Attribut, das in SQL mit Hilfe der Angabe <code>REFERENCES </code>vereinbart wird, wie in folgender Tabellendefinition zu sehen ist, in der die Tabelle <i>books</i> Zeilen der Tabelle <i>publishers</i> referenziert (nämlich für jeden <i>books</i>-Datensatz den zugehörigen <i>publishers</i>-Datensatz).</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">CREATE TABLE books {
  isbn      TEXT(10) PRIMARY KEY,
  title     TEXT(80) NOT NULL,
  publisher TEXT(30) <b>REFERENCES</b> <b>publishers</b>
}
CREATE TABLE <b>publishers</b> {
  name      TEXT(20) PRIMARY KEY,
  address   TEXT(80) NOT NULL
}</pre></td></tr></tbody></table><p>Wenn ein Fremdschlüssel sich auf einen zusammengesetzten Schlüssel bezieht, kann er nicht in einer Spaltendefinition, sondern muss in einer separaten FOREIGN-KEY-Klausel deklariert werden.</p><p>Der Begriff <em>Referentielle Integrität</em> drückt aus, dass es für jeden Fremdschlüsselwert einen korrespondierenden Schlüsselwert in der referenzierten Tabelle geben muss. Ein SQL-DBMS überprüft automatisch für alle Fremdschlüssel die Referentielle Integrität. Das impliziert, dass man z.B. keinen neuen Datensatz in die Tabelle <i>books</i> einfügen kann, wenn nicht zuvor ein entsprechender <i>publishers</i>-Datensatz angelegt wurde.</p><p>Fremdschlüssel repräsentieren Abhängigkeitsbeziehungen zwischen Tabellen (<em>Fremdschlüssel-Abhängigkeiten</em>), die In MS Access als Tabellen-<em>Beziehungen</em> definiert und visualisiert werden können. Dazu öffnet man ein Registerblatt <em>Beziehungen</em>, indem man in [Datenbanktools] auf die Option <em>Beziehungen</em> klickt. Dann fügt man beide Tabellen, <i>books</i> und <i>publishers</i>, hinzu und definiert die Fremdschlüssel-Abhängigkeit zwischen dem Attribut <i>books.publisher</i> und der Tabelle <i>publishers</i>, indem man das Attribut mit der Maus auswählt und auf das Primärschlüsselattribut <i>name</i> der Tabelle <i>publishers</i> zieht. Dadurch entsteht eine Verbindungslinie, die von MS Access automatisch mit dem Beziehungs-Funktionalitätstyp <em>many-to-one</em> versehen wird, indem das Linienende bei <i>books</i> mit dem Symbol ∞ und bei <i>publishers</i> mit 1 annotiert wird, wie in <a class="role-figure-ref" href="#Constraints__figAccessRelationship"><span class="role-label">Abbildung <span class="role-number">7-1</span></span></a> zu sehen.</p><figure id="Constraints__figAccessRelationship"><figcaption><span class="role-label">Abbildung <span class="role-number">7-1</span>. </span>In MS Access repräsentiert eine Beziehung zwischen zwei Tabellen eine Fremdschlüssel-Abhängigkeit</figcaption><div><img alt="???" src="_res/Access-Relation-books-publishers.png" /></div></figure></section><section><h4>Zusammenfassung</h4><p>Die folgende Tabelle führt die wichtigsten Tabellen-Integritätsbedingungen auf.</p><table border="1"><tbody><tr><th>Integritätsbedingung</th><th>SQL</th></tr><tr><td>Obligatorische Werte</td><td>NOT NULL</td></tr><tr><td>Eindeutigkeitsbeschränkung / Schlüssel / Kennung</td><td>UNIQUE</td></tr><tr><td>Primärschlüssel / Standard-Kennung (ein Schlüssel mit obligatorischen Werten)</td><td>PRIMARY KEY</td></tr><tr><td>Fremdschlüssel</td><td>REFERENCES &lt;table&gt;</td></tr></tbody></table></section></section></main><footer class="page-navigation"><table><tr><td class="page-navigation-to-first"><a href="InformationManagement.html"><span class="page-navigation-to-first-icon" title="Erste Seite
Information Management"></span></a></td><td class="page-navigation-to-previous"><a href="TablesAttributes.html"><span class="page-navigation-to-previous-icon" title="Vorherige Seite
7.1. Basic Concepts"></span></a></td><td class="page-navigation-previous"><span>7.1. Basic Concepts</span></td><td class="page-navigation-current"><span>7.2. Integrity Constraints</span> <span class="page-navigation-current-page">(35 / 42)</span></td><td class="page-navigation-next"><span>7.3. Inserting, Updating and Deleting Records</span></td><td class="page-navigation-to-next"><a href="DataManipulation.html"><span class="page-navigation-to-next-icon" title="Nächste Seite
7.3. Inserting, Updating and Deleting Records"></span></a></td><td class="page-navigation-to-last"><a href="_index.html"><span class="page-navigation-to-last-icon" title="Letzte Seite
Index"></span></a></td></tr></table></footer></body>
<!-- Mirrored from web-engineering.info/book/InformationManagement/Constraints.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 21 Jul 2023 11:02:29 GMT -->
</html>