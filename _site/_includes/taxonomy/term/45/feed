<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xml:base="https://web-engineering.info"  xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel>
 <title>web-engineering.info - Sensor</title>
 <link>https://web-engineering.info/taxonomy/term/45</link>
 <description></description>
 <language>en</language>
<item>
 <title>WoT with Arduino for Beginners: Part 3 - Connecting to the Internet via WiFi</title>
 <link>https://web-engineering.info/node/62</link>
 <description>&lt;div class=&quot;field field-name-body field-type-text-with-summary field-label-hidden view-mode-rss&quot;&gt;&lt;div class=&quot;field-items&quot;&gt;&lt;div class=&quot;field-item even&quot; property=&quot;content:encoded&quot;&gt;&lt;p&gt;In this multi-part tutorial we show how to develop Arduino-based apps for the Web of Things (WoT). This third part shows how to set up a connection between an Arduino and the Internet via a WiFi network and use HTTP(S) to send data to a free cloud service like &lt;a href=&quot;https://thingspeak.com&quot;&gt;ThingSpeak&lt;/a&gt;. In the following parts of this tutorial, which will appear every 1-3 weeks, we discuss how to control actuators and connect them all together in a Web of Things (WoT) app. Using standard Web technologies, such as HTTP and Web Sockets, we can then access the data or provide commands to the WoT nodes. As a newbie, it is helpful if you already have some familiarity with C/C++ programming and Web technologies, such as HTML and JavaScript.&lt;/p&gt;

&lt;p&gt;You may first want tor read the previous parts of this tutorial series:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://web-engineering.info/node/60&quot;&gt;Part 1: Mastering the RGB LED&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://web-engineering.info/node/61&quot;&gt;Part 2: Connecting to the Real World via Sensors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This tutorial is part of our &lt;a href=&quot;http://web-engineering.info/WoTProjects&quot;&gt;learning materials&lt;/a&gt; on the Web of Things published on &lt;a href=&quot;http://web-engineering.info/&quot;&gt;web-engineeering.info&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;small&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; working with electricity is dangerous. For this project we&#039;ll use 5V, which is safe for the human body under any environment conditions. However, the low voltage may be obtained from a mains connected power brick, and therefore we highly recommend you to take safety precautions and to use a trustful brand for the power supply. We cannot be held responsible for any caused damage! Do it at your own risk and/or ask help from an electronics engineer. In case you are using the USB connector from your PC to power the Arduino board, be aware that short-circuits which may occur on the Arduino board may also have a negative impact on your PC!&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;&lt;strong&gt;Credits:&lt;/strong&gt; some of the images from this tutorial are created by using &lt;a href=&quot;http://fritzing.org/home/&quot;&gt;Fritzing&lt;/a&gt;, a nice electronics modeling tool for beginners.&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;button&gt;Download the Source Code for this project&lt;/button&gt;&lt;/p&gt;

&lt;h2&gt;Arduino + ESP8266 = &quot;I&#039;m online, Mum!&quot;&lt;/h2&gt;

&lt;p&gt;After we&#039;ve managed to read data from the environment using sensors, we want to store the data for later use, such as statistical analysis or visualization. It would also be nice to if we could watch what&#039;s going on at the monitored site even when we are not around, by going to a website that provides access to the (current and historical) sensor data.&lt;/p&gt;

&lt;p&gt;An Arduino can be connected to a network, and thus to the Internet, by using various networking modules, e.g., standard WiFi, wired Ethernet or Bluetooth, see &lt;a href=&quot;#fig1&quot;&gt;Figure 1&lt;/a&gt;. Other custom solutions are also available, such as for example RF modules that communicate in the 315MHz-2.4GHz frequency range. However, such modules do not use the standard WiFi protocols, therefore you can&#039;t use them for directly connecting your Arduino to the Internet by simply using your WiFi router or repeater.&lt;/p&gt;

&lt;figure id=&quot;fig1&quot;&gt;&lt;img alt=&quot;Network Connection Modules for Arduino&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/network-modules.png&quot; /&gt;
&lt;figcaption&gt;Figure 1: Network Connection Modules for Arduino.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;A simple solution for having an Arduino connected to a WiFi network, and thus to the Internet, is to use an ESP8266 module. These modules are now widely available, with prices in the range of 2-8 EUR, including postage to the EU. Such a module is what we are going to use in this tutorial, and we intend to provide you with a guide on how to chose one, since multiple variants are available, how to update its firmware, since new versions are available almost every month, and how to use it to transmit and receive data by using standard Web technologies, such as HTTP(S).&lt;/p&gt;

&lt;h3&gt;Choosing an ESP8266 Module Version&lt;/h3&gt;

&lt;p&gt;Multiple versions of the ESP8266 WiFi module are available, we are aware about 12 of them, as shown in &lt;a href=&quot;#fig2&quot;&gt;Figure 2&lt;/a&gt;.&lt;/p&gt;

&lt;figure id=&quot;fig2&quot;&gt;&lt;img alt=&quot;Variants of the ESP8266 WiFi Module&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/esp8266-variants.png&quot; /&gt;
&lt;figcaption&gt;Figure 2: Variants of the ESP8266 WiFi Module.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;These modules use the 802.11b/g/n standard, operating at 2.4 GHz. This means, we can connect to a standard WiFi network, such as the one most of us have at home, provided by an WiFi router or access point (AP).&lt;/p&gt;

&lt;p&gt;Having multiple variants of ESP8266 module, comes the question: &quot;which one should I use ?&quot;. There is no perfect answer for this question, and it highly depends on what you are using the WiFi module for. These modules are not only a &quot;blind&quot; WiFi communication module, but are based on a MCU, which can be programmed and which have I/O pins, therefore it can do tasks similar with the ones available for the Arduino boards. Even more, the Arduino IDE supports ESP8266 programming, but details about this topic we&#039;ll discus in another tutorial. Regarding our question, there are three main reasons to consider when choosing an ESP8266 module:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;&lt;strong&gt;usability on a breadboard:&lt;/strong&gt; most of the times we prototype on a breadboard, therefore we should be able to connect these modules to such a board. Some of the modules, such as ESP02, ESP03 and ESP05 (see &lt;a href=&quot;#fig2&quot;&gt;Figure 2&lt;/a&gt;) are breadboard friendly, having a pitch of 2.54mm (the distance between two pins). Other modules, such as ESP07 or ESP08 have a pitch of 1.27mm, thus you&#039;ll only be able to use them with a breadboard when using an adapter. Last, other modules, such as ESP01 have a pitch of 2.54mm, but they have a two-row header, which makes it impossible to use it with a breadboard, because the implied short-circuit between the pins. Notice that some of the breadboard friendly modules have only a half-way pin connections, see ESP02 module from &lt;a href=&quot;#fig2&quot;&gt;Figure 2&lt;/a&gt;. Such connections are somehow harder to solder, specially for a beginner. Our tip: plug the pin headers into a breadboard, align the module on top of them, then solder.&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;flash memory size:&lt;/strong&gt; this is very important to consider when choosing an ESP8266 module, because they come with permanent flash memory, which is usually in the range of 4MBit (512KB) up to 16MBit (2MB), but can go up to 128MBit (16MB). &lt;em&gt;&lt;strong&gt;Starting with the firmware version 1.1.0 (released on June 2015), you&#039;ll need a module with at least 8MBit (1MB) flash size to burn the new firmware&lt;/strong&gt;&lt;/em&gt;. Thus, pay attention when buy the module and be sure that you get one that has at least 8Mbit (1MB) flash size. In term of RAM and MCU frequency, they are mostly the same, so no need to worry about it. There are ways to improve the flash capacity, but for this you&#039;ll need good soldering skills to remove the old flash IC and solder the new one, and usually the price of the flash IC bought in small quantities is more than half of the ESP8266 module price, thus defeating the purpose. Excepting for the ESP06, ESP07, ESP08 and ESP12 modules, which have a metallic (hard to remove) cover over the CPU and flash IC, you can simply detect the flash size by reading the text on the 8 pin black IC soldered near the MCU (which is the square black IC with pins on all four sides). If the number on the flash IC starts with 25Q80 then you have a 8MBit sized one, while if it starts with 25Q40 then you have a 4MBit sized one.&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;MCU features:&lt;/strong&gt; these modules are driven by a low power 32-bit RISC CPU (Tensilica Xtensa LX106) running at 80 MHz. It has 64 KB of instruction RAM, 96 KB of data RAM and supports external QSPI flash - 512 KB to 4 MB (up to 16MB is supported). I has 16 I/O pins, from which one has 10Bit ADC capabilities, and supports I2C, I2S, SPI and UART communication protocols. All these features are quite important if you are using the ESP8266 module as standalone controller board. However, if the ESP8266 module is used as WiFi interface only, then you&#039;ll not need these features, and you can chose the cheapest and board with suits your needs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Based on the above considerations, we chose to use ESP02 module, because it is small, breadboard friendly (even if is not very easy to solder the pin header) and it has a connector for a 2.4GHz WiFi antenna, thus allowing for a good WiFi range, even when used indoors.&lt;/p&gt;

&lt;h3&gt;Update the ESP8266 Firmware&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; perform the tasks shown on this section on your own risk. If something goes wrong, it may be possible to have a &quot;bricked&quot; module, which can&#039;t be used anymore or requires special tools to repair.&lt;/p&gt;

&lt;p&gt;Normally, after buying an ESP8266 module, the first task is to ensure that it has the latest firmware, thus being able to use the latest features and having fixed various software related problems. But how do we know if the last firmware is burned into our ESP8266 module? To answer this question we need to connect the module to a computer by using a TTL module and a software, which allows us to communicate with the module and perform queries or provide commands. A TTL module (e.g. see &lt;a href=&quot;#fig3&quot;&gt;Figure 3&lt;/a&gt;), see is a communication device that connects to an USB port of the computer and allows to map Serial protocol via the USB port. Its TX and RX pins connects to the RX and respective TX pins of the ESP8266 module (pay attention, the pins connection is twisted!). Such modules are quite cheap, having an approximate cost of about 2-3 EUR postage included in EU.&lt;/p&gt;

&lt;figure id=&quot;fig3&quot;&gt;&lt;img alt=&quot;USB-TTL UART Module&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/usb-ttl-module.png&quot; /&gt;
&lt;figcaption&gt;Figure 3: USB-TTL UART Module.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;In &lt;a href=&quot;#fig4&quot;&gt;Figure 4&lt;/a&gt; and &lt;a href=&quot;#fig5&quot;&gt;Figure 5&lt;/a&gt; are shown the breadboard connection and the schematics of the circuit which allows us to have the ESP02 module communicating with a computer by using the serial port (UART communcation). A breadboard friendly power supply is used to provide the required 3.3V for the ESP8266 module. This specific one allows inputs in the range 5-12V and produce a steady 3.3V or 5V (a switch allows the selection) output, with a maximum current of 0.5A.&lt;/p&gt;

&lt;p&gt;In addition, we need a software which allows us to have a user interface so we can send commands (or queries) to the module and see the module answer. While there are multiple software available for this purpose, we found &lt;a href=&quot;http://realterm.sourceforge.net/&quot;&gt;Realterm&lt;/a&gt; as being very stable, free of charge and easy to use. Further in this tutorial we refer to Realterm when providing examples or screen shots related to this topic, but you are free to use others if you like, such as for example &lt;a href=&quot;http://www.putty.org/&quot;&gt; Putty&lt;/a&gt;.&lt;/p&gt;

&lt;figure id=&quot;fig4&quot;&gt;&lt;img alt=&quot;ESP8266 PC USB Connection via TTL Module on a Breadboard&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/usb-ttl-esp8266-breadboard.png&quot; /&gt;
&lt;figcaption&gt;Figure 4: ESP8266 PC USB Connection via TTL Module on a Breadboard.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure id=&quot;fig5&quot;&gt;&lt;img alt=&quot;Schematics of ESP8266 PC USB Connection via TTL Module&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/usb-ttl-esp8266-schematics.png&quot; /&gt;
&lt;figcaption&gt;Figure 5: Schematics of ESP8266 PC USB Connection via TTL Module.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;It may be observed that two of the ESP8266 module pins are connected to VCC (3.3V) via 3.3kΩ resistors. This is required, because the RST (reset) and CH_PD (power down) pins must stay high during the normal operation of this module. One can use Arduino I/O pins to control the state of these pins, thus having reset and power down features for a project that implies to use the ESP8266 module, and allowing for lower energy consumption when WiFi transmission is not required. The ESP8266 module is able to recover very fast from a &quot;power down&quot; state, the wake-up time being in the order of milliseconds. However, after resetting the module, may take up to two seconds to have the module booted and a few other seconds until WiFi line is ready to be used.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Important:&lt;/strong&gt; the connection between the GPIO0 of the ESP8266 module and GND (see the blue wire in &lt;a href=&quot;#fig4&quot;&gt;Figure 4&lt;/a&gt;) is required when the firmware needs to be updated. In all the other case, you should remove this connection, otherwise your module will not communicate via the UART port (RX/TX lines). Removing or connecting GPIO0 pin to GND should be done ONLY when the module receives no power, so first turn OFF the power supply connected to module, then connect or disconnect the wire (or jumper) between the GPIO0 to GND.&lt;/p&gt;

&lt;p&gt;The USB-TTL module we use has a 3.3V UART interface, therefore is no need to have an additional voltage LC (level converter) module. Before doing the connections, check if your module has already this feature, by measuring (using a voltmeter) the voltage between the GND and TX pins of the USB-TTL module. If you read a voltage value under 3.5V, then it is safe to connect the RX and TX pins of the USB-TTL module directly to the ESP8266 TX and RX pins. If you read more than 3.5V then you need to use a LC module to convert the 5V to 3.3V and back between the RX and TX lines of the ESP8266 module and the USB-TTL module. Ignoring this advice may result in a broken ESP8266 module, so do it at your own risk!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; it is strongly recommended to use a stable 3.3V power supply, which  is able to provide current in excess of 500mA (0.5A). The ESP8266 module is in general power efficient, but during the data transmission, it may have peaks of up to 500mA. Powering it from the 3.3V rail of the Aruino board or from the 3.3V rail available for some USB-TTL module is NOT recommended and will very likely result in destroying the 3.3V voltage regulator of your Arduino board or of the USB-TTL board. We use a breadboard friendly power supply, able to provide 3.3V and 5V (a switch allow the selection) at up to 500mA (see &lt;a href=&quot;#fig4&quot;&gt;Figure 4&lt;/a&gt;). This specific power supply cab be found very cheap, having prices of about 1-3 EUR postage in EU included.&lt;/p&gt;

&lt;p&gt;After you have downloaded and installed &lt;a href=&quot;http://realterm.sourceforge.net/&quot;&gt;Realterm&lt;/a&gt;, start it and select the baud rate (normally this defaults to 115200 for most of the ESP8266 modules we bought over the last 6 months) and the COM port (which in our case is 38, but may be different for you, so better check). Last, push the &quot;Open&quot; button, to create a Serial (UART) connection. If the &quot;Open&quot; button was already pushed, then push it again to its OFF state it and push it back to its ON state. Also, check &lt;a href=&quot;#fig6&quot;&gt;Figure 6&lt;/a&gt; for additional information.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Realterm is highly configurable via command line parameters. Check the &lt;a href=&quot;http://realterm.sourceforge.net/index.html#Command_Line_Parameters&quot;&gt;command line configuration parameters&lt;/a&gt; documentation for making your settings permanent (e.g., to have the program started with the COM port and baud-rate already set to whatever you like) or for having various other configurations.&lt;/p&gt;

&lt;figure id=&quot;fig6&quot;&gt;&lt;img alt=&quot;Realterm Port and Baud-rate configuation&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/esp8266-FU-connect.png&quot; /&gt;
&lt;figcaption&gt;Figure 6: Realterm Port and Baud-rate configuation.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;At this moment we are ready to communicate with the ESP8266 module. First operation we like to perform is a reset, so we are able to see that the module reacts to our commands. For this, go to &quot;Send&quot; tab in Realterm UI and write &quot;AT+RST&quot; on the first text input box. Please check the &quot;+CR&quot; and &quot;+LF&quot; boxes located on the right of the first text input box, thus allowing to send a CR and LF chars at the end of the command, allowing the ESP8266 module to detect a &quot;command end&quot; limiter. You should see a result similar with the one shown in &lt;a href=&quot;#fig7&quot;&gt;Figure 7&lt;/a&gt;, but some of the response text may differ in your case because of different firmware versions.&lt;/p&gt;

&lt;figure id=&quot;fig7&quot;&gt;&lt;img alt=&quot;Sending Reset Command to ESP8266 Module&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/esp8266-AT+RST-before.png&quot; /&gt;
&lt;figcaption&gt;Figure 7: Sending Reset Command to ESP8266 Module.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Our initial purpose was to check if we have (or not) the latest firmware burned int our ESP8266 module. For this, following the same procedure as for &quot;AT+RST&quot; command, we send the &quot;AT+GMR&quot; command. Tee result we obtain is shown in &lt;a href=&quot;#fig8&quot;&gt;Figure 8&lt;/a&gt; but you may have a different one, because of a different firmware version burned into your module.&lt;/p&gt;

&lt;figure id=&quot;fig8&quot;&gt;&lt;img alt=&quot;Sending &#039;Get Version&#039; Command to ESP8266 Module&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/esp8266-AT+GMR-before.png&quot; /&gt;
&lt;figcaption&gt;Figure 8: Sending &#039;Get Version&#039; Command to ESP8266 Module.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;As shown in &lt;a href=&quot;#fig8&quot;&gt;Figure 8&lt;/a&gt;, the SDK firmware version of our module 1.3.0 and the AT version is 0.40.0, which are quite old (see also the date, is 8 August 2015!). Check if there is any available firmware update by navigating to &lt;a href=&quot;http://bbs.espressif.com/&quot;&gt;http://bbs.espressif.com/&lt;/a&gt; and look at the &quot;SDK&quot; section. We found that the current available firmware update is SDK version 1.5.3 and the current AT version is 1.1.0 (dated 16 April 2016).&lt;/p&gt;

&lt;p&gt;Download the firmware following the links provided in the SDK download page, then unzip the archive somewhere on your PC hard drive. Open the ESP8266Flasher tool, available as download in the archive attached to this tutorial. Now follow the instructions shown in &lt;a href=&quot;#fig9&quot;&gt;Figure 9&lt;/a&gt;, &lt;a href=&quot;#fig10&quot;&gt;Figure 10&lt;/a&gt; and &lt;a href=&quot;#fig11&quot;&gt;Figure 11&lt;/a&gt; to configure the tool for firmware update. Notice that in &lt;a href=&quot;#fig10&quot;&gt;Figure 10&lt;/a&gt;, we have selected 1MB because our ESP02 module has a 8MBit (1MB) flash IC, but you should do the appropriate selection for your module if the flash IC is different. However, a flash IC with a size smaller than 1MB &lt;strong&gt;will not work&lt;/strong&gt;, since the current firmware version is to big to fit. Such a module cannot be upgraded to a firmware version greater than 1.1.0 (which is quite old and misses a lot of features, so go and break your piggy bank and buy an appropriate ESP8266 module!).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; the ESP8266 firmware update tool, as well as the current version of the ESP8266 firmware is part of the download archive we provide with this article. However, new firmware versions may be released at anytime, so better check the &lt;a href=&quot;http://bbs.espressif.com/&quot;&gt;http://bbs.espressif.com/&lt;/a&gt; for being sure that you get the latest version.&lt;/p&gt;

&lt;figure id=&quot;fig9&quot;&gt;&lt;img alt=&quot;Select Firmware Update Binaries&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/esp8266-FU-config.png&quot; /&gt;
&lt;figcaption&gt;Figure 9: Select Firmware Update Binaries.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure id=&quot;fig10&quot;&gt;&lt;img alt=&quot;Select Flash Size and Baudrate for Firmware Update&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/esp8266-FU-advanced.png&quot; /&gt;
&lt;figcaption&gt;Figure 10: Select Flash Size and Baudrate for Firmware Update.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure id=&quot;fig11&quot;&gt;&lt;img alt=&quot;Select COM Port for Firmware Update&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/esp8266-FU-operation.png&quot; /&gt;
&lt;figcaption&gt;Figure 11: Select COM Port for Firmware Update.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Last, start the firmware update by pushing the &quot;Flash&quot; button, shown in &lt;a href=&quot;#fig11&quot;&gt;Figure 11&lt;/a&gt;. If all was correctly configure, you should see now the &quot;AP MAC&quot; and &quot;STA MAC&quot; fields (shown in &lt;a href=&quot;#fig11&quot;&gt;Figure 11&lt;/a&gt;) filled in with values (as shown in &lt;a href=&quot;#fig12&quot;&gt;Figure 12&lt;/a&gt;), and the blue bar starts to fill in, showing the progress (see &lt;a href=&quot;#fig12&quot;&gt;Figure 12&lt;/a&gt;).&lt;/p&gt;

&lt;figure id=&quot;fig12&quot;&gt;&lt;img alt=&quot;Firmware Update in Progress&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/esp8266-FU-updating.png&quot; /&gt;
&lt;figcaption&gt;Figure 12: Firmware Update in Progress.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;The update may take about a minute or two, and at the end, the ESP8266Flasher UI should look similar with &lt;a href=&quot;#fig13&quot;&gt;Figure 13&lt;/a&gt;.&lt;/p&gt;

&lt;figure id=&quot;fig13&quot;&gt;&lt;img alt=&quot;Firmware Update Completed&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/esp8266-FU-updated.png&quot; /&gt;
&lt;figcaption&gt;Figure 13: Firmware Update Completed.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;At this point, you&#039;ll need to power down the ESP8266 module (disconnect the power supply), and remove the connection between the GPIO0 pin and GND, so the module does not enter firmware upgrade mode when powered up. Missing this step results in a non communicative module, therefore not responding to commands and looking as a broken one, software wise.&lt;/p&gt;

&lt;p&gt;Start the Realterm, make the port configurations (discussed earlier in this section) and run the &quot;AT+RST&quot; command and then the &quot;AT+GMR&quot; command and check the results. If all went well, you should see results similar with the ones shown in &lt;a href=&quot;#fig14&quot;&gt;Figure 14&lt;/a&gt; and &lt;a href=&quot;#fig15&quot;&gt;Figure 15&lt;/a&gt;.&lt;/p&gt;

&lt;figure id=&quot;fig14&quot;&gt;&lt;img alt=&quot;Sending Reset Command to ESP8266 Module&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/esp8266-AT+RST-after.png&quot; /&gt;
&lt;figcaption&gt;Figure 14: Sending Reset Command to ESP8266 Module.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure id=&quot;fig15&quot;&gt;&lt;img alt=&quot;Sending &#039;Get Version&#039; Command to ESP8266 Module&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/esp8266-AT+GMR-before.png&quot; /&gt;
&lt;figcaption&gt;Figure 15: Sending &#039;Get Version&#039; Command to ESP8266 Module.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; the &quot;Display&quot; tab of the Realterm UI provides useful settings for selecting how the data is displayed. Normally, you&#039;ll want to select &quot;Ascii&quot; or &quot;Ansi&quot; as the value of the &quot;Display As&quot; parameter. In addition to normal characters, from the ASCII table, the &quot;Ascii&quot; mode shows also the special chars, such as CR and LF, which are important when using Realterm to debug or control ESP8266 module.&lt;/p&gt;

&lt;h2&gt;Use Arduino and HTTP(S) to Access Online Services via an WiFi Network&lt;/h2&gt;

&lt;p&gt;In this section we are going to use Arduino UNO, ESP02 WiFi module (remember, we chose to use this specific one out of all existing variations) and the DHT22 temperature and humidity sensor. With the ESP02 module we are going to connect to a WiFi network, thus gaining access to internet. Using a free &lt;a href=&quot;http://thingspeak.com&quot;&gt;thingspeak.com&lt;/a&gt; account, we store the temperature and humidity values, with the purpose of having charts that shows the evolution over time. We send a sample every 15 seconds, since it is highly improbable to have changes of temperature and humidity values faster than this, which also provides a lower power consumption, since the ESP8266 modules are quite power efficient in &quot;stand-by&quot; mode, but this changes a lot when data is transmitted over WiFi.&lt;/p&gt;

&lt;p&gt;It may be useful to have also a USB-TTL module near you, so in case of the case that your ESP8266 module seems irresponsible, you can try to provide commands directly via Realterm software, as discussed earlier in this tutorial.&lt;/p&gt;

&lt;h3&gt;Hardware Configuration&lt;/h3&gt;

&lt;p&gt;As shown in &lt;a href=&quot;#fig16&quot;&gt;Figure 16&lt;/a&gt; and &lt;a href=&quot;#fig17&quot;&gt;Figure 17&lt;/a&gt;, for this project we need the following components:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;An Arduino UNO board, but you can use almost any Arduino board, with minimal or no modifications.&lt;/li&gt;
	&lt;li&gt;An ESP02 WiFi module, but you can also use any of the 12 available versions, just remember to update the firmware.&lt;/li&gt;
	&lt;li&gt;A DHT22 temperature and humidity sensor, but if you like, DHT11/21 or LM35 are as good, you&#039;ll just need to adapt your code related to sensor reading.&lt;/li&gt;
	&lt;li&gt;A voltage LC module, that allows the communication between Arduino and ESP02 module, but you can skip this in case you are using a 3.3V Arduino board (e.g., Arduino DUE).&lt;/li&gt;
	&lt;li&gt;A voltage regulator module, that uses USB or a power brick to provide the 3.3V@500mA required by the ESP02, and most of the other ESP modules.&lt;/li&gt;
	&lt;li&gt;Three 10k resistors, used to PULL UP the DHT22 data pin and the RST and CH_PD pins of the ESP02 module.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In addition, an USB-TTL module may be useful for debugging, but this is not required for the functionality of the circuit. Notice that the connection between GPIO0 pin of the ESP8266 module and GND is dropped, that being only required for the firmware update. If you still have that connection, now is the case to disable it, because your module needs to boot up, and that is not the case as long as GPIO0 is connected to GND. You should let GPIO0 pin floating (not connected).&lt;/p&gt;

&lt;figure id=&quot;fig16&quot;&gt;&lt;img alt=&quot;ESP8266 WiFi Module Connected to an Arduino UNO Board&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/arduino-esp8266-breadboard.png&quot; /&gt;
&lt;figcaption&gt;Figure 16: ESP8266 WiFi Module Connected to an Arduino UNO Board.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure id=&quot;fig17&quot;&gt;&lt;img alt=&quot;Circuit Diagram of an ESP8266 WiFi Module Connected to an Arduino UNO Board&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/arduino-esp8266-schematics.png&quot; /&gt;
&lt;figcaption&gt;Figure 17: Circuit Diagram of an ESP8266 WiFi Module Connected to an Arduino UNO Board.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3&gt;SoftwareConfiguration&lt;/h3&gt;

&lt;p&gt;In this section we&#039;ll learn how to use the AT commands set for being able to connect to a WiFi network, then using TCP connect to a live server, and last, send the temperature and humidity values to &lt;a href=&quot;http://thingspeak.com&quot;&gt;thingspeak.com&lt;/a&gt; for being stored and having displayed them as a chart.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; all the source code, including the required libraries are included in the zip archive available for download as part of this article (check the article head), but we encourage you to visit our &lt;a href=&quot;https://github.com/dimircea/Arduino&quot;&gt;github.com project page&lt;/a&gt; where you can download the latest changes, updates and fixes for this code and much more.&lt;/p&gt;

&lt;p&gt;First, you&#039;ll need to setup a free account at &lt;a href=&quot;https://thingspeak.com&quot;&gt;thingspeak.com&lt;/a&gt;. Then, in the &quot;Channel Settings&quot; menu enable &quot;Field 1&quot; and &quot;Field 2&quot;, and give them some human readable names, such as &quot;DHT-Temperature&quot; and &quot;DHT-Humidity&quot;. Then, navigate to &quot;Api Keys&quot; menu and copy the &quot;Write API Key&quot; value and paste it on the ESP8266_DHT22.ino as the value of &lt;code&gt;DATA_SERVER_API_KEY&lt;/code&gt; constant. The file ESP8266_DHT22.ino is located under under examples/ESP8266/ESP8266_DHT22 folder. Remember to replace also &lt;code&gt;WIFI_SSID&lt;/code&gt; and &lt;code&gt;WIFI_PASSWORD&lt;/code&gt; constants values with your own WiFi network credentials.&lt;/p&gt;

&lt;p&gt;Second, you&#039;ll need to copy the DHTxx and ESP8266 folders, located under libraries sub-folder, into your libraries sub-folder of the Arduino IDE software. This is required because we&#039;ll use these two libraries with our example code.&lt;/p&gt;

&lt;p&gt;Lets have now a look at the example code, part of the &lt;em&gt;examples/ESP8266/ESP8266_DHT22/ESP8266_DHT22.ino&lt;/em&gt; Arduino sketch. Like with any Arduino porgram, we&#039;ll need to include the library headers, in our case these are DHTxx.h and ESP8266.h. We also define a constant for the I/O pin used to communicate with the DHT22 sensor, and a set of constants that stores the WiFi credentials (SSID and password), thingspeak.com server address (api.thingspeak.com), the TCP port used for connection, the request path and the thingspeak.com &quot;Write API Key&quot; (required for being able to write data).&lt;/p&gt;

&lt;pre&gt;
#include &amp;lt;dhtxx.h&amp;gt;
#include &amp;lt;esp8266.h&amp;gt;
#define DHT_PIN 7

// WiFi authentication data
const char* WIFI_SSID = &quot;your-wifi-ssid&quot;;
const char* WIFI_PASSWORD = &quot;your-wifi-password&quot;;

// data server address and port
const char* DATA_SERVER_ADDRESS = &quot;api.thingspeak.com&quot;
const uint8_t DATA_SERVER_PORT = 80;

// data to be sent to the server
const char* DATA_SERVER_API_KEY = &quot;your-thingspeak-write-api-key&quot;;
char* DATA_SERVER_PATH = &quot;/update&quot;;
&lt;/pre&gt;

&lt;p&gt;Further, we have to create the Dht and ESP8266 objects, responsible for the communication with the DHT22 sensor and ESP8266 WiFi module.&lt;/p&gt;

&lt;pre&gt;
Dht dht(DHT_PIN, Dht::TypeEL::DHT22);
ESP8266 esp(Serial);
&lt;/pre&gt;

&lt;p&gt;The Arduino board and the ESP8266 module communicates via the serial port, thus we use the &lt;code&gt;Serial&lt;/code&gt; object as the middle-ware. The &lt;code&gt;Serial&lt;/code&gt; global object, which is Arduino specific, is provided as parameter to the ESP8266 object and used internally to read and write data, as well as to deal with the incoming data streams and extract the relevant information.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;setup&lt;/code&gt; method takes care of the Serial port initialization (communication is made at 115200bps). In addition, it creates a loop while trying to connect the ESP8266 module to the specified WiFi network (credentials are provided by the &lt;code&gt;WIFI_SSID&lt;/code&gt; and &lt;code&gt;WIFI_PASSWORD&lt;/code&gt; constants).&lt;/p&gt;

&lt;pre&gt;
void setup() {  
  Serial.begin(115200);
  esp.atCwmode(ESP8266::WiFiMode::STA);
  while (esp.atCwjap(WIFI_SSID, WIFI_PASSWORD) != ESP8266::Error::NONE);
};
&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;atCwjap&lt;/code&gt; method, part of the &lt;code&gt;ESP8266&lt;/code&gt; library, is responsible with the WiFi connection for the specified WiFi network. This method is the equivalent of &lt;code&gt;AT+CWJAP=&quot;wifi-ssid&quot;,&quot;wifi-password&quot;&lt;/code&gt; command, which we can send to the ESP8266 module, e.g., by using Realterm. The library we are using, contains a set of methods, most of them being a one-to-one mapping of a specific AT command, and the method name is the AT command name (e.g., &lt;code&gt;AT+CWJAP&lt;/code&gt; has the equivalent method &lt;code&gt;atCwjap&lt;/code&gt;). However, notice that this library does not covers the complete set of available AT commands.&lt;/p&gt;

&lt;p&gt;It is important to know that the ESP8266 module may work in three different modes: client (STA), access point (AP) and both combined (AP+STA). The &lt;code&gt;AT+CWMODE&lt;/code&gt; command allows to set one of these modes, and the used values are: 1 for &lt;code&gt;STA&lt;/code&gt;, 2 for &lt;code&gt;AP&lt;/code&gt; and 3 for &lt;code&gt;AP+STA&lt;/code&gt;. E.g., &lt;code&gt;AT+CWMODE=1&lt;/code&gt; sets the module in client (station) mode. Our ESP8266 library has an equivalent method, &lt;code&gt;atCwmode&lt;/code&gt; for this command. It takes as parameter an enumeration literal value, &lt;code&gt;ESP8266::WiFiMode::xxx&lt;/code&gt;, where &lt;code&gt;xxx = {STA, AP, AP_STA}&lt;/code&gt;. Since we use the WiFi module to connect to a network, she STA mode is the most appropriate, and we set this in the &lt;code&gt;setup&lt;/code&gt; method. It will also work if AP+STA mode is used, but this have some security implications, because the WiFi module becomes also an WiFi access point that has internet access, and unless you know exactly what you are doing, it may open serious security back-doors in your network.&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;loop&lt;/code&gt; method (remember, this method executes again, and again as long as the Arduino receives power) we check if we have a WiFi connection, and if that is true, we perform a DHT22 sensor reading and sent it to thingspeak.com by using the &lt;code&gt;sendDataToServer&lt;/code&gt; method, that we&#039;ll discuss further. We do this with a periodicity of 15 seconds, thus the &lt;code&gt;delay(15000)&lt;/code&gt; call. Notice that the real time between sending data is larger, since various other delays occurs in the code, such as for the TCP connection, data sending, and so on.&lt;/p&gt;

&lt;pre&gt;
void loop() {
  if (!checkWiFi()) return;
  Dht::Result result = dht.read();
  if (result.status == Dht::StatusEL::OK) 
    sendDataToServer(result.temperature, result.humidity);
  delay(5000);
};
&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;checkWifi&lt;/code&gt; method simply sends an &lt;code&gt;AT&lt;/code&gt; command and waits for an &lt;code&gt;OK&lt;/code&gt;, which the ESP8266 module normally sends as response. This command is not really supposed to do something, but just to have a simple way to detect if a serial communication with the module exists or not.&lt;/p&gt;

&lt;pre&gt;
boolean checkWiFi() {
  if( esp.at() == ESP8266::Error::NONE) return true; 
  return false;
};
&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;sendDataToServer&lt;/code&gt; method is responsible with four operations:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;creates the HTTP request, by using a template, discussed later in this tutorial;&lt;/li&gt;
	&lt;li&gt;opens a TCP connection on port 80, with the specified server (see the &lt;code&gt;DATA_SERVER_ADDRESS&lt;/code&gt; constant);&lt;/li&gt;
	&lt;li&gt;sends a GET request to the data server;&lt;/li&gt;
	&lt;li&gt;finally, closes the TCP connection.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
void sendDataToServer(float temperature, float humidity) {
  char data[64] = {0};
  char *pData = data;
  createDataFromTemplate(pData, temperature, humidity);
  esp.atCipstartTcp(DATA_SERVER_ADDRESS, 80);
  esp.atCipsendHttpGet(DATA_SERVER_PATH, data);
  esp.atCipclose();
};
&lt;/pre&gt;

&lt;p&gt;An example of a HTTP GET request that we like to submit looks as follows:&lt;/p&gt;

&lt;pre&gt;
GET /update?api_key=22.7&amp;amp;field1=%s&amp;amp;field2=35.5 HTTP/1.0
&lt;/pre&gt;

&lt;p&gt;We see that some static parts are used (the HTTP method name, the request path &lt;code&gt;/update&lt;/code&gt; and the HTTP version specification), but also some parts that are changing, such as the values of &lt;code&gt;field1&lt;/code&gt; and &lt;code&gt;field2&lt;/code&gt; parameters, corresponding to temperature and humidity values. We&#039;ll turn the parameter part of the request into a template, where the dynamic values are replaced at the request time with specific temperature and humidity quantities. For this, we define a template char pointer (you can thing on it like being a string).&lt;/p&gt;

&lt;pre&gt;
const char DATA_TEMPLATE[] PROGMEM = &quot;?api_key=%s&amp;amp;field1=%s&amp;amp;field2=%s&quot;;
&lt;/pre&gt;

&lt;p&gt;Some magic happens here, because of the keyword PROGMEM. That is not really related to the template, but to the way on which the &quot;template string&quot; is stored by the Arduino MCU. Normally, all strings are stored in the RAM, thus keeping the RAM occupied with data that is only rarely used. The PROGMEM variable modifier informs the compiler that we like to store this value in FLASH (remember, we have FLASH sizes with an order of magnitude greater than RAM!). The problem is now, that we can&#039;t just simply read the variable and expect to have the value there, because what it really stores is the start address of the FLASH memory where the data was stored. For this reason, we created the &lt;code&gt;getPMData&lt;/code&gt; (get program memory data) method to extract the real data from FLASH. Notice that this method comes with the ESP8266 library and is used intensively to deal with the static strings involved by the communication with the ESP8266 module. This method takes three parameters: 1) the defined PROGMEM variable; 2) a char pointer with sufficient allocated memory to store the data you need to read; and 3) a reference to an &lt;code&gt;uint8_t&lt;/code&gt; variable that will be set to a value representing the length of the data that was read from FLASH.&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;createDataFromTemplate&lt;/code&gt; method, we take care to replace the parameters, represented by &lt;code&gt;%s&lt;/code&gt; (denoting a string parameter), into real values.&lt;/p&gt;

&lt;pre&gt;
void createDataFromTemplate( char *&amp;amp;data, float temperature, float humidity) {
  char buffTemp[6] = {0}, buffHum[5] = {0}, tmpl[32] = {0};
  char *pTmpl = tmpl;
  uint8_t templateLen = -1;
  // read template from PROGMEM
  getPMData( DATA_TEMPLATE, pTmpl, templateLen);
  // create data string from template by replacing
  // parameters with their actual values from sensors
  sprintf( data, pTmpl, DATA_SERVER_API_KEY,
    dtostrf( temperature, 0, 1, buffTemp),
    dtostrf( humidity, 0, 1, buffHum));
};
&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;getPMData&lt;/code&gt; method we read the template from FLASH. Further, using &lt;code&gt;sprintf&lt;/code&gt; we replace the specified parameters (i.e., which starts with the % symbol) with concrete values. The &lt;code&gt;dtostrf&lt;/code&gt; method allows to transform the float values that we have for temperature and humidity into strings, used then to fill the template variables. Notice, that &lt;code&gt;sprintf&lt;/code&gt; is able to deal directly with numeric variables, but unfortunately its version available for the Arduino sketches lacks this functionality, thus we also need to use &lt;code&gt;dtostrf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Replace the constant values (i.e., WIFI_SSID, WIFI_PASSWORD, DATA_SERVER_API_KEY and so on) with your own values, then write the sketch into your Arduino. If all went fine, you should now check your account and access the &quot;Private View&quot; tab of your thingspeak.com account. In our case, for a small set of values, we obtain the charts shown in &lt;a href=&quot;#fig18&quot;&gt;Figure 18&lt;/a&gt;. Remember, that we only set data once every 15 seconds, meaning that it can take a while until you&#039;ll see something on your thingspeak.com chart.&lt;/p&gt;

&lt;figure id=&quot;fig18&quot;&gt;&lt;img alt=&quot;Temperature and Humidity Value Charts at thingspeak.com&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/networking/thingspeak-charts.png&quot; /&gt;
&lt;figcaption&gt;Figure 18: Temperature and Humidity Value Charts at thingspeak.com.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2&gt;Some Points of Attention&lt;/h2&gt;

&lt;p&gt;It is important to use a good quality power supply, both for your Arduino board (if not powered via USB) and the ESP8266 module. A low quality power supply may have unknown effects, and may produce behaviors like unwanted resets of the devices. If your ESP8266 module seems to be unstable, i.e., often resets by itself, then it is very likely that you have an issue with the 3.3V rail provided to the module. You can try to add a 1000µF electrolytic capacitor in parallel with an 0.1µF ceramic capacitor to the 3.3V rail. If this does not improve the module behavior, then try to replace your power supply. If an oscilloscope is available, you can observe the behavior of the 3.3V rail.&lt;/p&gt;

&lt;p&gt;When using the ESP8266 module with a device that runs the UART communication on 5V rail (e.g., Arduino UNO and most of the other Arduino boards), then you &lt;strong&gt; need&lt;/strong&gt; to use a voltage LC (level converter) between the RX and TX lines of the ESP8266 modules and the TX and RX lines of the paired device. Also, remember, the RX and TX lines are twisted between the two devices implied in the UART communication.&lt;/p&gt;

&lt;p&gt;While the ESP8266 is a really nice and cheap module, the current version is not rock solid in terms of stability, thus you may observe strange behaviors sometimes. It may help to reset the software configuration to its default state, by using the &quot;AT+RESTORE&quot; command. After that, you should configure the module again, with respect to all parameters you&#039;ve been set before the reset (e.g., WiFi connection, client or AP mode, etc). If your module still misbehaves, then a better power supply may help. Also, be sure that you didn&#039;t wrote a firmware with a version over 1.1.0 on a module that only has 4Mbit (or less) flash size, because you may completely brick your module.&lt;/p&gt;

&lt;p&gt;Sometimes, TCP or UDP connections made via this module are not stable or you may even get connection refused errors. In this case, you should try a few more times to be sure that it is really a problem, since in multiple cases this is just a temporarily problem and can be solved by retrying, resetting or power cycling the module.&lt;/p&gt;

&lt;p&gt;Periodically check the temperature of your ESP8266 module, simply by putting your finger on the CPU IC. If it feels hot when touched, then something may be wrong. Usually a hot CPU on the ESP8266 module means that the module receives more than the 3.3V required on the power line or on the RX and/or TX lines. Check the voltage, and make sure that this is not the case. If this is not the case, the high temperature may be due to high WiFi activity. While this is not unusual for these modules, make sure that the module is on a place with environment temperature under 30°C to avoid overheating and damaging the CPU.&lt;/p&gt;

&lt;p&gt;When using the module in AP (access point) or STA+AP (station and access point) modes (that is, AT+CWMODE=2 or AT+CWMODE=3), make sure that you set a good password, otherwise you may have &quot;spy eyes&quot; on your network and may even result in security breach of your entire enterprise network! To check if you are in either AP or STA+AP mode, run the &quot;AT+CWMODE?&quot; command and check which value it returns (+CWMODE:1 means STA mode, +CWMODE:2 means AP mode and +CWMODE:3 means STA+AP mode).&lt;/p&gt;

&lt;h2&gt;Next Tutorial: Part 4 - Control the Environment by Using Actuators&lt;/h2&gt;

&lt;p&gt;In this tutorial we&#039;ll learn how to use Arduino to produce environment changes. Specifically, we&#039;ll use relays to turn ON/OF lights, miniature water pumps to ensure the correct soil moisture for our beloved room plants and a DIY PWM actuator to adjust the intensity of a dimmable LED strip, used to produce ambient light on a room.&lt;/p&gt;

&lt;p&gt;The release date of the 4th part is: before 24 May 2016.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;section class=&quot;field field-name-field-category field-type-taxonomy-term-reference field-label-above view-mode-rss&quot;&gt;&lt;h2 class=&quot;field-label&quot;&gt;Category:&amp;nbsp;&lt;/h2&gt;&lt;ul class=&quot;field-items&quot;&gt;&lt;li class=&quot;field-item even&quot;&gt;&lt;a href=&quot;/taxonomy/term/40&quot; typeof=&quot;skos:Concept&quot; property=&quot;rdfs:label skos:prefLabel&quot; datatype=&quot;&quot;&gt;WoT&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;field-item odd&quot;&gt;&lt;a href=&quot;/taxonomy/term/45&quot; typeof=&quot;skos:Concept&quot; property=&quot;rdfs:label skos:prefLabel&quot; datatype=&quot;&quot;&gt;Sensor&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;field-item even&quot;&gt;&lt;a href=&quot;/Arduino&quot; typeof=&quot;skos:Concept&quot; property=&quot;rdfs:label skos:prefLabel&quot; datatype=&quot;&quot;&gt;Arduino&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;div class=&quot;easy_social_box clearfix horizontal easy_social_lang_und&quot;&gt;
            &lt;div class=&quot;easy_social-widget easy_social-widget-twitter first&quot;&gt;&lt;a href=&quot;http://twitter.com/share&quot; class=&quot;twitter-share-button&quot;
data-url=&quot;https://web-engineering.info/node/62&quot;
data-count=&quot;horizontal&quot;
data-lang = &quot;en&quot;
data-via=&quot;&quot;
data-related=&quot;:Check it out!&quot;
data-text=&quot;WoT with Arduino for Beginners: Part 3 - Connecting to the Internet via WiFi&quot;&gt;Tweet&lt;/a&gt;&lt;/div&gt;
          &lt;div class=&quot;easy_social-widget easy_social-widget-facebook&quot;&gt;&lt;fb:like href=&quot;https://web-engineering.info/node/62&quot; send=&quot;true&quot; layout=&quot;button_count&quot; width=&quot;88&quot; show_faces=&quot;true&quot; action=&quot;like&quot; colorscheme=&quot;light&quot; font=&quot;&quot;&gt;&lt;/fb:like&gt;&lt;/div&gt;
          &lt;div class=&quot;easy_social-widget easy_social-widget-googleplus&quot;&gt;&lt;div class=&quot;g-plusone&quot; data-size=&quot;medium&quot; data-annotation=&quot;bubble&quot; data-href=&quot;https://web-engineering.info/node/62&quot;&gt;&lt;/div&gt;&lt;/div&gt;
          &lt;div class=&quot;easy_social-widget easy_social-widget-linkedin last&quot;&gt;&lt;script type=&quot;in/share&quot; data-url=&quot;https://web-engineering.info/node/62&quot; data-counter=&quot;right&quot;&gt;&lt;/script&gt;&lt;/div&gt;
  &lt;/div&gt; &lt;!-- /.easy_social_box --&gt;</description>
 <pubDate>Wed, 20 Apr 2016 14:46:57 +0000</pubDate>
 <dc:creator>mdiaconescu</dc:creator>
 <guid isPermaLink="false">62 at https://web-engineering.info</guid>
 <comments>https://web-engineering.info/node/62#comments</comments>
</item>
<item>
 <title>WoT with Arduino for Beginners: Part 2 - Connecting to the Real World via Sensors</title>
 <link>https://web-engineering.info/node/61</link>
 <description>&lt;div class=&quot;field field-name-body field-type-text-with-summary field-label-hidden view-mode-rss&quot;&gt;&lt;div class=&quot;field-items&quot;&gt;&lt;div class=&quot;field-item even&quot; property=&quot;content:encoded&quot;&gt;&lt;p&gt;In this multi-part tutorial we show how to develop Arduino-based apps for the Web of Things (WoT). This second part shows how to read data with the help of analog or digitally controlled sensors. In the following parts of this tutorial, which will appear every 1-3 weeks, we discuss how to control actuators and how to connect them all together in a Web of Things (WoT) network. Using standard Web technologies, such as HTTP and Web Sockets, we can then access the data or provide commands to the WoT nodes. As a newbie, it is helpful if you already have some basic C/C++ programming knowledge and understanding of some Web standards and programming languages, such as HTML and JavaScript.&lt;/p&gt;

&lt;p&gt;Check the other parts of this tutorial series:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://web-engineering.info/node/60&quot;&gt;Part 1: Mastering the RGB LED&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; working with electricity is dangerous. For this project we&#039;ll use 5V, which is safe for the human body under any environment conditions. However, the low voltage may be obtained from a mains connected power brick, and therefore we highly recommend you to take safety precautions and to use a trustful brand for the power supply. We cannot be held responsible for any caused damage! Do it at your own risk and/or ask help from an electronics engineer. In case you are using the USB connector from your PC to power the Arduino board, be aware that short-circuits which may occur on the Arduino board may also have a negative impact on your PC!&lt;/small&gt;&lt;/p&gt;

&lt;p style=&quot;margin-top:1em&quot;&gt;&lt;small&gt;&lt;strong&gt;Credits:&lt;/strong&gt; some of the images from this tutorial are created by using &lt;a href=&quot;http://fritzing.org/home/&quot;&gt;Fritzing&lt;/a&gt;, a nice electronics modeling tool for beginners.&lt;/small&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/WoT-Tutorial-Part2.zip&quot;&gt;Download Source Code&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt;

&lt;h2&gt;What is a Sensor ?&lt;/h2&gt;

&lt;p&gt;A sensor is a device that is able to capture a quality (property) of the environment, within its detection radius, and provides, in some form, a quantity value representing the quantitative characteristics of that property. There are two main categories of sensors: electronic sensor or mechanical sensors.&lt;/p&gt;

&lt;p&gt;Examples of devices consisting of one or more sensors:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;&lt;em&gt;electronic sensors:&lt;/em&gt; digital thermometers, weather stations or alcohol level testers;&lt;/li&gt;
	&lt;li&gt;&lt;em&gt;mechanical sensors:&lt;/em&gt; water levels using balloons and graded bars, tire pressure testers found in gas stations, spring based pressure sensors found in some vices or force sensors found in manometer tools.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Usually, we also call sensor a collection of detectors, such as measuring temperature and humidity in the same time. A detector is an atomic sensor, able to measure one specific quality. Therefore, a sensor may consist of either one or more detectors.&lt;/p&gt;

&lt;p&gt;Further in this tutorial we only discuss about electronic sensors/detectors: their output is an electric signal, that can be captured and interpret as the quantity of the environment measured quality (property). We&#039;ll use Arduino UNO board as interface (or controller), but most of the other Arduino boards (Nano, Micro, MEGA2560, etc) works as well with the provided code examples, without any or with very minor changes.&lt;/p&gt;

&lt;h2&gt;Digital Sensors&lt;/h2&gt;

&lt;p&gt;A digital sensor is a sensor that uses a digital communication interface. Such an interface can be a standard one, such as &lt;a href=&quot;https://en.wikipedia.org/wiki/I%C2%B2C&quot;&gt;I2C&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus&quot;&gt;SPI&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;, but can also be a custom one, such as a stream of HIGH and LOW signals (also known as pulses), which are then interpreted as binary data. Custom digital interfaces may also refer to simply measuring a pulse for an amount of time and interpreting its length as the received information. Last but not least, some digital sensors are only providing a HIGH (or LOW) signal, when an event occurs, such as a intrusion detection sensor.&lt;/p&gt;

&lt;p&gt;In this tutorial we discuss the DHT11/DHT22 humidity and temperature sensor as well as the HC-SR04 distance measurement sensor, both using a custom digital interface.&lt;/p&gt;

&lt;h3&gt;Measure Temperature and Humidity with a DHT11/DHT22 Sensor&lt;/h3&gt;

&lt;p&gt;It is fairly simple to measure temperature and relative air humidity with the help of DHT11, DHT21 or DHT22 sensors. Each of those consists in fact of two detectors in a single package, and with a single 1-Wire custom digital communication interface. The main differences between these sensors are the measured ranges and their accuracy and resolution properties, as shown in the table &lt;a href=&quot;#table1&quot;&gt;Table 1&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;These sensors are fairly low priced, and in EU you can buy a DHT11 sensor for about 3EUR, a DHT21 for about 4EUR and a DHT22 for about 5EUR, postage included. The price can be cut in less than half when you are willing to order it online from China (e.g., by using &lt;a href=&quot;http://www.ebay.com/sch/i.html?_nkw=DHT11&quot;&gt;eBay&lt;/a&gt;), but be warned, the time to receive it in EU is usually from three to six weeks, sometimes even longer.&lt;/p&gt;

&lt;table id=&quot;table1&quot;&gt;
	&lt;caption&gt;Table 1: DHT11/DHT21/DHT22 Sensor Characteristics.&lt;/caption&gt;
	&lt;thead&gt;
		&lt;tr&gt;
			&lt;th&gt;&amp;nbsp;&lt;/th&gt;
			&lt;th&gt;DHT11 Temperature&lt;/th&gt;
			&lt;th&gt;DHT11 Air Humidity&lt;/th&gt;
			&lt;th&gt;DHT21/HM2301 Temperature&lt;/th&gt;
			&lt;th&gt;DHT21/HM2301 Air Humidity&lt;/th&gt;
			&lt;th&gt;DHT22/AM2302 Temperature&lt;/th&gt;
			&lt;th&gt;DHT22/AM2302 Air Humidity&lt;/th&gt;
		&lt;/tr&gt;
	&lt;/thead&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;Range&lt;/td&gt;
			&lt;td&gt;[0, 50]°C&lt;/td&gt;
			&lt;td&gt;[20, 90]%&lt;/td&gt;
			&lt;td&gt;[-40, 80]°C&lt;/td&gt;
			&lt;td&gt;[0, 100]%&lt;/td&gt;
			&lt;td&gt;[-40, 125]°C&lt;/td&gt;
			&lt;td&gt;[0, 100]%&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Accuracy&lt;/td&gt;
			&lt;td&gt;±2°C&lt;/td&gt;
			&lt;td&gt;±5%&lt;/td&gt;
			&lt;td&gt;±1°C&lt;/td&gt;
			&lt;td&gt;±5%&lt;/td&gt;
			&lt;td&gt;±0.2°C&lt;/td&gt;
			&lt;td&gt;±2%&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Resolution&lt;/td&gt;
			&lt;td&gt;1°C&lt;/td&gt;
			&lt;td&gt;1%RH&lt;/td&gt;
			&lt;td&gt;0.1°C&lt;/td&gt;
			&lt;td&gt;0.1%RH&lt;/td&gt;
			&lt;td&gt;0.1°C&lt;/td&gt;
			&lt;td&gt;0.1%RH&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Operating voltage&lt;/td&gt;
			&lt;td&gt;[3.3, 5.5]V&lt;/td&gt;
			&lt;td&gt;[3.3, 5.5]V&lt;/td&gt;
			&lt;td&gt;[3.3, 6]V&lt;/td&gt;
			&lt;td&gt;[3.3, 6]V&lt;/td&gt;
			&lt;td&gt;[3.3, 6]V&lt;/td&gt;
			&lt;td&gt;[3.3, 6]V&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Operating current&lt;/td&gt;
			&lt;td&gt;[1.2, 2]mA&lt;/td&gt;
			&lt;td&gt;[1.2, 2]mA&lt;/td&gt;
			&lt;td&gt;[1.3, 2.1]mA&lt;/td&gt;
			&lt;td&gt;[1.3, 2.1]mA&lt;/td&gt;
			&lt;td&gt;[1.3, 2.1]mA&lt;/td&gt;
			&lt;td&gt;[1.3, 2.1]mA&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;&amp;nbsp;&lt;/td&gt;
			&lt;td colspan=&quot;2&quot; style=&quot;text-align:center; font-weight: bold;&quot;&gt;&lt;a href=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/DHT11.pdf&quot;&gt;Download datasheet&lt;/a&gt;&lt;/td&gt;
			&lt;td colspan=&quot;2&quot; style=&quot;text-align:center; font-weight: bold;&quot;&gt;&lt;a href=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/DHT21.pdf&quot;&gt;Download datasheet&lt;/a&gt;&lt;/td&gt;
			&lt;td colspan=&quot;2&quot; style=&quot;text-align:center; font-weight: bold;&quot;&gt;&lt;a href=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/DHT22.pdf&quot;&gt;Download datasheet&lt;/a&gt;&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;DHTxx sensor&amp;nbsp;may come with or without a breakout board, which allows not only to fix the sensor with a screw in a fixed place, but also usually have a LED to indicate that the sensor receives power, and most of them provides a PULL UP resistor, which otherwise you have to add between their DATA and VCC pins. A PULL UP resistor has usually a value between 2kΩ and 20kΩ (most common values are 4.7kΩ and 10kΩ), and it connects the corresponding data line to VCC, thus the line stays at VCC level as long there is no other activity from the micro-controller, to pull the data line to LOW. &lt;a href=&quot;#fig1&quot;&gt;Figure 1&lt;/a&gt; shows variations of DHT11 sensors and &lt;a href=&quot;#fig2&quot;&gt;Figure 2&lt;/a&gt; shows variations of DHT22 sensors, with or without a breakout board, as well as the pin-out (pins configuration).&lt;/p&gt;

&lt;figure id=&quot;fig1&quot;&gt;&lt;img alt=&quot;DHT11 Sensors&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/DHT11.png&quot; /&gt;
&lt;figcaption&gt;Figure 1: Variations of DHT11 Sensor.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure id=&quot;fig2&quot;&gt;&lt;img alt=&quot;DHT22 Sensors&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/DHT22.png&quot; /&gt;
&lt;figcaption&gt;Figure 2: Variations of DHT22 Sensor.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4&gt;Hardware Configuration&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;#fig3&quot;&gt;Figure 3&lt;/a&gt; shows how to connect a DHTxx sensor to an Arduino UNO board, and &lt;a href=&quot;#fig4&quot;&gt;Figure 4&lt;/a&gt; shows the electronics schematics. Notice the third pin of the sensor is not connected and all three variations of this sensor have the same pin-out.&lt;/p&gt;

&lt;figure id=&quot;fig3&quot;&gt;&lt;img alt=&quot;DHTxx Sensor Connected to an Arduino UNO Board&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/Fritzing-DHTxx-breadboard.png&quot; /&gt;
&lt;figcaption&gt;Figure 3: DHTxx Sensor Connected to an Arduino UNO Board.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure id=&quot;fig4&quot;&gt;&lt;img alt=&quot;Circuit Diagram for a DHTxx Sensor Connected to an Arduino UNO Board&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/Fritzing-DHTxx-schematics.png&quot; /&gt;
&lt;figcaption&gt;Figure 4: Circuit Diagram for a DHTxx Sensor Connected to an Arduino UNO Board.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Note1:&lt;/strong&gt; if we use a DHTxx sensor without a breakout board that includes a PULL UP resistor, then we&#039;ll need to add a 10kΩ one between the VCC line and the DATA pin. If the PULL UP resistor is missing, the received data may be corrupted or may be no transmission.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note2:&lt;/strong&gt; in some diagrams, the VCC pin is also noted as VDD, but its meaning does not change.&lt;/p&gt;

&lt;h4&gt;Software Configuration&lt;/h4&gt;

&lt;p&gt;Its now the time to query the sensor and obtain temperature and humidity data. For this you&#039;ll need to add the DHTxx library to your Arduino IDE libraries collection. Download the DHTxx library from &lt;a href=&quot;https://github.com/dimircea/Arduino/tree/master/libraries/DHTxx&quot;&gt;github&lt;/a&gt; and copy the folder &lt;code&gt;DHTxx&lt;/code&gt; into your &lt;code&gt;libraries&lt;/code&gt; sub-folder of the Arduino installation folder. If the Arduino IDE was started before, you have now to close it and start it again.&lt;/p&gt;

&lt;p&gt;To &quot;load&quot; the DHTxx library into our Arduino sketch, we use the &lt;code&gt;#include&lt;/code&gt; directive. Then, we create an instance of the &lt;code&gt;Dht&lt;/code&gt; class (defined by the library), which takes care of the communication with the DHTxx sensor. Its constructor has two parameters: the pin number used to communicate with the sensor (the Arduino UNO digital pin 7 in our example), and the sensor type used (DHT11, DHT21 or DHT22), defined by the &lt;code&gt;Dht::TypeEL&lt;/code&gt; enumeration. While the DHTxx sensors are using almost the same data encoding during the communication, there are also slight differences, which require special attention inside the library code. Explicitly, one of &lt;code&gt;Dht::TypeEL::DHT11&lt;/code&gt;, &lt;code&gt;Dht::TypeEL::DHT21&lt;/code&gt; or &lt;code&gt;Dht::TypeEL::DHT22&lt;/code&gt; can be used as the second parameter of the constructor, depending on your sensor choice.&lt;/p&gt;

&lt;pre&gt;
&lt;strong&gt;#include &amp;lt;dhtxx.h&amp;gt;&lt;/strong&gt;
#define DHT_PIN 7

&lt;strong&gt;Dht dht(DHT_PIN, Dht::TypeEL::DHT22);&lt;/strong&gt;
&lt;/pre&gt;

&lt;p&gt;Since we like to see the read temperature and humidity values, we&#039;ll use the Arduino serial communication capabilities, in combination with the Arduino IDE serial monitor tool, which you can open by using the &quot;Tools &amp;gt; Serial Monitor&quot; menu. This additional code is only required for being able to visualize the information, but has nothing to do with the sensor, or sensor communication. The DHTxx sensor requires some initialization time, which is usually about two seconds, thus a delay of two seconds is added in the &lt;code&gt;setup&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;
void setup() {  
  Serial.begin(115200);
  delay(2000);
};
&lt;/pre&gt;

&lt;p&gt;Last, we use the &lt;code&gt;Dht::read&lt;/code&gt; method, to inquire temperature and humidity information from the sensor. A &lt;code&gt;Result&lt;/code&gt; structure is provided in return, and it has three properties: temperature, humidity and status, which should be &lt;code&gt;Dht::StatusEL::OK&lt;/code&gt; if no communication errors took place. We use a delay of five seconds between two readings.&lt;/p&gt;

&lt;pre&gt;
void loop() {
  &lt;strong&gt;Dht::Result result = dht.read();&lt;/strong&gt;
  if (result.status == Dht::StatusEL::OK) {
    Serial.print(&quot;Temperature: &quot;);
    Serial.println(result.temperature);
    Serial.print(&quot;Humidity: &quot;);
    Serial.println(result.humidity);
  } else if (result.status == Dht::StatusEL::CRC_ERROR) {
    Serial.println(&quot;CRC error! &quot;);
  } else {
    Serial.println(&quot;Timeout error! &quot;);
  }
  delay(5000);
};
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; DHTxx sensors can be read no faster than once every two seconds. Not following this rule results in no communication with the sensor or communication timeouts.&lt;/p&gt;

&lt;p&gt;If all went well, and you have used an DHT21 or DHT22 sensor, you should see the &lt;em&gt;Serial Monitor&lt;/em&gt; window showing information similar with &lt;a href=&quot;#fig5&quot;&gt;Figure 5&lt;/a&gt;. One can observe slight differences between readings (like 0.2°C between the temperature values), but that is just fine, and are the result of the sensor accuracy.&lt;/p&gt;

&lt;figure id=&quot;fig5&quot;&gt;&lt;img alt=&quot;Serial Monitor Showing DHTxx Sensor Readings&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/Serial-Monitor-DHTxx.png&quot; /&gt;
&lt;figcaption&gt;Figure 5: Serial Monitor Showing DHTxx Sensor Readings.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;If you are interested in more information about the low level communication with the DHTxx sensor, then you should have a look at the DHTxx library code (files &lt;code&gt;DHTxx.h&lt;/code&gt; and &lt;code&gt;DHTxx.cpp&lt;/code&gt;) which contains detailed code comments. Also, check the information provided in the &lt;a href=&quot;https://github.com/dimircea/Arduino/tree/master/libraries/DHTxx&quot;&gt;DHTxx library github project page&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Measure Distance with HC-SR04 Ultrasonic Sensor&lt;/h3&gt;

&lt;p&gt;In multiple projects, measuring distance is an important aspect. Imagine a &quot;self-driving&quot; robot (or car) project, where detecting obstacles, thus measuring distance between the robot and any possible nearby objects, is one of the main tasks. Fortunately there is a easy and cheap way to achieve this, with the help of an ultrasonic based distance measurement sensor, such as HC-SR04, shown in &lt;a href=&quot;#fig6&quot;&gt;Figure 6&lt;/a&gt;. These sensors uses high frequency sound pulses (40KHz or more) and measure the time required by the sound to travel forth, and back if it is bounced by an nearby obstacle. Internally, a timeout is used to detect if an object exists or not in the sensor range (which for HC-SR04 is about 4m). In &lt;a href=&quot;#table2&quot;&gt;Table 2&lt;/a&gt; are shown the main characteristics of a HC-SR04 sensor.&lt;/p&gt;

&lt;p&gt;Variations of this sensor, using the UART communication interface (i.e., HC-SR03) can be found on the market. Usually, they are more expensive (the price is double or more), and the communication protocol required to communicate with such a sensor, especially RAM resources, are higher.&lt;/p&gt;

&lt;p&gt;HC-SR04 sensors are fairly low priced, and in EU you can buy one for as low as 3EUR including postage. If you are willing to wait up to six weeks, it is possible to buy such sensors from China (e.g., by using &lt;a href=&quot;http://www.ebay.com/sch/i.html?_nkw=hc-sr04&quot;&gt;eBay&lt;/a&gt;) for about 1EUR per piece, including postage.&lt;/p&gt;

&lt;table id=&quot;table2&quot;&gt;
	&lt;caption&gt;Table 2: HC-SR04 sensor characteristics.&lt;/caption&gt;
	&lt;thead&gt;
		&lt;tr&gt;
			&lt;th&gt;Range&lt;/th&gt;
			&lt;th&gt;Detection Angle&lt;/th&gt;
			&lt;th&gt;Accuracy&lt;/th&gt;
			&lt;th&gt;Resolution&lt;/th&gt;
			&lt;th&gt;Operating voltage&lt;/th&gt;
			&lt;th&gt;Operating current&lt;/th&gt;
		&lt;/tr&gt;
	&lt;/thead&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;[2, 400]cm&lt;/td&gt;
			&lt;td&gt;30 degrees&lt;/td&gt;
			&lt;td&gt;3mm&lt;/td&gt;
			&lt;td&gt;1mm&lt;/td&gt;
			&lt;td&gt;[4.5, 5.5]V&lt;/td&gt;
			&lt;td&gt;[12, 18]mA&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td colspan=&quot;6&quot; style=&quot;text-align:center; font-weight: bold;&quot;&gt;&lt;a href=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/HC-SR04.pdf&quot;&gt;Download datasheet&lt;/a&gt;&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;figure id=&quot;fig6&quot;&gt;&lt;img alt=&quot;HC-SR04 Sensor&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/HC-SR04.png&quot; /&gt;
&lt;figcaption&gt;Figure 6: HC-SR04 Sensor.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4&gt;Hardware Configuration&lt;/h4&gt;

&lt;p&gt;Connecting the Arduino board with the HC-SR04 sensor is really easy. First, you&#039;ll need to provide power to the VCC and GND pins. Second, chose two Arduino pins (use digital ones while the analog pins we need for other purposes) to be used in the communication with the sensor. One pin represents the &quot;trigger&quot;, informing the sensor that we like to read the distance, and the other one represents the output from sensor, also known as &quot;echo&quot;, providing a pulse of a specified length, mapped then to a distance value.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;#fig7&quot;&gt;Figure 7&lt;/a&gt; is shown how to wire the sensor to an Arduino UNO board, but the same apply to almost any other Arduino boards. &lt;a href=&quot;#fig8&quot;&gt;Figure 8&lt;/a&gt; shows the electrical diagram of the circuit.&lt;/p&gt;

&lt;figure id=&quot;fig7&quot;&gt;&lt;img alt=&quot;HC-SR04 Sensor Connected to an Arduino UNO Board&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/Fritzing-HCSR04-breadboard.png&quot; /&gt;
&lt;figcaption&gt;Figure 7: HC-SR04 Sensor Connected to an Arduino UNO Board.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure id=&quot;fig8&quot;&gt;&lt;img alt=&quot;Circuit Diagram of a HC-SR04Sensor Connected to an Arduino UNO Board&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/Fritzing-HCSR04-schematics.png&quot; /&gt;
&lt;figcaption&gt;Figure 8: Circuit Diagram of a HC-SR04Sensor Connected to an Arduino UNO Board.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4&gt;Software Configuration&lt;/h4&gt;

&lt;p&gt;Reading the distance with a HC-SR04 sensor requires to &lt;a href=&quot;https://github.com/dimircea/Arduino/tree/master/libraries/HCSR04&quot;&gt;download from github&lt;/a&gt; and import the HCSR04 into your Arduino IDE. For this, you&#039;ll need to copy the folder &lt;code&gt;HCSR04&lt;/code&gt; into your &lt;code&gt;libraries&lt;/code&gt; sub-folder of the Arduino installation folder. If the Arduino IDE was started before, you have now to close it and start it again.&lt;/p&gt;

&lt;p&gt;Use the #include directive to &quot;load&quot; the library into your Arduino sketch. Create an instance of the HCSR04 class, which takes care of the communication with the sensor. The constructor has two parameters: the pin number used to inform the sensor that we want to read the distance, known as the &lt;em&gt;trigger pin&lt;/em&gt; (the Arduino UNO digital pin 7 in our case), and the pin number used to read the sensor response, known as the &lt;em&gt;echo pin&lt;/em&gt; (the Arduino UNO digital pin 5 in our example).&lt;/p&gt;

&lt;pre&gt;
&lt;strong&gt;#include &amp;lt;HCSR04.h&amp;gt;&lt;/strong&gt;
#define TRIGGER_PIN 6
#define ECHO_PIN 5

&lt;strong&gt;HCSR04 hcsr04(TRIGGER_PIN, ECHO_PIN);&lt;/strong&gt;

&lt;/pre&gt;

&lt;p&gt;Since we want to test the sensor and check the distance it reads, we&#039;ll use the Arduino serial communication capabilities, in combination with the Arduino IDE serial monitor tool (use the &quot;Tools &amp;gt; Serial Monitor&quot; menu) to show the sensor readings. This additional code is only required for being able to visualize the information, but has nothing to do with the sensor, or sensor communication. The HC-SR04 sensor requires some initialization time, which is usually about one second, thus a delay of one second is added in the setup method.&lt;/p&gt;

&lt;pre&gt;
void setup() { 
  // Start serial communication, used to show 
  // sensor data in the Arduino serial monitor. 
  Serial.begin(115200); 
  // Wait for the HCSR04 sensor to settle. 
  // This usually needs about one second... 
  delay(1000); 
};&lt;/pre&gt;

&lt;p&gt;Use the &lt;code&gt;HC-Sr04::read&lt;/code&gt; method, to inquire distance measurement from the sensor. By default, the distance is measured in centimeters. If you need the distance in millimeters, meters or kilometers, use the &lt;code&gt;HCSR04::read(HCSR04::MetricsEL::xx)&lt;/code&gt; method instead. The value of the parameter can be one of: &lt;code&gt;HCSR04::MetricsEL::mm&lt;/code&gt;, &lt;code&gt;HCSR04::MetricsEL::cm&lt;/code&gt; (default), &lt;code&gt;HCSR04::MetricsEL::m&lt;/code&gt; or &lt;code&gt;HCSR04::MetricsEL::km&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;
void loop() {
  &lt;strong&gt;float distance = hcsr04.read();&lt;/strong&gt;
  if (distance &amp;gt; 0) {
    Serial.println(distance);
  } else {
    Serial.println(&quot;Error reading the sensor!&quot;);
  }
  // continuously read the sensor, ~10 times/s
  // Note: may be much less than ~10 times/s because reading
  // the sensor and checking the timeout may take up to 50ms
  delay(100);
};&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; while in theory you can make hundreds of readings per second with this sensor, the practice learn us that you can take under ten reliable readings every second second. This is due to Arduino capabilities but also to sensor internals, driven by another micro-controller.&lt;/p&gt;

&lt;p&gt;If all went well, you should see the &lt;em&gt;Serial Monitor&lt;/em&gt; window showing information similar with &lt;a href=&quot;#fig9&quot;&gt;Figure 9&lt;/a&gt;.&lt;/p&gt;

&lt;figure id=&quot;fig9&quot;&gt;&lt;img alt=&quot;Serial Monitor Showing HC-SR04 Sensor Readings&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/Serial-Monitor-HCSR04.png&quot; /&gt;
&lt;figcaption&gt;Figure 9: Serial Monitor Showing HC-SR04 Sensor Readings.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;If we&#039;ve got your attention and you want to know more about how exactly the software communicates with the sensor and maps the detected pulse length into a distance value, please have a look at the library code which is commented in the smallest details.&lt;/p&gt;

&lt;h2&gt;Analog Sensors&lt;/h2&gt;

&lt;p&gt;Analog sensors provide information about the measured quality as a voltage level, or other equivalent form, e.g., resistance of current. Using various electronics laws and equations we can interpret these values as a quantity of the measured quality. Examples of such sensors are photo resistors, rain or soil moisture sensors, providing the information into the form of &quot;resistance&quot;. Other sensors, such as LM35 analog temperature sensor, directly provides a voltage level that can be translated into temperature value using a liner function.&lt;/p&gt;

&lt;h3&gt;Measure Temperature with LM35 Analog Sensor&lt;/h3&gt;

&lt;p&gt;LM35 sensor, shown in &lt;a href=&quot;#fig10&quot;&gt;Figure 10&lt;/a&gt;, is a very cheap way (it costs under one EUR for one piece) to measure the environment temperature, used in combination with any device that is able to read voltage in the millivolts range. That means, we can even use a multi-meter (a device able to measure voltage, resistance, current, etc) to measure the temperature, without the need of having an additional micro-controller. However, in this tutorial we show how to use an Arduino UNO to do the measurement. These sensors comes in multiple variations, from which the most known is LM35DZ. &lt;a href=&quot;#table3&quot;&gt;Table 3&lt;/a&gt; shows the most important characteristics. Other versions are different in ranges, accuracy or supply voltage values.&lt;/p&gt;

&lt;figure id=&quot;fig10&quot;&gt;&lt;img alt=&quot;LM35DZ Analog Sensor&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/LM35DZ.png&quot; /&gt;
&lt;figcaption&gt;Figure 10: LM35DZ Analog Sensor.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;table id=&quot;table3&quot;&gt;
	&lt;caption&gt;Table 2: LM35DZ Sensor Characteristics.&lt;/caption&gt;
	&lt;thead&gt;
		&lt;tr&gt;
			&lt;th&gt;Range&lt;/th&gt;
			&lt;th&gt;Accuracy&lt;/th&gt;
			&lt;th&gt;Resolution&lt;/th&gt;
			&lt;th&gt;Operating voltage&lt;/th&gt;
			&lt;th&gt;Operating current&lt;/th&gt;
		&lt;/tr&gt;
	&lt;/thead&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;[-40, 110]°C&lt;/td&gt;
			&lt;td&gt;±0.25°C&lt;/td&gt;
			&lt;td&gt;0.2°C (= 2mV Output)&lt;/td&gt;
			&lt;td&gt;[-0.2, 35]V&lt;/td&gt;
			&lt;td&gt;[60, 100]µA&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td colspan=&quot;5&quot; style=&quot;text-align:center; font-weight: bold;&quot;&gt;&lt;a href=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/LM35DZ.pdf&quot;&gt;Download datasheet&lt;/a&gt;&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The linear function used to translate sensor output voltage in °C of temperature is: &lt;code&gt;f(x) = 100x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is the sensor voltage output in volts and &lt;code&gt;f(x)&lt;/code&gt; is the temperature in °C. In other words, for every 1°C, the output voltage of this sensor is 10mV, e.g., 220mV output means a temperature value of 22°C.&lt;/p&gt;

&lt;h4&gt;Hardware Configuration&lt;/h4&gt;

&lt;p&gt;Connecting a LM35 sensor to Arduino UNO is very simple, as shown in &lt;a href=&quot;#fig11&quot;&gt;Figure 11&lt;/a&gt;. Just connect the VCC pin to 5V (obtained from Arduino UNO 5V pin), the GND pin to Arduino UNO ground and the output pin to one of the analog pins of the Arduino UNO board, annotated with A0...A5. In our example, we use A0. No additional components are required. &lt;a href=&quot;#fig12&quot;&gt;Figure 12&lt;/a&gt; shows the schematics of the circuit.&lt;/p&gt;

&lt;figure id=&quot;fig11&quot;&gt;&lt;img alt=&quot;LM35 Sensor Connected to an Arduino UNO Board.&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/Fritzing-LM35-breadboard.png&quot; /&gt;
&lt;figcaption&gt;Figure 11: LM35 Sensor Connected to an Arduino UNO Board.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure id=&quot;fig12&quot;&gt;&lt;img alt=&quot;Circuit Diagram of a LM35 Sensor Connected to an Arduino UNO Board.&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/Fritzing-LM35-schematics.png&quot; /&gt;
&lt;figcaption&gt;Figure 12: Circuit Diagram of a LM35 Sensor Connected to an Arduino UNO Board.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4&gt;Software Configuration&lt;/h4&gt;

&lt;p&gt;Ardunio UNO and most of the arduino boards comes with a feature known as ADC: Analog to Digital Converter. That is, connecting a voltage source to one of the ADC capable pins, we can measure the applied voltage value.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; you should NOT try to measure voltages over VCC, so 5V in our case, with any ADC pin, because you&#039;ll burn your Arduino micro-controller. Also when using a 3.3V Arduino board, the maximum measurable voltage value with any ADC pin is 3.3V.&lt;/p&gt;

&lt;p&gt;First, we&#039;ll define the pin used to read the sensor. Analog pins can be refereed in an Arduino program with Ax (e.g., A0 or A3), and corresponds to the notation you see on your Arduino PCB board.&lt;/p&gt;

&lt;pre&gt;
#define LM35DZ_PIN A0
&lt;/pre&gt;

&lt;p&gt;We like to be able to see the sensor output, and for that we use the Arduino serial monitor feature. Some settle time is welcome for the LM35DZ sensor to adapt to the power supply and environment, and we allow it do do so for about one second (more is required if the temperature variation is larger than a few degrees).&lt;/p&gt;

&lt;pre&gt;
void setup() {
  Serial.begin(115200);
  delay(1000);
}
&lt;/pre&gt;

&lt;p&gt;Further, we can read the pin output by using the &lt;code&gt;analogRead&lt;/code&gt; method, which takes as parameter the used pin number, e.g., A0, expressed by LM35DZ_PIN. However, this method returns a number between 0 and 1023 for our Ardunio UNO. This is due to the fact that Arduino UNO ADC unit uses 10 bits to represent data, thus values from 0 to 1023. The question is now: how do we translate this number to the read voltage value?&lt;/p&gt;

&lt;p&gt;An ADC unit uses a reference voltage for measurements. By default, in most of the Arduino boards, including Arduino UNO, this is VCC (i.e., 5V). It means, that we have a range of [0, 5]V (or [GND, VCC]V) represented with integers in the range [0, 1023], therefore 1024 total values. In conclusion, one ADC unit is: &lt;code&gt;1U = 5 / 1024 ≈ 0.00488&lt;/code&gt;. For example, if &lt;code&gt;analogRead&lt;/code&gt; returns a value of 237, this represents &lt;code&gt;237 * 0.00488V ≈ 1.155V&lt;/code&gt;. Using this, we can now obtain the temperature value, knowing that our LM35DZ sensor has an output of 0.01V (10mV) for every °C: &lt;code&gt;temperature = adcUnits * 0.00488 * 100&lt;/code&gt;. Using Arduino code, that is:&lt;/p&gt;

&lt;pre&gt;
void loop() {
  uint16_t adcUnits = analogRead(LM35DZ_PIN);
  float temperature = adcUnits * 0.00488 * 100;
  Serial.print(&quot;Temperature: &quot;);
  Serial.println(temperature);
}
&lt;/pre&gt;

&lt;p&gt;Dealing with ADC units requires attention, and following the below two rules helps in obtaining stable readings:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Read the datasheet and check the minimum interval between two ADC readings. For Arduino UNO the ADC clock works at 125KHz and one ADC conversion requires 13 clocks. Therefore, the reading can be done with a frequency of about 9600Hz, so about 9600 times per second, which means one reading every 100µS.&lt;/li&gt;
	&lt;li&gt;There are a multitude of factors affecting the ADC readings, such as temperature, magnetic waves, voltage stability and so on. Therefore is good to average a set of readings and use these as the &quot;absolute&quot; read value. For our example, it will be appropriate to average at least 10 samples before considering a temperature value.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Following the above presented rules, we obtain the code below:&lt;/p&gt;

&lt;pre&gt;

void loop() {
  uint8_t i = 0;
  uint16_t adcUnits = 0;
  float temperature  = 0;
  for (i = 0; i &amp;lt; 9; i++) {
    adcUnits = analogRead(LM35DZ_PIN);
    temperature += adcUnits * 0.00488 * 100;
  }
  temperature /= 10;
  Serial.print(&quot;Temperature: &quot;);
  Serial.println(temperature);
  
  delay(5000);
}
&lt;/pre&gt;

&lt;p&gt;The new version of this code provides repeatable results within 0.2°C, while the first version can only provide repeatable results within 0.5°C. If all went fine, you should see the &lt;em&gt;Serial Monitor&lt;/em&gt; window showing information similar with &lt;a href=&quot;#fig13&quot;&gt;Figure 13&lt;/a&gt;&lt;/p&gt;

&lt;figure id=&quot;fig13&quot;&gt;&lt;img alt=&quot;Serial Monitor Showing LM35DZ Sensor Readings&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/Serial-Monitor-LM35.png&quot; /&gt;
&lt;figcaption&gt;Figure 13: Serial Monitor Showing LM35DZ Sensor Readings.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3&gt;Measure Light Intensity with a Photo Resistor&lt;/h3&gt;

&lt;p&gt;A photo-resistor is a special type of resistor which change its value based on the ambient light intensity. Usually, these resistors have specified values for &quot;complete dark&quot; and &quot;extreme light&quot;, and normally the datasheet presents a mapping function allowing to transform a resistance value into a luminous emittance value (measured in LUX).&lt;/p&gt;

&lt;p&gt;In this tutorial we discus about VT93N1 photo-resistor, fairly easy to use and with a low price of about 1EUR for one piece, EU postage included. Being a resistor, it can be mounted either way in a circuit. &lt;a href=&quot;#fig14&quot;&gt;Figure 14&lt;/a&gt; shows the pyhsical shape of a VT93N1 photo-resistor. In &lt;a href=&quot;#table4&quot;&gt; Table 4&lt;/a&gt; are shown the most important characteristics of the VT93N1 sensor.&lt;/p&gt;

&lt;table id=&quot;table4&quot;&gt;
	&lt;caption&gt;Table 4: VT93N1 Photo Resistor Characteristics.&lt;/caption&gt;
	&lt;thead&gt;
		&lt;tr&gt;
			&lt;th&gt;Range&lt;/th&gt;
			&lt;th&gt;Accuracy&lt;/th&gt;
			&lt;th&gt;Resolution&lt;/th&gt;
			&lt;th&gt;Adaptation time&lt;/th&gt;
			&lt;th&gt;Operating voltage&lt;/th&gt;
			&lt;th&gt;Max. power dissipation&lt;/th&gt;
		&lt;/tr&gt;
	&lt;/thead&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;[12, 300]kΩ&lt;/td&gt;
			&lt;td&gt;±20%&lt;/td&gt;
			&lt;td&gt;1Ω&lt;/td&gt;
			&lt;td&gt;min. 5 seconds&lt;/td&gt;
			&lt;td&gt;[-60, 60]V&lt;/td&gt;
			&lt;td&gt;80mW&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td colspan=&quot;6&quot; style=&quot;text-align:center; font-weight: bold;&quot;&gt;&lt;a href=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/VT93N1.pdf&quot;&gt;Download datasheet&lt;/a&gt;&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;figure id=&quot;fig14&quot;&gt;&lt;img alt=&quot;VT93N1 Photo Resistor&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/VT93N1.png&quot; /&gt;
&lt;figcaption&gt;Figure 14: VT93N1 Photo Resistor.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;It is possible to measure a resistor, thus a photo-resistor too, by using various techniques such as:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Use a constant current source, measure the dropout voltage over the resistor, then use Ohm&#039;s law to compute the resistance: &lt;code&gt;R = V / I&lt;/code&gt;, where R is the resistance in ohms we want to measure, V is the dropout voltage in volts across the resistor, and I is the applied constant current value in Amperes.&lt;/li&gt;
	&lt;li&gt;Use a voltage divider with another precision resistor, for which the resistance value is already known. Apply a known voltage across the end of the resistor network and measure the voltage drop across the resistor with the known value. The equation which applies is: &lt;code&gt;V_across_R2 = R2 * V_input / (R1 + R2)&lt;/code&gt;. We solve this for R1, that is the resistance we are interested in: &lt;code&gt;R1 = R2 * (V_input / V_across_R2 - 1)&lt;/code&gt;. Therefore, if we know the applied voltage to the circuit, the value of the fixed R2 resistor, and we measure the voltage drop across R2, we can easily compute the value of R1, measured in ohms.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In our case, since we don&#039;t have a constant current source, but we can use a resistor of a known value, the second method is used, as shown in &lt;a href=&quot;#fig15&quot;&gt;Figure 15&lt;/a&gt;, respectively &lt;a href=&quot;#fig16&quot;&gt;Figure 16&lt;/a&gt;. However, we&#039;ll use the Arduino UNO ADC capabilities to replace the voltmeter, as we learned earlier in this tutorial.&lt;/p&gt;

&lt;figure id=&quot;fig15&quot;&gt;&lt;img alt=&quot;Measure Resistance Using a Voltmeter.&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/Fritzing-Resistor-Divider-breadboard.png&quot; /&gt;
&lt;figcaption&gt;Figure 15: Measure Resistance Using a Voltmeter.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure id=&quot;fig16&quot;&gt;&lt;img alt=&quot;Circuit Diagram for Measuring Resistance Using a Voltmeter.&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/Fritzing-Resistor-Divider-schematics.png&quot; /&gt;
&lt;figcaption&gt;Figure 16: Circuit Diagram for Measuring Resistance Using a Voltmeter.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4&gt;Hardware Configuration&lt;/h4&gt;

&lt;p&gt;For being able to measure the luminous flux, we need to measure the resistance of the VT93N1 photo resistor, then use a formula to map this to the corresponding LUX value. In &lt;a href=&quot;#fig17&quot;&gt;Figure 17&lt;/a&gt; is shown how to connect the VT93N1 photo resistor to an Arduino UNO board, and for more details, in &lt;a href=&quot;#fig18&quot;&gt;Figure 18&lt;/a&gt; the circuit diagram is also shown.&lt;/p&gt;

&lt;figure id=&quot;fig17&quot;&gt;&lt;img alt=&quot;VT93N1 Sensor Connected to an Arduino UNO Board.&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/Fritzing-VT93N1-breadboard.png&quot; /&gt;
&lt;figcaption&gt;Figure 17: VT93N1 Sensor Connected to an Arduino UNO Board.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure id=&quot;fig18&quot;&gt;&lt;img alt=&quot;Circuit Diagram of a VT93N1 Sensor Connected to an Arduino UNO Board.&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/Fritzing-VT93N1-schematics.png&quot; /&gt;
&lt;figcaption&gt;Figure 18: Circuit Diagram of a VT93N1 Sensor Connected to an Arduino UNO Board.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Due to the relatively low accuracy of the VT93N1 sensor and also because of the high variations of light in a real environment, it is possible to obtain relatively high fluctuations, even if looks to be no change in the light, as perceived by the human eyes. This is relative, and for being able to characterize the performance of your sensor, a higher accuracy LUX-meter device may be required.&lt;/p&gt;

&lt;p&gt;Without an initial calibration, using a high precision LUX-meter, the error factor may be as high as 20%. This can be reduced to about 5-10%, when using high precision resistors with a well known value, a good voltmeter for initial voltage drop measurements and a high precision LUX-meter. However, this is only needed if you&#039;ll need to use this sensor for sensitive projects. To detect if is getting dark in a room, so a light turns on automatically, or to check if some plants have enough light in their current location (plants can tolerate high light variations) this cheap sensor even without any initial calibration is sufficient.&lt;/p&gt;

&lt;h4&gt;Software Configuration&lt;/h4&gt;

&lt;p&gt;We deal with an analog devices, that point us in using an analog pin of our Arduino UNO board, e.g., pin A1 for this example.&lt;/p&gt;

&lt;pre&gt;
#define VT93N1_PIN A1
&lt;/pre&gt;

&lt;p&gt;As in all our examples, we use the Arduino serial monitor to show sensor data. In addition, the sensor datasheet tells us that at least 5 seconds are needed for having the sensor adapted to the environmental light, so a 5 seconds delay is used at startup.&lt;/p&gt;

&lt;pre&gt;
void setup() {
  Serial.begin(115200);
  delay(5000);
}
&lt;/pre&gt;

&lt;p&gt;Since the datasheet does not provide a mapping function to transform a resistance value into a LUX value, we&#039;ll need to use our friend Google, which soon provide us with an response. The formula we can use is: &lt;code&gt;E = 341.64 / R^(10 / 9)&lt;/code&gt;, where E is the luminous emittance in LUX, and R is the resistance in kΩ (kilo ohms).&lt;/p&gt;

&lt;pre&gt;
void loop() {
  double vAcrossR2 = 0, r1 = 0, luxValue = 0,
         vInput = 5, r2 = 10000;
  
  // collect 10 samples and average to obtain stable value.
  for ( byte i = 0; i &amp;lt; 10; i++) {
    // read voltage from pin, in Volts
    vAcrossR2 += analogRead(VT93N1_PIN) * 0.00488;
  }
  vAcrossR2 = vAcrossR2 / 10.0;

  // calculate resistance r1 = 22 * (vInput / vAcrossR1 - 1)
  r1 = r2 * ( vInput / vAcrossR2 - 1);

  // convert resistance value to LUX value for this sensor based in formula:
  // E = 341.64 / R^(10 / 9), where R is measured in kOhm
  luxValue = 341.64 / pow( r1 / 1000.0, 10.0 / 9.0);

  Serial.print(&quot;LUX: &quot;);
  Serial.println(luxValue);

  delay(5000);
}&lt;/pre&gt;

&lt;p&gt;There are a few points in the code that requires explanations:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Computing the resistance is made as shown below in this tutorial, with respect to a voltage divider circuit, using the equation: &lt;code&gt;R1 = R2 * (V_input / V_across_R2 - 1)&lt;/code&gt;.&lt;/li&gt;
	&lt;li&gt;Ten samples of ADC readings are taken, to improve the stability.&lt;/li&gt;
	&lt;li&gt;The &lt;code&gt;pow&lt;/code&gt; method is used to calculate the exponential value: its first argument is the base and the second is the exponent.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If all went fine, you should see the Serial Monitor window showing information similar with &lt;a href=&quot;#fig19&quot;&gt;Figure 19&lt;/a&gt;.&lt;/p&gt;

&lt;figure id=&quot;fig19&quot;&gt;&lt;img alt=&quot;Serial Monitor Showing VT93N1 Sensor Readings.&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/Serial-Monitor-VT93N1.png&quot; /&gt;
&lt;figcaption&gt;Figure 19: Serial Monitor Showing VT93N1 Sensor Readings.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2&gt;Some Points of Attention&lt;/h2&gt;

&lt;p&gt;The examples from this tutorial show how to use the sensors with an Arduino UNO board. However, the same code and connections work with almost any other Arduino board. It is important to notice that some Arduino boards, such as Arduino DUE, use 3.3V as input (VCC = 3.3V). Therefore, you should use sensors that are able to receive power from a 3.3V source instead of 5V one. This is required for being able to directly connect sensor pins to Arduino pins without destroying your Arduino board.&lt;/p&gt;

&lt;p&gt;There are cases when we really want or need to use a 3.3V an Adruino board with a 5V powered sensor, or a 5V Arduino board with a 3.3V sensor. The solution for this problem is to use &lt;code&gt;voltage level converter&lt;/code&gt;. It is possible to build one by using small FETs (Field Effect Transistors) or by using voltage divider circuit (not the most recommended way, but still the cheapest and easiest) or you can simply buy a specially designed board which takes care of such tasks. In &lt;a href=&quot;#fig20&quot;&gt;Figure 20&lt;/a&gt; is shown such a ready to use small board that provides four I/O level converter pins from 3/3.3V to 5V and back. Such boards costs as less as 1-2€ per piece, postage in EU included (e.g., use &lt;a href=&quot;http://www.ebay.com/sch/i.html?_nkw=Level+Conversion+Module+5V-3V&quot;&gt;eBay&lt;/a&gt;).&lt;/p&gt;

&lt;figure id=&quot;fig20&quot;&gt;&lt;img alt=&quot;Two ways, four channels, 3.3V to 5V Voltage Level Converter&quot; src=&quot;http://web-engineering.info/sites/default/files/wot_tutorials/sensors/HV-LV-Converter.png&quot; /&gt;
&lt;figcaption&gt;Figure 20: Two ways, four channels, 3.3V to 5V Voltage Level Converter.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Another special attention has to be paid to the power supplyused for your project. Cheap ones comes usually with low regulation, that is, the maximum ±5% allowed tolerance is not really what we get, thus causing all kind of strange problems with your micro-controller, such as resets. This is even worst when using analog sensors, which are usually highly sensitive to voltage variation, and even a ±1% variation may reduce the accuracy to a few levels of magnitude. As a general advice, either use a high quality power source (that can be expensive for a DIY project!), or at least add a 0.1µF ceramic capacitor in parallel with a 100µF (or larger, up to 1000µF) electrolytic capacitor on the power supply line, before any other device in the circuit. This allows for high frequency (the small ceramic capacitor) and low frequency (the larger electrolytic capacitor) spikes filtering (at some level), thus improving the general behavior of the circuit.&lt;/p&gt;

&lt;h2&gt;Next Tutorial: Part 3 - WiFI Network Connection and Cloud Data Storage&lt;/h2&gt;

&lt;p&gt;In this tutorial we&#039;ll learn how to use an ESP8266 WiFi module (there are 13 or more different variations) to connect an Arduino based sensor node to network, and use free online services to store data for later analyze, or provide charts showing the evolution of the measured environment properties over time.&lt;/p&gt;

&lt;p&gt;The ESP8266 WiFI module is a cheap way to empower a device very limited in resources, such as the Arduino UNO board, with a standard 802.11g/b/n WiFi network connection, and allow it to communicate (as a client) with another devices, or services, by using standard HTTP/HTTPS protocols, i.e., GET, POST and PUT methods. In addition, custom UDP based communication is also possible when using ESP8266 WiFi module and the right firmware.&lt;/p&gt;

&lt;p&gt;Stay tuned, the release date is: before 10 May 2016.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;section class=&quot;field field-name-field-category field-type-taxonomy-term-reference field-label-above view-mode-rss&quot;&gt;&lt;h2 class=&quot;field-label&quot;&gt;Category:&amp;nbsp;&lt;/h2&gt;&lt;ul class=&quot;field-items&quot;&gt;&lt;li class=&quot;field-item even&quot;&gt;&lt;a href=&quot;/Arduino&quot; typeof=&quot;skos:Concept&quot; property=&quot;rdfs:label skos:prefLabel&quot; datatype=&quot;&quot;&gt;Arduino&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;field-item odd&quot;&gt;&lt;a href=&quot;/taxonomy/term/40&quot; typeof=&quot;skos:Concept&quot; property=&quot;rdfs:label skos:prefLabel&quot; datatype=&quot;&quot;&gt;WoT&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;field-item even&quot;&gt;&lt;a href=&quot;/taxonomy/term/43&quot; typeof=&quot;skos:Concept&quot; property=&quot;rdfs:label skos:prefLabel&quot; datatype=&quot;&quot;&gt;C/C++&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;field-item odd&quot;&gt;&lt;a href=&quot;/taxonomy/term/45&quot; typeof=&quot;skos:Concept&quot; property=&quot;rdfs:label skos:prefLabel&quot; datatype=&quot;&quot;&gt;Sensor&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;field-item even&quot;&gt;&lt;a href=&quot;/taxonomy/term/47&quot; typeof=&quot;skos:Concept&quot; property=&quot;rdfs:label skos:prefLabel&quot; datatype=&quot;&quot;&gt;Digital&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;field-item odd&quot;&gt;&lt;a href=&quot;/taxonomy/term/48&quot; typeof=&quot;skos:Concept&quot; property=&quot;rdfs:label skos:prefLabel&quot; datatype=&quot;&quot;&gt;Analog&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;div class=&quot;easy_social_box clearfix horizontal easy_social_lang_und&quot;&gt;
            &lt;div class=&quot;easy_social-widget easy_social-widget-twitter first&quot;&gt;&lt;a href=&quot;http://twitter.com/share&quot; class=&quot;twitter-share-button&quot;
data-url=&quot;https://web-engineering.info/node/61&quot;
data-count=&quot;horizontal&quot;
data-lang = &quot;en&quot;
data-via=&quot;&quot;
data-related=&quot;:Check it out!&quot;
data-text=&quot;WoT with Arduino for Beginners: Part 2 - Connecting to the Real World via Sensors&quot;&gt;Tweet&lt;/a&gt;&lt;/div&gt;
          &lt;div class=&quot;easy_social-widget easy_social-widget-facebook&quot;&gt;&lt;fb:like href=&quot;https://web-engineering.info/node/61&quot; send=&quot;true&quot; layout=&quot;button_count&quot; width=&quot;88&quot; show_faces=&quot;true&quot; action=&quot;like&quot; colorscheme=&quot;light&quot; font=&quot;&quot;&gt;&lt;/fb:like&gt;&lt;/div&gt;
          &lt;div class=&quot;easy_social-widget easy_social-widget-googleplus&quot;&gt;&lt;div class=&quot;g-plusone&quot; data-size=&quot;medium&quot; data-annotation=&quot;bubble&quot; data-href=&quot;https://web-engineering.info/node/61&quot;&gt;&lt;/div&gt;&lt;/div&gt;
          &lt;div class=&quot;easy_social-widget easy_social-widget-linkedin last&quot;&gt;&lt;script type=&quot;in/share&quot; data-url=&quot;https://web-engineering.info/node/61&quot; data-counter=&quot;right&quot;&gt;&lt;/script&gt;&lt;/div&gt;
  &lt;/div&gt; &lt;!-- /.easy_social_box --&gt;</description>
 <pubDate>Fri, 08 Apr 2016 09:41:02 +0000</pubDate>
 <dc:creator>mdiaconescu</dc:creator>
 <guid isPermaLink="false">61 at https://web-engineering.info</guid>
 <comments>https://web-engineering.info/node/61#comments</comments>
</item>
</channel>
</rss>
