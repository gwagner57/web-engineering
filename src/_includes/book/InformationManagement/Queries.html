<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="role-ebook-page" lang="de">
<!-- Mirrored from web-engineering.info/book/InformationManagement/Queries.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 21 Jul 2023 11:02:29 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head><meta charset="UTF-8" /><title>Chapter 8. Database Queries</title><link href="_res/pageNavigation.css" rel="stylesheet" type="text/css" /><link href="_res/ebook.css" rel="stylesheet" type="text/css" /><link href="_res/icons/index.html" type="inode/directory" /></head><body><header class="page-navigation"><table><tr><td class="page-navigation-to-first"><a href="InformationManagement.html"><span class="page-navigation-to-first-icon" title="Erste Seite
Information Management"></span></a></td><td class="page-navigation-to-previous"><a href="DataManipulation.html"><span class="page-navigation-to-previous-icon" title="Vorherige Seite
7.3. Inserting, Updating and Deleting Records"></span></a></td><td class="page-navigation-previous"><span>7.3. Inserting, Updating and Deleting Records</span></td><td class="page-navigation-current"><span>Chapter 8. Database Queries</span> <span class="page-navigation-current-page">(37 / 42)</span></td><td class="page-navigation-next"><span>Chapter 9. Database Design</span></td><td class="page-navigation-to-next"><a href="index-2.html"><span class="page-navigation-to-next-icon" title="Nächste Seite
Chapter 9. Database Design"></span></a></td><td class="page-navigation-to-last"><a href="_index.html"><span class="page-navigation-to-last-icon" title="Letzte Seite
Index"></span></a></td></tr></table></header><main><section class="role-chapter" id="Queries"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">8</span>. </span>Database Queries</h1><p>TO BE TRANSLATED...</p><p>Ein DBMS muss es ermöglichen, die in einer DB gespeicherten Informationen bei Bedarf wieder abzurufen. Dazu werden normalerweise DB-Anfragen formuliert, die ausdrücken, um welche Informationen es geht. In einem RDBMS geht es um Werte für bestimmte Attribute in bestimmten Tabellenzeilen. Diese Werte bilden die Antworten (bzw. die Antwortmenge), die das RDBMS bei der Verarbeitung einer Anfrage erzeugt. Da eine Antwort die Form eines Werte-Tupels hat, entspricht die erzeugte Antwortmenge einer Tabelle.</p><p>Um diesen Sachverhalt zu illustrieren, betrachten wir folgende RDB:</p><div style="display:flex"><table border="1"><thead><tr><th colspan="4">books</th></tr><tr><th><u>isbn</u></th><th>title</th><th>year</th><th>publisher</th></tr></thead><tbody><tr><td>006251587X</td><td>Weaving the Web</td><td>2000</td><td>Harper Business</td></tr><tr><td>0465026567</td><td>Gödel, Escher, Bach</td><td>1999</td><td>Basic Books</td></tr><tr><td>0465030793</td><td>I Am A Strange Loop</td><td>2000</td><td>Basic Books</td></tr><tr><td>0321312562</td><td>Database Systems</td><td>2005</td><td>Pearson International</td></tr></tbody></table><table border="1"><thead><tr><th colspan="2">publishers</th></tr><tr><th><u>name</u></th><th>address</th></tr></thead><tbody><tr><td>Basic Books</td><td>New York, USA</td></tr><tr><td>Pearson International</td><td>London, Great Britain</td></tr><tr><td>Harper Business</td><td>New York, USA</td></tr></tbody></table></div><p>Wenn nach Buchtitel, Verlag und Verlagsadresse aller erfassten Bücher, die im Jahr 2000 erschienen sind, gefragt wird, ergibt sich folgende Antwort-Tabelle:</p><table border="1"><thead><tr><th colspan="3">query results</th></tr><tr><th>title</th><th>publisher</th><th>address</th></tr></thead><tbody><tr><td>I Am A Strange Loop</td><td>Basic Books</td><td>New York, USA</td></tr><tr><td>Weaving the Web</td><td>Harper Business</td><td>New York, USA</td></tr></tbody></table><p>Diese Anfrage entspricht folgender SQL-Abfrage:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3</pre></td><td class="listing-lines"><pre id="Queries__listingQueryImplJoin" style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">SELECT title, publisher, address
FROM books, publishers
WHERE year = 2000 AND publisher = name</pre></td></tr></tbody></table><p>Diese Abfrage besteht aus drei Schritten:</p><ol><li>sie bildet eine <em>Produktverknüpfung</em> der beiden Tabellen <code>books</code> und <code>publishers</code> in der FROM-Klausel,</li><li>sie <em>selektiert</em> dann durch die WHERE-Klausel diejenigen Zeilen, die die Spaltengleichheitsbedingung <code>publisher = name</code> sowie die Spaltenwertbedingung <code>year = 2000</code> erfüllen, und</li><li><em>projiziert</em> schließlich durch die SELECT-Klausel die selektierten Zeilen auf die drei Attribute <code>title</code>, <code>publisher</code>, <code>address</code>.</li></ol><p>Die Abfrage wird also mit Hilfe der drei Tabellen-Operationen <em>Produkt</em>, <em>Selektion</em> und <em>Projektion</em> ausgewertet.</p><blockquote class="role-notice"><p>Wenn man eine SQL-Abfrage in MS Access eingibt und sie auswerten lässt, kann es sein, dass die Abfrage automatisch umgeschrieben wird. Insbesondere werden Attributnamen um Tabellennamen erweitert (wie z.B. &quot;books.title&quot; statt &quot;title&quot; ) und von Access reservierte Wörter (wie z.B. &quot;Name&quot;) werden in eckigen Klammern gesetzt. </p></blockquote><section><h4>Einfache Abfragen</h4><p>Eine einfache Abfrage setzt sich aus den drei SQL-Klauseln SELECT, FROM und WHERE zusammen, wobei sich die FROM-Klausel nur auf eine Tabelle bezieht, mit SELECT eine Projektion auf eine Teilmenge der Attribute (bzw. Spalten) und mit WHERE eine Selektion der resultierenden Zeilen mit Hilfe von einfachen Zeilenbedingungen vorgenommen wird. </p><p>Die allereinfachste Abfrage fragt nach dem Inhalt einer Tabelle, wie z.B. </p><figure class="role-example" id="Queries__lox__1"><figcaption><span class="role-label">Beispiel <span class="role-number">8-1</span>. </span>Welche Informationen gibt es über Bücher?</figcaption><div style="display:flex"><pre style="width:20em; height:2em">SELECT * FROM books</pre><table border="1"><thead><tr><th colspan="4">query results</th></tr><tr><th>isbn</th><th>title</th><th>year</th><th>publisher</th></tr></thead><tbody><tr><td>006251587X</td><td>Weaving the Web</td><td>2000</td><td>Harper Business</td></tr><tr><td>0465026567</td><td>Gödel, Escher, Bach</td><td>1999</td><td>Basic Books</td></tr><tr><td>0465030793</td><td>I Am A Strange Loop</td><td>2000</td><td>Basic Books</td></tr><tr><td>0321312562</td><td>Database Systems</td><td>2005</td><td>Pearson International</td></tr></tbody></table></div></figure><p>Hierbei werden in der SELECT-Klausel mit dem Wildcard-Symbol * alle Attribute berücksichtigt. Eine <em>Projektion, </em>also eine Einschränkung auf bestimmte Attribute, wird vermieden. Um das Abfrageresultat auf eine relevante Teilmenge der Attribute einzuschränken, muss in der SELECT-Klausel durch Aufzählung der interessierenden Attribute eine entsprechende Projektion vorgenommen werden, wie z.B. in folgender Abfrage:</p><figure class="role-example" id="Queries__lox__2"><figcaption><span class="role-label">Beispiel <span class="role-number">8-2</span>. </span>Erstelle eine Liste aller Bücher mit ISBN und Titel</figcaption><div style="display:flex"><pre style="width:20em; height:2em"><b>SELECT isbn, title</b> FROM books</pre><table border="1"><thead><tr><th colspan="2">query results</th></tr><tr><th>isbn</th><th>title</th></tr></thead><tbody><tr><td>006251587X</td><td>Weaving the Web</td></tr><tr><td>0465026567</td><td>Gödel, Escher, Bach</td></tr><tr><td>0465030793</td><td>I Am A Strange Loop</td></tr><tr><td>0321312562</td><td>Database Systems</td></tr></tbody></table></div></figure><p>Symbolisch kann eine Projektion einer der Tabelle <i>books</i> auf eine Teilmenge [isbn, title] ihrer Spalten folgendermaßen notiert werden:</p><div class="informalfigure">Proj( [isbn, title], <i>books</i>)</div><p>Um nach bestimmten Büchern zu suchen, muss eine <em>Selektionsbedingung</em> in einer WHERE-Klausel angegeben werden, wie z.B. </p><figure class="role-example" id="Queries__lox__3"><figcaption><span class="role-label">Beispiel <span class="role-number">8-3</span>. </span>Erstelle eine Liste aller Bücher (mit ISBN und Titel), die im Jahr 2000 erschienen sind</figcaption><div style="display:flex"><pre style="width:20em; height:5em">SELECT isbn, title 
FROM books
<b>WHERE year = 2000</b></pre><table border="1"><thead><tr><th colspan="2">query results</th></tr><tr><th>isbn</th><th>title</th></tr></thead><tbody><tr><td>006251587X</td><td>Weaving the Web</td></tr><tr><td>0465030793</td><td>I Am A Strange Loop</td></tr></tbody></table></div></figure><p>Elementare Selektionsbedingungen können nicht nur mit dem Gleicheitsprädikat, sondern auch mit anderen Vergleichsprädikaten (&lt;, &gt;, !=, etc.) sowie mit dem Intervall-Prädikat <b>BETWEEN</b> und dem String-Muster-Prädikat <b>LIKE</b> gebildet werden. Z.B. verlangt die Bedingung<code> price BETWEEN 10 AND 20</code>, dass der Wert des Attributs <code>price</code> zwischen 10 und 20 (inklusive) liegt. Die Bedingung<code> title LIKE '%and%' </code>verlangt, dass der Wert des Attributs <code>title</code> den Teilstring 'and' enthält. Dabei ist '%' ein Wildcard-Symbol für irgendeinen String (in MS Access wird anstatt dem Symbol '%' das gängugere Wildcard-Symbol '*'.sowie '?' anstatt '_' für ein einzelnes beliebiges Zeichen verwendet).</p><p>Symbolisch kann eine Selektion der Tabelle <i>books</i> mit einer Selektionsbedingung year=2000 folgendermaßen notiert werden:</p><div class="informalfigure">Sel( year = 2000, <i>books</i>)</div><p>Die Kombination einer Projektion und einer Selektion kann folgendermaßen notiert werden:</p><div class="informalfigure">Proj( [isbn, title], Sel( year = 2000, <i>books</i>))</div><p>Die Zeilen einer Ergebnistabelle können mit einer ORDER-BY-Klausel sortiert werden, wie im nächsten Abfragebeispiel gezeigt wird.</p><figure class="role-example" id="Queries__lox__4"><figcaption><span class="role-label">Beispiel <span class="role-number">8-4</span>. </span>Erstelle eine nach Titel geordnete Liste aller Bücher (mit ISBN und Titel), die im Jahr 2000 erschienen sind</figcaption><div style="display:flex"><pre style="width:20em; height:5em">SELECT isbn, title 
FROM books 
WHERE year = 2000
<b>ORDER BY title</b></pre><table border="1"><thead><tr><th colspan="2">query results</th></tr><tr><th>isbn</th><th>title</th></tr></thead><tbody><tr><td>0465030793</td><td>I Am A Strange Loop</td></tr><tr><td>006251587X</td><td>Weaving the Web</td></tr></tbody></table></div></figure><p>Wenn die Sortierung in <em>absteigender</em> Reihenfolge erfolgen soll, ist das Schlüsselwort <b>DESC</b> an die ORDER-BY-Klausel anzuhängen, wie in<code> ORDER BY title DESC</code>.</p></section><section><h4>Statistische Abfragen</h4><p>Wir erweitern die oben präsentierte Tabelle <i>books</i> durch Hinzufügung einer Spalte <code>price</code> für den Buchpreis:</p><table border="1"><thead><tr><th colspan="5">books</th></tr><tr><th><u>isbn</u></th><th>title</th><th>year</th><th>price</th><th>publisher</th></tr></thead><tbody><tr><td>006251587X</td><td>Weaving the Web</td><td>2000</td><td>16.00</td><td>Harper Business</td></tr><tr><td>0465026567</td><td>Gödel, Escher, Bach</td><td>1999</td><td>17.99</td><td>Basic Books</td></tr><tr><td>0465030793</td><td>I Am A Strange Loop</td><td>2000</td><td>14.99</td><td>Basic Books</td></tr><tr><td>0321312562</td><td>Database Systems</td><td>2005</td><td>60.00</td><td>Pearson International</td></tr></tbody></table><p>Immer wenn wir derartige Daten haben, kann es sein, dass wir gewisse Statistiken aus ihnen gewinnen wollen:</p><ol><li>Wie viele Bücher gibt es pro Verlag?</li><li>Was ist das Erscheinungsjahr des ältesten Buchs in der Datenbank?</li><li>Was ist der Durchschnittspreis der Bücher des Verlags Basic Books?</li></ol><p>Diese drei Beispiele statistischer Anfragen werden in den folgenden SQL-Abfragen ausgedrückt. </p><figure class="role-example" id="Queries__lox__5"><figcaption><span class="role-label">Beispiel <span class="role-number">8-5</span>. </span>Statistische Anfrage 1: Wieviele Bücher gibt es pro Verlag?</figcaption><div style="display:flex"><pre style="width:20em; height:5em">SELECT publisher, <b>COUNT</b>(*) <b>AS</b> nmr_of_books 
FROM books
<b>GROUP BY</b> publisher</pre><table border="1"><thead><tr><th colspan="2">query results</th></tr><tr><th>publisher</th><th>nmr_of_books</th></tr></thead><tbody><tr><td>Harper Business</td><td>1</td></tr><tr><td>Basic Books</td><td>2</td></tr><tr><td>Pearson International</td><td>1</td></tr></tbody></table></div></figure><p>Bei dieser Abfrage werden drei noch nicht behandelte SQL-Elemente verwendet:</p><ol><li>Die <b>COUNT</b>-Aggregatfunktion mit dem Wildcard-Symbol * als Argument bestimmt die Anzahl von Zeilen. Da in dieser Abfrage die Ergebnistabelle gruppiert ist, wird die Zeilenanzahl pro Gruppe ermittelt. Wenn als Argument ein Attribut angegeben ist, wird die Anzahl von Zeilen mit einem Wert für das Attribut (genauer gesagt, mit einem von NULL verschiedenen Attributwert) ermittelt.</li><li>Mit Hilfe von <b>AS</b> kann ein Attribut in der Ergebnistabelle mit einem anderen Spaltentitel ausgegeben oder ein Spaltentitel für einen berechneten Ausdruck definiert werden.</li><li>Die <b>GROUP</b>-<b>BY</b>-Klausel erlaubt es, Zeilen in der Ergebnistabelle nach einem (oder mehreren) Attribut(en) zu gruppieren und für eine Gruppe nur eine Ergebniszeile zu erzeugen. In der SELECT-Klausel einer GROUP-BY-Abfrage können außer Berechnungsausdrücken nur solche Attribute angegeben werden, die auch in der GROUP-BY-Klausel angegeben sind.</li></ol><p>Um das Erscheinungsjahr des ältesten Buchs zu ermitteln, kann nach der minimalen Jahreszahl mit Hilfe der Aggregatfunktion <b>MIN</b> gesucht werden:</p><figure class="role-example" id="Queries__lox__6"><figcaption><span class="role-label">Beispiel <span class="role-number">8-6</span>. </span>Statistische Anfrage 2: Was ist das Erscheinungsjahr des ältesten Buchs in der Datenbank?</figcaption><div style="display:flex"><pre style="width:20em; height:5em">SELECT <b>MIN</b>(year) AS earliest_year
FROM books</pre><table border="1"><thead><tr><th>query results</th></tr><tr><th>earliest_year</th></tr></thead><tbody><tr><td>1999</td></tr></tbody></table></div></figure><p>Außer COUNT und MIN gibt es noch folgende Aggregatfunktionen: <b>MAX</b> für maximale Werte, <b>AVG</b> für Durchschnittswerte und <b>SUM</b> für Summenbildung. Beispielsweise kann die Frage &quot;was ist der Durchschnittspreis der Bücher des Verlags Basic Books?&quot; folgendermaßen ausgedrückt werden: </p><figure class="role-example" id="Queries__lox__7"><figcaption><span class="role-label">Beispiel <span class="role-number">8-7</span>. </span>Statistische Anfrage 3: Was ist der Durchschnittspreis der Bücher des Verlags Basic Books?</figcaption><div style="display:flex"><pre style="width:20em; height:5em">SELECT <b>AVG</b>(price) AS average_price_of_Basic_Books
FROM books
WHERE publisher = 'Basic Books'</pre><table border="1"><thead><tr><th>query results</th></tr><tr><th>average_price_of_Basic_Books</th></tr></thead><tbody><tr><td>16,49</td></tr></tbody></table></div></figure></section><section><h4>Verschachtelte Abfragen</h4><p>Eine Abfrage kann anstelle von bestimmten Werten oder Tabellen auch Unterabfragen enthalten, die einen zu berechnenden Wert bzw. eine zu berechnende Tabelle repräsentieren.</p><p>Eine Variante der obigen Abfrage nach den Häufigkeiten von publzierten Büchern pro Verlag ergibt sich, wenn die durch <code>COUNT(publisher)</code> ausgedrückte absolute Häufigkeit durch eine relative Häufigkeit ersetzt wird. Dazu ist die absolute Häufigkeit durch die per <code>SELECT COUNT(*) FROM books </code>ermittelte Gesamtzahl der Tabellenzeilen zu dividieren. Es wird also ein zu berechnender Wert in einem Spaltenwertausdruck durch eine Unterabfrage ermittelt bzw. repräsentiert., wie in folgendem Beispiel gezeigt wird</p><figure class="role-example" id="Queries__lox__8"><figcaption><span class="role-label">Beispiel <span class="role-number">8-8</span>. </span>Welchen prozentualen Bücher-Anteil hat jeder Verlag?</figcaption><div style="display:flex"><pre style="width:20em; height:5em">SELECT publisher, 
  COUNT(publisher) / (SELECT COUNT(*) FROM books) AS perc_of_books 
FROM books
<b>GROUP BY</b> publisher</pre><table border="1"><thead><tr><th colspan="2">query results</th></tr><tr><th>publisher</th><th>perc_of_books</th></tr></thead><tbody><tr><td>Harper Business</td><td>0.25</td></tr><tr><td>Basic Books</td><td>0.5</td></tr><tr><td>Pearson International</td><td>0.25</td></tr></tbody></table></div></figure><p>Eine Unterabfrage kann auch in der durch die WHERE-Klausel ausgedrückten Selektionsbedingung vorkommen. Z.B. könnte von den selektierten Zeilen mit Hilfe einer <b>IN</b>-Bedingung verlangt werden, dass ihre Werte für ein Attribut <code>a1</code> in einer durch eine Unterabfrage berechneten Wertemenge vorkommt:</p><pre style="width:20em; height:5em">SELECT * FROM table1
WHERE a1 <b>IN</b> (SELECT a2 FROM table2 WHERE cond2)</pre><p>Oder es könnte verlangt werden, dass der Wert von <code>a1</code> kleiner als <em>alle</em> Werte einer Unterabfrage ist, was mit Hilfe von <b>ALL</b> geprüft werden kann:</p><pre style="width:20em; height:5em">SELECT * FROM table1
WHERE a1 &lt; <b>ALL</b> (SELECT a2 FROM table2 WHERE cond2)</pre><p>Auf ähnliche Weise kann mit <b>ANY</b> statt ALL geprüft werden, ob ein Wert kleiner als <em>irgendein</em> Wert einer Unterabfrage ist. Schließlich kann mit Hilfe von <b>EXISTS</b> geprüft werden, ob eine Unterabfrage ein nicht-leeres Resultat hat, es also wenigstens einen Wert bzw. eine Zeile im Resultat gibt.</p></section><section><h4>Abfragen mit mehreren Tabellen</h4><p>Der Informationsbestand einer Datenbank ist über eine Menge von Tabellen aufgeteilt. Immer wenn bei einer Abfrage Informationen aus mehr als einer Tabelle benötigt werden, müssen diese Tabellen in der Abfrage miteinander verbunden werden. Es gibt verschiedene Tabellen-Verbindungsoperationen. Die wichtigste heißt <em>innerer Verbund</em> (engl. <em>inner join</em>). Alle Verbund-Operationen basieren auf dem <em>Kartesischen Produkt</em> zweier Tabellen, <i>T</i><sub>1</sub> × <i>T</i><sub>2</sub>, das wie in der Mengenlehre als Menge aller möglichen Kombinationen definiert ist. </p><p>Um ein überschaubares Beispiel für ein Kartesisches Produkt zu erhalten, betrachten wir folgende vereinfachte Bibliotheksdatenbank:</p><div style="display:flex"><table border="1"><thead><tr><th colspan="3">books</th></tr><tr><th><u>isbn</u></th><th>title</th><th>publisher</th></tr></thead><tbody><tr><td>006251587X</td><td>Weaving the Web</td><td>Harper Business</td></tr><tr><td>0465026567</td><td>Gödel, Escher, Bach</td><td>Basic Books</td></tr></tbody></table><table border="1"><thead><tr><th colspan="2">publishers</th></tr><tr><th><u>name</u></th><th>address</th></tr></thead><tbody><tr><td>Basic Books</td><td>New York, USA</td></tr><tr><td>Pearson International</td><td>London, Great Britain</td></tr><tr><td>Harper Business</td><td>New York, USA</td></tr></tbody></table></div><p>Für diese beiden Tabellen erhalten wir folgendes Kartesische Produkt:</p><table border="1"><thead><tr><th colspan="5">books × publishers</th></tr><tr><th><u>isbn</u></th><th>title</th><th>publisher</th><th>name</th><th>address</th></tr></thead><tbody><tr><td>006251587X</td><td>Weaving the Web</td><td>Harper Business</td><td>Basic Books</td><td>New York, USA</td></tr><tr><td>006251587X</td><td>Weaving the Web</td><td>Harper Business</td><td>Pearson International</td><td>London, Great Britain</td></tr><tr><td>006251587X</td><td>Weaving the Web</td><td>Harper Business</td><td>Harper Business</td><td>New York, USA</td></tr><tr><td>0465026567</td><td>Gödel, Escher, Bach</td><td>Basic Books</td><td>Basic Books</td><td>New York, USA</td></tr><tr><td>0465026567</td><td>Gödel, Escher, Bach</td><td>Basic Books</td><td>Pearson International</td><td>London, Great Britain</td></tr><tr><td>0465026567</td><td>Gödel, Escher, Bach</td><td>Basic Books</td><td>Harper Business</td><td>New York, USA</td></tr></tbody></table><p>Dies entspricht folgender SQL-Abfrage:</p><pre>SELECT * FROM books, publishers</pre><p>Ein innerer Verbund zweier Tabellen <i>T</i><sub>1</sub> und <i>T</i><sub>2</sub> mit Verbundbedingung <i>C</i> ist eine Selektion des Kartesischen Produkts <i>T</i><sub>1</sub> × <i>T</i><sub>2</sub>. Symbolisch:</p><div class="informalfigure"><i>T</i><sub>1</sub> ⨝<sub><i>C</i></sub> <i>T</i><sub>2</sub> = Sel( <i>C</i>, <i>T</i><sub>1</sub> × <i>T</i><sub>2</sub>)</div><p>Ein Beispiel ist der innere Verbund </p><div class="informalfigure"><i>books</i> ⨝<sub><i>publisher=name</i></sub> <i>publishers</i>,</div><p>der es erlaubt, Informationen aus beiden Tabellen (den Buchtitel, den Verlag und seine Adresse) pro Buch wie in <a class="role-example-ref" href="#Queries__exQueryJoin"><span class="role-label">Beispiel <span class="role-number">8-9</span></span></a> zusammenzuführen.</p><figure class="role-example" id="Queries__exQueryJoin"><figcaption><span class="role-label">Beispiel <span class="role-number">8-9</span>. </span>Erstelle eine Liste aller erfassten Bücher mit Buchtitel, Verlag und Verlagsadresse</figcaption><div style="display:flex"><pre style="width:20em; height:5em">SELECT title, publisher, address
FROM books <b>INNER JOIN</b> publishers <b>ON</b> books.publisher = publishers.name</pre><table border="1"><thead><tr><th colspan="3">query results</th></tr><tr><th>title</th><th>publisher</th><th>address</th></tr></thead><tbody><tr><td>Weaving the Web</td><td>Harper Business</td><td>New York, USA</td></tr><tr><td>Gödel, Escher, Bach</td><td>Basic Books</td><td>New York, USA</td></tr></tbody></table></div></figure><p>Alternativ kann eine solche Verbundabfrage auch ohne die Verbundbildung in der FROM-Klausel als Kombination aus Selektion (in der WHERE-Klausel) und Kartesischem Produkt (in der FROM-Klausel) formuliert werden:</p><pre style="width:20em; height:5em">SELECT title, publisher, address
FROM books, publishers
WHERE books.publisher = publishers.name</pre><p>Wenn man in MS Access Beziehungen zwischen den in einer Abfrage beteiligten Tabellen definiert hat, werden entsprechende Verbund-Abfragen auf der Basis dieser Beziehungen vorgeschlagen. </p></section><section><h4>Vereinigung und Differenz</h4><p>Während die Verbund-Operation zur Auswertung einer konjunktiven (AND) Anfrage dient, werden zur Auswertung von disjunktiven (OR) bzw. konjunktiv-negierten (AND-NOT) Anfragen die Tabellenoperationen Vereinigung (UNION) und Differenz (EXCEPT) verwendet.</p><p>Wir betrachten folgendes DB-Schema:</p><div class="indented"><p><b><i>people</i></b> = ⟨ <u>id</u>, name⟩</p><p><b><i>movies</i></b> = ⟨ <u>id</u>, title, release_date, director⟩</p><b><i>people_as_actors_in_movies</i></b> = ⟨ person_id, movie_id⟩</div><p>Zu diesem Schema können wir folgende Abfragen definieren:</p><figure class="role-example" id="Queries__lox__10"><figcaption><span class="role-label">Beispiel <span class="role-number">8-10</span>. </span>Erstelle eine Liste (von Personenkennzeichen) aller Schauspieler und Regisseure</figcaption><pre>SELECT director FROM movies <b>UNION</b> 
   SELECT person_id FROM people_as_actors_in_movies</pre></figure><figure class="role-example" id="Queries__lox__11"><figcaption><span class="role-label">Beispiel <span class="role-number">8-11</span>. </span>Welche Regisseure sind keine Schauspieler?</figcaption><pre>SELECT director FROM movies <b>EXCEPT</b> 
   SELECT person_id FROM people_as_actors_in_movies</pre></figure></section></section></main><footer class="page-navigation"><table><tr><td class="page-navigation-to-first"><a href="InformationManagement.html"><span class="page-navigation-to-first-icon" title="Erste Seite
Information Management"></span></a></td><td class="page-navigation-to-previous"><a href="DataManipulation.html"><span class="page-navigation-to-previous-icon" title="Vorherige Seite
7.3. Inserting, Updating and Deleting Records"></span></a></td><td class="page-navigation-previous"><span>7.3. Inserting, Updating and Deleting Records</span></td><td class="page-navigation-current"><span>Chapter 8. Database Queries</span> <span class="page-navigation-current-page">(37 / 42)</span></td><td class="page-navigation-next"><span>Chapter 9. Database Design</span></td><td class="page-navigation-to-next"><a href="index-2.html"><span class="page-navigation-to-next-icon" title="Nächste Seite
Chapter 9. Database Design"></span></a></td><td class="page-navigation-to-last"><a href="_index.html"><span class="page-navigation-to-last-icon" title="Letzte Seite
Index"></span></a></td></tr></table></footer></body>
<!-- Mirrored from web-engineering.info/book/InformationManagement/Queries.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 21 Jul 2023 11:02:29 GMT -->
</html>